<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>test2</title>
    <link href="/2023/06/24/test2/"/>
    <url>/2023/06/24/test2/</url>
    
    <content type="html"><![CDATA[<p><img src="/imgs/$%7Bfiilename%7D/image-20230624225934675.png" alt="image-20230624225934675"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>数据结构-考点范围</title>
    <link href="/2023/06/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E8%80%83%E7%82%B9%E8%8C%83%E5%9B%B4/"/>
    <url>/2023/06/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E8%80%83%E7%82%B9%E8%8C%83%E5%9B%B4/</url>
    
    <content type="html"><![CDATA[<h1 id="一、哈夫曼树🌟-第5章-二叉树"><a href="#一、哈夫曼树🌟-第5章-二叉树" class="headerlink" title="一、哈夫曼树🌟(第5章-二叉树)"></a>一、哈夫曼树🌟(第5章-二叉树)</h1><h1 id="二、如何构造二叉树并画出来（第5章-二叉树）"><a href="#二、如何构造二叉树并画出来（第5章-二叉树）" class="headerlink" title="二、如何构造二叉树并画出来（第5章-二叉树）"></a>二、如何构造二叉树并画出来（第5章-二叉树）</h1><h1 id="三、深度优先和广度优先（第6章-图-图的遍历）"><a href="#三、深度优先和广度优先（第6章-图-图的遍历）" class="headerlink" title="三、深度优先和广度优先（第6章-图-图的遍历）"></a>三、深度优先和广度优先（第6章-图-图的遍历）</h1><h1 id="四、领接表和矩阵（第6章-图-图的存储结构）"><a href="#四、领接表和矩阵（第6章-图-图的存储结构）" class="headerlink" title="四、领接表和矩阵（第6章-图-图的存储结构）"></a>四、领接表和矩阵（第6章-图-图的存储结构）</h1><h1 id="五、最小生成树（第6章-图-图的应用）"><a href="#五、最小生成树（第6章-图-图的应用）" class="headerlink" title="五、最小生成树（第6章-图-图的应用）"></a>五、最小生成树（第6章-图-图的应用）</h1><h1 id="六、AVL树（第7章-查找）"><a href="#六、AVL树（第7章-查找）" class="headerlink" title="六、AVL树（第7章-查找）"></a>六、AVL树（第7章-查找）</h1><h1 id="七、散列表散列查找（第7章-查找-散列表的查找）"><a href="#七、散列表散列查找（第7章-查找-散列表的查找）" class="headerlink" title="七、散列表散列查找（第7章-查找-散列表的查找）"></a>七、散列表散列查找（第7章-查找-散列表的查找）</h1><h1 id="八、二叉排序树（第7章-查找-树表的查找）"><a href="#八、二叉排序树（第7章-查找-树表的查找）" class="headerlink" title="八、二叉排序树（第7章-查找-树表的查找）"></a>八、二叉排序树（第7章-查找-树表的查找）</h1><h1 id="九、排序算法（第8章排序）🌟"><a href="#九、排序算法（第8章排序）🌟" class="headerlink" title="九、排序算法（第8章排序）🌟"></a>九、排序算法（第8章排序）🌟</h1>]]></content>
    
    
    <categories>
      
      <category>考试复习</category>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
      <tag>考试复习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构-书本复习</title>
    <link href="/2023/06/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%88%B7%E9%A2%98-%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <url>/2023/06/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%88%B7%E9%A2%98-%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<p><img src="/../_posts/images/image-20230624223542884.png" alt="image-20230624223542884"></p>]]></content>
    
    
    <categories>
      
      <category>考试复习</category>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
      <tag>考试复习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构-书本复习</title>
    <link href="/2023/06/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%B9%A6%E6%9C%AC%E5%A4%8D%E4%B9%A0/"/>
    <url>/2023/06/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%B9%A6%E6%9C%AC%E5%A4%8D%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id=""><a href="#" class="headerlink" title=""></a></h1><h1 id="一、"><a href="#一、" class="headerlink" title="一、"></a>一、</h1>]]></content>
    
    
    <categories>
      
      <category>考试复习</category>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
      <tag>考试复习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构-刷题</title>
    <link href="/2023/06/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%88%B7%E9%A2%98/"/>
    <url>/2023/06/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%88%B7%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="第一周测验"><a href="#第一周测验" class="headerlink" title="第一周测验"></a>第一周测验</h1><h2 id="1、单选-2分-计算机所处理的数据一般具备某种内在联系，这是指（-）。"><a href="#1、单选-2分-计算机所处理的数据一般具备某种内在联系，这是指（-）。" class="headerlink" title="1、单选(2分)计算机所处理的数据一般具备某种内在联系，这是指（ ）。"></a>1、单选(2分)计算机所处理的数据一般具备某种内在联系，这是指（ ）。</h2><p>A.数据和数据之间存在某种关系<br>B.元素和元素之间存在某种关系<br>C.元素内部具有某种结构<br>D.数据项和数据项之间存在某种关系<br><strong>正确答案：B</strong><br>解析： B、在<a href="https://so.csdn.net/so/search?q=%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84&spm=1001.2101.3001.7020">数据结构</a>中讨论的关系指的是元素和元素之间的关系。</p><p><strong>课本考据：数据是描述客观事物的数和字符的集合，人们通常以数据元素作为数据的基本单位。其中数据元素也成为元素、结点、顶点或者记录。</strong></p><h2 id="2、单选-2分-在数据结构中，与所使用的计算机无关的是数据的（-）结构。"><a href="#2、单选-2分-在数据结构中，与所使用的计算机无关的是数据的（-）结构。" class="headerlink" title="2、单选(2分)在数据结构中，与所使用的计算机无关的是数据的（ ）结构。"></a>2、单选(2分)在数据结构中，与所使用的计算机无关的是数据的（ ）结构。</h2><p>A.逻辑<br>B.存储<br>C.逻辑和存储<br>D.物理<br><strong>正确答案：A</strong><br>解析： A、逻辑结构与存储结构无关，也就是与使用的计算机无关。</p><p><strong>课本考据：数据的逻辑结构由数据元素之间的逻辑关系构成，数据逻辑结构与数据的存储无关，是独立于计算机的，因此数据的逻辑结构可以看作是从具体问题抽象出来的数学模型。</strong></p><h2 id="3、单选-2分-在计算机中存储数据时，通常不仅要存储各数据元素的值，而且还要存储（-）。"><a href="#3、单选-2分-在计算机中存储数据时，通常不仅要存储各数据元素的值，而且还要存储（-）。" class="headerlink" title="3、单选(2分)在计算机中存储数据时，通常不仅要存储各数据元素的值，而且还要存储（ ）。"></a>3、单选(2分)在计算机中存储数据时，通常不仅要存储各数据元素的值，而且还要存储（ ）。</h2><p>A.数据的处理方法<br>B.数据元素的类型<br>C.数据元素之间的关系<br>D.数据的存储方法<br><strong>正确答案：C</strong><br>解析： C、将数据逻辑结构映射成存储数据时，需要存储所有数据元素的值和数据元素之间关系。</p><h2 id="4、单选-2分-数据结构在计算机内存中的表示是指（-）。"><a href="#4、单选-2分-数据结构在计算机内存中的表示是指（-）。" class="headerlink" title="4、单选(2分)数据结构在计算机内存中的表示是指（ ）。"></a>4、单选(2分)数据结构在计算机内存中的表示是指（ ）。</h2><p>A.数据的存储结构<br>B.数据结构<br>C.数据的逻辑结构<br>D.数据元素之间的关系<br><strong>正确答案：A</strong><br>解析： A、数据的存储结构是逻辑结构在计算机内存中的表示，它既保存数据元素，也保存数据元素之间的关系。</p><p><strong>课本考据：数据逻辑结构在计算机存储器中的存储表示成为数据的存储结构（也称为映像），也就是逻辑结构在计算机中的存储实现。</strong></p><h2 id="5、单选-2分-数据在计算机的存储器中表示时，逻辑上相邻的两个元素对应的物理地址也是相邻的，这种存储结构称之为（-）。"><a href="#5、单选-2分-数据在计算机的存储器中表示时，逻辑上相邻的两个元素对应的物理地址也是相邻的，这种存储结构称之为（-）。" class="headerlink" title="5、单选(2分)数据在计算机的存储器中表示时，逻辑上相邻的两个元素对应的物理地址也是相邻的，这种存储结构称之为（ ）。"></a>5、单选(2分)数据在计算机的存储器中表示时，逻辑上相邻的两个元素对应的物理地址也是相邻的，这种存储结构称之为（ ）。</h2><p>A.逻辑结构<br>B.顺序存储结构<br>C.链式存储结构<br>D.以上都对<br><strong>正确答案：B</strong><br>解析： B、顺序存储结构是逻辑结构的一种直接映射，通过数据元素之间的物理关系来表示逻辑关系。</p><p><strong>课本考据：顺序存储结构的定义——是采用一组连续的存储单元存放的数据元素，也就是说所有数据元素在存储器中占有一整块存储空间，而且两个逻辑上相邻的元素在存储器中的存储位置也相邻。</strong></p><h2 id="6、单选-2分-数据采用链式存储结构时，要求（-）。"><a href="#6、单选-2分-数据采用链式存储结构时，要求（-）。" class="headerlink" title="6、单选(2分)数据采用链式存储结构时，要求（ ）。"></a>6、单选(2分)数据采用链式存储结构时，要求（ ）。</h2><p>A.每个节点占用一片连续的存储区域<br>B.所有节点占用一片连续的存储区域<br>C.节点的最后一个域必须是指针域<br>D.每个节点有多少后继节点，就必须设多少个指针域<br><strong>正确答案：A</strong><br>解析： A、在链式存储结构中，通常一个结点是整体分配存储空间的，所以每个结点占用一片连续的存储区域，所有结点的存储地址既可以连续也可以不连续，所以所有结点不一定占用一片连续的存储区域。</p><p><strong>课本考据：在链式存储结构中，每个逻辑元素用一个内存节点存储，每个节点是单独分配的，所有的节点地址不一定是连续的，所有无须占用一整块存储空间。</strong></p><h2 id="7、单选-2分-可以用（-）定义一个完整的数据结构。"><a href="#7、单选-2分-可以用（-）定义一个完整的数据结构。" class="headerlink" title="7、单选(2分)可以用（ ）定义一个完整的数据结构。"></a>7、单选(2分)可以用（ ）定义一个完整的数据结构。</h2><p>A.数据元素<br>B.数据对象<br>C.数据关系<br>D.抽象数据类型<br><strong>正确答案：D</strong><br>解析： D、抽象数据类型指的是用户进行软件系统设计时从问题的数学模型中抽象出来的逻辑数据结构和逻辑数据结构上的运算，可以定义一个完整的数据结构。</p><p><strong>补充：抽象数据类型不考虑计算机的具体存储结构和运算的具体实现算法。</strong></p><h2 id="8、单选-2分-算法指的是（-）。"><a href="#8、单选-2分-算法指的是（-）。" class="headerlink" title="8、单选(2分)算法指的是（ ）。"></a>8、单选(2分)算法指的是（ ）。</h2><p>A.计算机程序<br>B.解决问题的方法<br>C.查找或排序过程<br>D.求解特定问题的指令有限序列<br><strong>正确答案：D</strong><br>解析： D、算法是求解特定问题的指令有限序列。</p><p><strong>补充：数据元素之间有逻辑关系和物理关系，对应的运算有基于逻辑结构的运算描述和居于存储结构的运算实现——通常我们把基于存储结构的运算实现的步骤或过程称为算法。</strong></p><h2 id="9、单选-2分-在算法设计时，若实参和形参同步发生改变，则应把形参变量说明为（-）型参数。"><a href="#9、单选-2分-在算法设计时，若实参和形参同步发生改变，则应把形参变量说明为（-）型参数。" class="headerlink" title="9、单选(2分)在算法设计时，若实参和形参同步发生改变，则应把形参变量说明为（ ）型参数。"></a>9、单选(2分)在算法设计时，若实参和形参同步发生改变，则应把形参变量说明为（ ）型参数。</h2><p>A.指针<br>B.引用<br>C.传值<br>D.常数<br><strong>正确答案：B</strong><br>解析： B、函数的形参变量与对应的实参共享相同的存储空间，可以将形参值回传给对应的实参。</p><h2 id="10、单选-2分-某算法的时间复杂度为O-n2-，表明该算法的（-）。"><a href="#10、单选-2分-某算法的时间复杂度为O-n2-，表明该算法的（-）。" class="headerlink" title="10、单选(2分)某算法的时间复杂度为O(n2)，表明该算法的（ ）。"></a>10、单选(2分)某算法的时间复杂度为O(n2)，表明该算法的（ ）。</h2><p>A.问题规模是<br>B.执行时间等于<br>C.执行时间与n2成正比<br>D.问题规模与n2成正比<br><strong>正确答案：C</strong><br>解析： C、<strong>算法的时间复杂度是问题规模n的函数，某算法的时间复杂度为O(n2),表示该算法的频度为cn2（c为一个正常量），即执行时间与n2成正比。</strong></p><h1 id="第二周测验"><a href="#第二周测验" class="headerlink" title="第二周测验"></a>第二周测验</h1><h2 id="1、单选-2分-线性表是（-）。"><a href="#1、单选-2分-线性表是（-）。" class="headerlink" title="1、单选(2分)线性表是（ ）。"></a>1、单选(2分)<a href="https://so.csdn.net/so/search?q=%E7%BA%BF%E6%80%A7%E8%A1%A8&spm=1001.2101.3001.7020">线性表</a>是（ ）。</h2><p>A.一个有限序列，可以为空<br>B.一个有限序列，不可以为空<br>C.一个无限序列，可以为空<br>D.一个无限序列，不可以为空<br><strong>正确答案：A</strong><br>解析： A、线性表是具有n（n≥0）个数据元素的有限序列。</p><p><strong>课本考据：线性表是具有相同特征的数据元素的一个有限序列。当 n&#x3D;0时，表示线性表是一个空表，即不包含任何元素。</strong></p><h2 id="2、单选-2分-线性表的基本运算ListInsert-amp-L-i-e-表示在线性表L中第i个位置上插入一个元素e，若L的长度为n，则i的合法取值是（-）。"><a href="#2、单选-2分-线性表的基本运算ListInsert-amp-L-i-e-表示在线性表L中第i个位置上插入一个元素e，若L的长度为n，则i的合法取值是（-）。" class="headerlink" title="2、单选(2分)线性表的基本运算ListInsert(&amp;L,i,e)表示在线性表L中第i个位置上插入一个元素e，若L的长度为n，则i的合法取值是（ ）。"></a>2、单选(2分)线性表的基本运算ListInsert(&amp;L,i,e)表示在线性表L中第i个位置上插入一个元素e，若L的长度为n，则i的合法取值是（ ）。</h2><p>A.1≤i≤n<br>B.1≤i≤n+1<br>C.0≤i≤n-1<br>D. 0≤i≤n<br><strong>正确答案：B</strong><br>解析： B、线性表的基本运算ListInsert(&amp;L，i，e)中，位置i是指逻辑序号，可以在L的位置1到位置n+1插入元素。</p><p><strong>课本考据：插入数据元素，在L的第i（1&lt;&#x3D;i&lt;&#x3D;n+1）个位置插入一个新的元素e，L的长度增一。</strong></p><h2 id="3、单选-2分-顺序表具有随机存取特性，指的是（-）。"><a href="#3、单选-2分-顺序表具有随机存取特性，指的是（-）。" class="headerlink" title="3、单选(2分)顺序表具有随机存取特性，指的是（ ）。"></a>3、单选(2分)顺序表具有随机存取特性，指的是（ ）。</h2><p>A.查找值为x的元素与顺序表中元素个数n无关<br>B.查找值为x的元素与顺序表中元素个数n有关<br>C.查找序号为i的元素与顺序表中元素个数n无关<br>D.查找序号为i的元素与顺序表中元素个数n有关<br><strong>正确答案：C</strong><br>解析： C、一种存储结构具有随机存取特性指的是，对于给定的序号i，在O(1)时间内找到对应元素值。</p><p><strong>课本考据：顺序表示线性表的直接映射，可从求线性表中的某个数据元素的值的算法得知<br>&#x3D;&gt;<br>一个没有循环（或者有循环，但循环的次数与问题规模 n无关）的算法中原操作执行次数与问题规模无关，记作O（1），也成为常数阶</strong>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">bool</span> <span class="hljs-title function_">GetElem</span><span class="hljs-params">(SqList * L,<span class="hljs-type">int</span> i, ElemType &amp;e)</span><br>&#123;<br><span class="hljs-keyword">if</span>(i&lt;<span class="hljs-number">1</span> || i&gt;L-&gt;length)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>e=L-&gt;data[i<span class="hljs-number">-1</span>];<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-number">1234567</span><br></code></pre></td></tr></table></figure><h2 id="4、单选-2分-在顺序表中删除一个元素所需要的时间（-）。"><a href="#4、单选-2分-在顺序表中删除一个元素所需要的时间（-）。" class="headerlink" title="4、单选(2分)在顺序表中删除一个元素所需要的时间（ ）。"></a>4、单选(2分)在顺序表中删除一个元素所需要的时间（ ）。</h2><p>A.与删除元素的位置及顺序表的长度都有关<br>B.只与删除元素的位置有关<br>C.与删除任何其他元素所需要的时间相等<br>D.只与顺序表的长度有关<br><strong>正确答案：A</strong><br>解析： A、当从顺序表中删除元素时，为了保持顺序表的逻辑特性，需要移动元素以覆盖该删除的元素。因此在顺序表中删除一个元素与该元素的位置及顺序表的长度都有关。</p><p><strong>课本考据：元素移动的次数与表长n&#x3D;L-&gt;length和删除元素的位置i有关，共有n个元素可被删除。</strong></p><h2 id="5、单选-2分-在n（n-gt-1）个运算的顺序表中，算法时间复杂度为O-1-的运算是（-）。"><a href="#5、单选-2分-在n（n-gt-1）个运算的顺序表中，算法时间复杂度为O-1-的运算是（-）。" class="headerlink" title="5、单选(2分)在n（n&gt;1）个运算的顺序表中，算法时间复杂度为O(1)的运算是（ ）。"></a>5、单选(2分)在n（n&gt;1）个运算的顺序表中，算法时间复杂度为O(1)的运算是（ ）。</h2><p>A.访问第i个元素（2≤i≤n）并求其前驱元素<br>B.在第i个元素之后插入一个新元素<br>C.删除第i个元素<br>D.将这n个元素递增排序<br><strong>正确答案：A</strong><br>解析： A、访问第i个元素（2≤i≤n）即L-&gt;data[i-1]和求其前驱元素L-&gt;data[i-2]的时间复杂度均为O(1)。</p><p><strong>课本考据：元素移动的次数不仅与表长n&#x3D;L-&gt;length有关，而且与插入、删除的位置i有关，平均时间复杂度为O（n）。</strong></p><h2 id="6、单选-2分-关于线性表的顺序存储结构和链式存储结构的描述中，正确的是（-）。"><a href="#6、单选-2分-关于线性表的顺序存储结构和链式存储结构的描述中，正确的是（-）。" class="headerlink" title="6、单选(2分)关于线性表的顺序存储结构和链式存储结构的描述中，正确的是（ ）。"></a>6、单选(2分)关于线性表的顺序存储结构和链式存储结构的描述中，正确的是（ ）。</h2><p>Ⅰ.线性表的顺序存储结构优于链式存储结构<br>Ⅱ.顺序存储结构比链式存储结构的存储密度高<br>Ⅲ.如需要频繁插入和删除元素，最好采用顺序存储结构<br>Ⅳ.如需要频繁插入和删除元素，最好采用链式存储结构<br>A.Ⅰ、Ⅱ、Ⅲ<br>B.Ⅱ、Ⅳ<br>C.Ⅱ、Ⅲ<br>D.Ⅲ、Ⅳ<br><strong>正确答案：B</strong><br>解析： B、线性表的顺序存储结构和链式存储结构各有优缺点，不能简单比较好坏，所以Ⅰ错误。链式存储结构使用指针表示逻辑关系，所以存储密度比较低，所以Ⅱ正确。如频繁使用插入和删除操作，链式存储结构更优于顺序存储结构，所以Ⅲ错误，Ⅳ正确。</p><h2 id="7、单选-2分-在单链表中，增加一个头节点的目的是为了（-）。"><a href="#7、单选-2分-在单链表中，增加一个头节点的目的是为了（-）。" class="headerlink" title="7、单选(2分)在单链表中，增加一个头节点的目的是为了（ ）。"></a>7、单选(2分)在单链表中，增加一个头节点的目的是为了（ ）。</h2><p>A.使单链表至少有一个节点<br>B.标识链表中某个重要节点的位置<br>C.方便插入和删除运算的实现<br>D.表示单链表是线性表的链式存储结构<br><strong>正确答案：C</strong><br>解析： C、在单链表中增加一个头节点的主要目的是使删除和插入节点操作更简单，方便运算的实现。</p><h2 id="8、单选-2分-通过含有n（n≥1）个元素的数组a，采用头插法建立一个单链表L，则L中节点值的次序（-）。"><a href="#8、单选-2分-通过含有n（n≥1）个元素的数组a，采用头插法建立一个单链表L，则L中节点值的次序（-）。" class="headerlink" title="8、单选(2分)通过含有n（n≥1）个元素的数组a，采用头插法建立一个单链表L，则L中节点值的次序（ ）。"></a>8、单选(2分)通过含有n（n≥1）个元素的数组a，采用头插法建立一个单链表L，则L中节点值的次序（ ）。</h2><p>A.与数组a的元素次序相同<br>B.与数组a的元素次序相反<br>C.与数组a的元素次序无关<br>D.以上都不对<br><strong>正确答案：B</strong><br>解析： B、采用头插法建立单链表时，后面的节点插入到最前端，所以L的节点值次序与数组a的元素次序相反。</p><h2 id="9、单选-2分-某算法在含有n（n≥1）个节点的单链表中查找值为x节点，其时间复杂度是（-）。"><a href="#9、单选-2分-某算法在含有n（n≥1）个节点的单链表中查找值为x节点，其时间复杂度是（-）。" class="headerlink" title="9、单选(2分)某算法在含有n（n≥1）个节点的单链表中查找值为x节点，其时间复杂度是（ ）。"></a>9、单选(2分)某算法在含有n（n≥1）个节点的单链表中查找值为x节点，其时间复杂度是（ ）。</h2><p>A.O(log2n)<br>B.O(1)<br>C.O(n2)<br>D.O(n)<br><strong>正确答案：D</strong><br>解析： D、需要从首节点出发逐一查找每个节点。</p><p><strong>课本考据：按元素值查找的算法在单链表L中从头开始找第一个值域与e相等的结点，若存在这样的结点，则返回逻辑序号，否则返回0；</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">LocateElem</span><span class="hljs-params">(LinkNode * ElemType)</span><br>&#123;<br><span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;<br>LinkNode * p=L-&gt;next;<br><span class="hljs-keyword">while</span>(p != UNLL &amp;&amp; p-&gt;data != e)<br>&#123;<br>p=p-&gt;next;<br>i++;<br>&#125;<br><span class="hljs-keyword">if</span>(p==<span class="hljs-literal">NULL</span>)<br><span class="hljs-keyword">return</span>(<span class="hljs-number">0</span>);<br><span class="hljs-keyword">else</span><br><span class="hljs-keyword">return</span>(i);<br>&#125;<br><span class="hljs-number">1234567891011121314</span><br></code></pre></td></tr></table></figure><h2 id="10、单选-2分-在长度为n（n≥1）的单链表中删除尾节点的时间复杂度为（-）。"><a href="#10、单选-2分-在长度为n（n≥1）的单链表中删除尾节点的时间复杂度为（-）。" class="headerlink" title="10、单选(2分)在长度为n（n≥1）的单链表中删除尾节点的时间复杂度为（ ）。"></a>10、单选(2分)在长度为n（n≥1）的单链表中删除尾节点的时间复杂度为（ ）。</h2><p>A.O(1)<br>B.O(log2n)<br>C.O(n)<br>D.O(n2)<br><strong>正确答案：C</strong><br>解析： C、在长度为n（n≥1）的单链表中删除尾节点时，需要找倒数第2个节点，此时时间复杂度为O(n)。</p><p><strong>课本考据L：删除数据元素的实现过程是先在单链表L中找到第i-1个结点，由p指向它。若存在这样的结点，且也存在后继结点（也由p指向它），则删除q所指的结点，返回true；否则返回false，表示参数i错误。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">bool</span> <span class="hljs-title function_">ListDelete</span><span class="hljs-params">(LinkNode *&amp; L,<span class="hljs-type">int</span> i,ElemType &amp; e)</span><br>&#123;<br><span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;<br>LinkNode * p=L,*q;<br><span class="hljs-keyword">if</span>(i&lt;=<span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">while</span>(j&lt;i<span class="hljs-number">-1</span> &amp;&amp; p != <span class="hljs-literal">NULL</span>)<br>&#123;<br>j++;<br>p=p-&gt;next;<br>&#125;<br><span class="hljs-keyword">if</span>(p==<span class="hljs-literal">NULL</span>)<br>ruturn <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">else</span><br>&#123;<br>q=p-&gt;next;<br><span class="hljs-keyword">if</span>(q==<span class="hljs-literal">NULL</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>e=q-&gt;data;<br>p-&gt;next=q-&gt;next;<br><span class="hljs-built_in">free</span>(q);<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br>&#125;<span class="hljs-number">12345678910111213141516171819202122</span><br></code></pre></td></tr></table></figure><h2 id="11、单选-2分-关于线性表的正确说法是（-）。"><a href="#11、单选-2分-关于线性表的正确说法是（-）。" class="headerlink" title="11、单选(2分)关于线性表的正确说法是（ ）。"></a>11、单选(2分)关于线性表的正确说法是（ ）。</h2><p>A.每个元素都有一个前驱和一个后继元素<br>B.线性表中至少有一个元素<br>C.表中元素的排序顺序必须是由小到大或由大到小<br>D.除第一个元素和最后一个元素外，其余每个元素有且仅有一个前驱和一个后继元素<br><strong>正确答案：D</strong><br>解析： D、线性表属典型的线性结构。</p><h2 id="12、单选-2分-以下关于顺序表的叙述中，正确的是（-）。"><a href="#12、单选-2分-以下关于顺序表的叙述中，正确的是（-）。" class="headerlink" title="12、单选(2分)以下关于顺序表的叙述中，正确的是（ ）。"></a>12、单选(2分)以下关于顺序表的叙述中，正确的是（ ）。</h2><p>A.顺序表可以利用一维数组表示，因此顺序表与一维数组在结构上是一致的，它们可以通用<br>B.在顺序表中，逻辑上相邻的元素在物理位置上不一定相邻<br>C.顺序表和一维数组一样，都可以进行随机存取<br>D.在顺序表中每一个元素的类型不必相同<br><strong>正确答案：C</strong><br>解析： C、顺序表中所有元素必须连续存放，而一维数组中所有元素可以不连续存放，另外，一维数组只有按下标的存、取两个操作，而顺序表可以进行线性表的插入、删除等操作，所以选项A错误。在顺序表中，逻辑上相邻的元素在物理位置上也一定相邻，所以选项B错误。顺序表中每一个元素的类型必须相同，所以选项D错误。</p><h2 id="13、单选-2分-以下属于顺序表的优点是（-）。"><a href="#13、单选-2分-以下属于顺序表的优点是（-）。" class="headerlink" title="13、单选(2分)以下属于顺序表的优点是（ ）。"></a>13、单选(2分)以下属于顺序表的优点是（ ）。</h2><p>A.插入元素方便<br>B.删除元素方便<br>C.存储密度大<br>D.以上都不对<br><strong>正确答案：C</strong><br>解析： C、顺序表的存储密度为1，所以其存储密度大。</p><h2 id="14、单选-2分-设线性表中有n个元素，以下运算中，（-）在单链表上实现要比在顺序表上实现效率更高。"><a href="#14、单选-2分-设线性表中有n个元素，以下运算中，（-）在单链表上实现要比在顺序表上实现效率更高。" class="headerlink" title="14、单选(2分)设线性表中有n个元素，以下运算中，（ ）在单链表上实现要比在顺序表上实现效率更高。"></a>14、单选(2分)设线性表中有n个元素，以下运算中，（ ）在单链表上实现要比在顺序表上实现效率更高。</h2><p>A.删除指定位置元素的后一个元素<br>B.在尾元素的后面插入一个新元素<br>C.顺序输出前k个元素<br>D.交换第i个元素和第n-i+1个元素的值（i&#x3D;1，2，…，n）<br><strong>正确答案：A</strong><br>解析： A、在顺序表中插入元素和删除元素时需要移动较多元素，而在单链表上执行同样的操作不需要移动元素，只需修改相关节点的指针域。</p><h2 id="15、单选-2分-以下关于单链表的叙述中正确的是（-）。"><a href="#15、单选-2分-以下关于单链表的叙述中正确的是（-）。" class="headerlink" title="15、单选(2分)以下关于单链表的叙述中正确的是（ ）。"></a>15、单选(2分)以下关于单链表的叙述中正确的是（ ）。</h2><p>Ⅰ.节点除自身信息外还包括指针域，存储密度小于顺序表<br>Ⅱ.找第i个节点的时间为O(1)<br>Ⅲ.在插入、删除运算时不必移动节点<br>A.仅Ⅰ、Ⅱ<br>B.仅Ⅱ、Ⅲ<br>C.仅Ⅰ、Ⅲ<br>D.Ⅰ、Ⅱ、Ⅲ<br><strong>正确答案：C</strong><br>解析： C、单链表不具有随机存取特性，即不能在O(1)的时间内找到第i个节点。</p><p><strong>课本考据：在链表中，逻辑上相邻的元素对应的存储位置是通过指针来连接的，因而每个结点的存储位置可以任意安排，不必要求相邻，所以当进行插入或删除操作时只需要修改相关结点的指针域即可。（方便省时）</strong></p><hr><h1 id="第三周测验2"><a href="#第三周测验2" class="headerlink" title="第三周测验2"></a>第三周测验2</h1><h2 id="1、单选-2分-与单链表相比，双链表的优点之一是（-）。"><a href="#1、单选-2分-与单链表相比，双链表的优点之一是（-）。" class="headerlink" title="1、单选(2分)与单链表相比，双链表的优点之一是（ ）。"></a>1、单选(2分)与<a href="https://so.csdn.net/so/search?q=%E5%8D%95%E9%93%BE%E8%A1%A8&spm=1001.2101.3001.7020">单链表</a>相比，双链表的优点之一是（ ）。</h2><p>A.插入、删除操作更简单<br>B.可以进行随机访问<br>C.可以省略表头指针或表尾指针<br>D.访问前后相邻节点更方便<br><strong>正确答案：D</strong><br>解析： D、在双链表中可以访问任一节点的前后相邻节点，而单链表中只能访问任一节点的下一个节点。</p><p>课本考据：由于双链表的每个结点既包含一个指向后继结点的指针，又包含一个指向前驱结点的指针，所以当访问过一个结点后既可以依次向后访问每一个结点，也可以依次向前访问每一个结点。<strong>（双链表中每个结点有指向前后结点的指针即可访问前后结点）</strong></p><h2 id="2、单选-2分-带头节点的双链表L为空表时应满足（-）。"><a href="#2、单选-2分-带头节点的双链表L为空表时应满足（-）。" class="headerlink" title="2、单选(2分)带头节点的双链表L为空表时应满足（ ）。"></a>2、单选(2分)带头节点的双链表L为空表时应满足（ ）。</h2><p>A.L &#x3D;&#x3D; NULL<br>B.L-&gt;prior &#x3D;&#x3D; L-&gt;next<br>C.L-&gt;prior &#x3D;&#x3D; NULL<br>D.L-&gt;nex t &#x3D;&#x3D; NULL<br><strong>正确答案：D</strong></p><p><strong>课本考据：除了插入和删除结点，双链表其他运算的算法与单链表中相应的算法相同。</strong></p><h2 id="3、单选-2分-在长度为n（n≥1）的双链表中插入一个节点（非尾节点）要修改（-）个指针域。"><a href="#3、单选-2分-在长度为n（n≥1）的双链表中插入一个节点（非尾节点）要修改（-）个指针域。" class="headerlink" title="3、单选(2分)在长度为n（n≥1）的双链表中插入一个节点（非尾节点）要修改（ ）个指针域。"></a>3、单选(2分)在长度为n（n≥1）的双链表中插入一个节点（非尾节点）要修改（ ）个指针域。</h2><p>A.1<br>B.2<br>C.3<br>D.4<br><strong>正确答案：D</strong><br>解析： D、需要修改插入节点的prior、next域，前驱节点的next域和后继节点的prior域。</p><p><strong>课本考据：原理参考第二题，如图<img src="/images/20201110165354598.png" alt="在这里插入图片描述"></strong><br><strong>操作语句如下：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">s-&gt;next=p-&gt;next;<br>p-&gt;next-&gt;prior=s;<br>s-&gt;prior=p;<br>p-&gt;next=s;<br><span class="hljs-number">1234</span><br></code></pre></td></tr></table></figure><h2 id="4、单选-2分-对于长度为n（n≥1）的双链表L，在p所指节点之前插入一个新节点的算法的时间复杂度为（-）。"><a href="#4、单选-2分-对于长度为n（n≥1）的双链表L，在p所指节点之前插入一个新节点的算法的时间复杂度为（-）。" class="headerlink" title="4、单选(2分)对于长度为n（n≥1）的双链表L，在p所指节点之前插入一个新节点的算法的时间复杂度为（ ）。"></a>4、单选(2分)对于长度为n（n≥1）的双链表L，在p所指节点之前插入一个新节点的算法的时间复杂度为（ ）。</h2><p>A.O(1)<br>B.O(n)<br>C.O(n2)<br>D.O(nlog2n)<br><strong>正确答案：A</strong><br>解析： A、设新节点指针为q，操作是：p-&gt;prior-&gt;next&#x3D;p; q-&gt;prior&#x3D;p-&gt;prior; p-&gt;prior&#x3D;q; q-&gt;next&#x3D;p;</p><h2 id="5、单选-2分-在长度为n（n≥1）的双链表中删除一个节点（非尾节点）要修改（-）个指针域。"><a href="#5、单选-2分-在长度为n（n≥1）的双链表中删除一个节点（非尾节点）要修改（-）个指针域。" class="headerlink" title="5、单选(2分)在长度为n（n≥1）的双链表中删除一个节点（非尾节点）要修改（ ）个指针域。"></a>5、单选(2分)在长度为n（n≥1）的双链表中删除一个节点（非尾节点）要修改（ ）个指针域。</h2><p>A.1<br>B.2<br>C.3<br>D.4<br><strong>正确答案：B</strong><br>解析： B、需要修改前驱节点的next域和后继节点的prior域。</p><h2 id="6、单选-2分-与非循环单链表相比，循环单链表的主要优点是（-）。"><a href="#6、单选-2分-与非循环单链表相比，循环单链表的主要优点是（-）。" class="headerlink" title="6、单选(2分)与非循环单链表相比，循环单链表的主要优点是（ ）。"></a>6、单选(2分)与非循环单链表相比，循环单链表的主要优点是（ ）。</h2><p>A.不再需要头指针<br>B.已知某个节点的位置后，能够容易找到它的前驱节点<br>C.在进行插入、删除操作时，能更好地保证链表不断开<br>D.从表中任意节点出发都能扫描到整个链表<br><strong>正确答案：D</strong><br>解析： D、循环单链表中可以循环扫描，因此从表中任意节点出发都能扫描到整个链表。</p><h2 id="7、单选-2分-设有带头节点的循环单链表L，当这种链表成为空链表时，有（-）。"><a href="#7、单选-2分-设有带头节点的循环单链表L，当这种链表成为空链表时，有（-）。" class="headerlink" title="7、单选(2分)设有带头节点的循环单链表L，当这种链表成为空链表时，有（ ）。"></a>7、单选(2分)设有带头节点的循环单链表L，当这种链表成为空链表时，有（ ）。</h2><p>A.表头节点指针域next为空<br>B.L的值为NULL<br>C.表头节点的指针域next与L的值相等<br>D.表头节点的指针域next与L的地址相等<br><strong>正确答案：C</strong><br>解析： C、带头节点的循环单链表L成为空链表时满足L-&gt;next&#x3D;&#x3D;L，即表头节点<em>L的指针域next与L的值相等，而不是表头节点</em>L的指针域next与L的地址相等。</p><h2 id="8、单选-2分-在长度为n（n≥1）的循环双链表L中，删除尾节点的时间复杂度为（-）。"><a href="#8、单选-2分-在长度为n（n≥1）的循环双链表L中，删除尾节点的时间复杂度为（-）。" class="headerlink" title="8、单选(2分)在长度为n（n≥1）的循环双链表L中，删除尾节点的时间复杂度为（ ）。"></a>8、单选(2分)在长度为n（n≥1）的循环双链表L中，删除尾节点的时间复杂度为（ ）。</h2><p>A.O(1)<br>B.O(n)<br>C.O(n2)<br>D.O(nlog2n)<br><strong>正确答案：A</strong><br>解析： A、通过头节点指针直接找到尾节点，然后再删除该尾节点，对应的时间复杂度为O(1)。</p><h2 id="9、单选-2分-将两个分别含有m、n个节点的有序单链表归并成一个有序单链表，要求不破坏原有的单链表，对应算法的空间复杂度是（-）（MIN表示取最小值）。"><a href="#9、单选-2分-将两个分别含有m、n个节点的有序单链表归并成一个有序单链表，要求不破坏原有的单链表，对应算法的空间复杂度是（-）（MIN表示取最小值）。" class="headerlink" title="9、单选(2分)将两个分别含有m、n个节点的有序单链表归并成一个有序单链表，要求不破坏原有的单链表，对应算法的空间复杂度是（ ）（MIN表示取最小值）。"></a>9、单选(2分)将两个分别含有m、n个节点的有序单链表归并成一个有序单链表，要求不破坏原有的单链表，对应算法的空间复杂度是（ ）（MIN表示取最小值）。</h2><p>A.O(n)<br>B.O(m)<br>C.O(m+n)<br>D.O(MIN(m,n))<br><strong>正确答案：C</strong><br>解析： C、将两个有序单链表A、B归并到C中时，通过比较A、B中的节点，将比较小的节点复制到C中，复制次数为m+n，即新建m+n个节点，对应的空间复杂度为O(m+n)。</p><h2 id="10、单选-2分-已知两个长度分别为m-和n-的升序单链表，若将它们合并为一个长度为m-n-的降序单链表，则时间复杂度是（-）。"><a href="#10、单选-2分-已知两个长度分别为m-和n-的升序单链表，若将它们合并为一个长度为m-n-的降序单链表，则时间复杂度是（-）。" class="headerlink" title="10、单选(2分)已知两个长度分别为m 和n 的升序单链表，若将它们合并为一个长度为m+n 的降序单链表，则时间复杂度是（ ）。"></a>10、单选(2分)已知两个长度分别为m 和n 的升序单链表，若将它们合并为一个长度为m+n 的降序单链表，则时间复杂度是（ ）。</h2><p>A.O(n)<br>B.O(m×n)<br>C.O(m)<br>D.O(m+n)<br><strong>正确答案：D</strong></p><h2 id="11、单选-2分-在长度为n（n≥1）的双链表L中，删除p所指节点的时间复杂度为（-）。"><a href="#11、单选-2分-在长度为n（n≥1）的双链表L中，删除p所指节点的时间复杂度为（-）。" class="headerlink" title="11、单选(2分)在长度为n（n≥1）的双链表L中，删除p所指节点的时间复杂度为（ ）。"></a>11、单选(2分)在长度为n（n≥1）的双链表L中，删除p所指节点的时间复杂度为（ ）。</h2><p>A.O(1)<br>B.O(n)<br>C.O(n2)<br>D.O(nlog2n)<br><strong>正确答案：A</strong><br>解析： A、在双链表中，通过p所指节点可以找到前后节点，通过其前后节点来删除p所指节点，对应的时间复杂度为O(1)。</p><h2 id="12、单选-2分-在长度为n（n≥1）的循环单链表L中，删除尾节点的时间复杂度为（-）。"><a href="#12、单选-2分-在长度为n（n≥1）的循环单链表L中，删除尾节点的时间复杂度为（-）。" class="headerlink" title="12、单选(2分)在长度为n（n≥1）的循环单链表L中，删除尾节点的时间复杂度为（ ）。"></a>12、单选(2分)在长度为n（n≥1）的循环单链表L中，删除尾节点的时间复杂度为（ ）。</h2><p>A.O(1)<br>B.O(n)<br>C.O(n2)<br>D.O(nlog2n)<br><strong>正确答案：B</strong><br>解析： B、通过L查找到尾节点的前驱节点，然后删除尾节点，对应的时间复杂度为O(n)。</p><h2 id="13、单选-2分-在只有尾节点指针rear没有头节点的非空循环单链表中，删除尾节点的时间复杂度为（-）。"><a href="#13、单选-2分-在只有尾节点指针rear没有头节点的非空循环单链表中，删除尾节点的时间复杂度为（-）。" class="headerlink" title="13、单选(2分)在只有尾节点指针rear没有头节点的非空循环单链表中，删除尾节点的时间复杂度为（ ）。"></a>13、单选(2分)在只有尾节点指针rear没有头节点的非空循环单链表中，删除尾节点的时间复杂度为（ ）。</h2><p>A.O(1)<br>B.O(n)<br>C.O(n2)<br>D.O(nlog2n)<br><strong>正确答案：B</strong><br>解析： B、通过rear查找到尾节点的前驱节点，然后删除尾节点，对应的时间复杂度为O(n)。</p><h2 id="14、单选-2分-在只有尾节点指针rear没有头节点的非空循环单链表中，删除开始节点的时间复杂度为（-）。"><a href="#14、单选-2分-在只有尾节点指针rear没有头节点的非空循环单链表中，删除开始节点的时间复杂度为（-）。" class="headerlink" title="14、单选(2分)在只有尾节点指针rear没有头节点的非空循环单链表中，删除开始节点的时间复杂度为（ ）。"></a>14、单选(2分)在只有尾节点指针rear没有头节点的非空循环单链表中，删除开始节点的时间复杂度为（ ）。</h2><p>A.O(1)<br>B.O(n)<br>C.O(n2)<br>D.O(nlog2n)<br><strong>正确答案：A</strong><br>解析： A、通过rear指针直接删除开始节点。</p><h2 id="15、单选-2分-两个长度为n的双链表，节点类型相同，若以h1为头指针的双链表是非循环的，以h2为头指针指针的双链表是循环的，则（-）。"><a href="#15、单选-2分-两个长度为n的双链表，节点类型相同，若以h1为头指针的双链表是非循环的，以h2为头指针指针的双链表是循环的，则（-）。" class="headerlink" title="15、单选(2分)两个长度为n的双链表，节点类型相同，若以h1为头指针的双链表是非循环的，以h2为头指针指针的双链表是循环的，则（ ）。"></a>15、单选(2分)两个长度为n的双链表，节点类型相同，若以h1为头指针的双链表是非循环的，以h2为头指针指针的双链表是循环的，则（ ）。</h2><p>A.对于非循环双链表来说，删除首节点的操作，其时间复杂度都是O(n)<br>B.对于循环双链表来说，删除首节点的操作，其时间复杂度都是O(n)<br>C.对于非循环双链表来说，删除尾节点的操作，其时间复杂度都是O(1)<br>D.对于循环双链表来说，删除尾节点的操作，其时间复杂度都是O(1)<br><strong>正确答案：D</strong><br>解析： D、对于这两个双链表来说，删除首节点的操作的时间复杂度都是O(1)。对于非循环双链表来说，删除尾节点的操作的时间复杂度都是O(n)，对于循环双链表来说，删除尾节点的操作的时间复杂度都是O(1)。</p><hr><h1 id="第四周测验"><a href="#第四周测验" class="headerlink" title="第四周测验"></a>第四周测验</h1><h2 id="1、单选-2分-栈的“先进后出”特性是指（-）。"><a href="#1、单选-2分-栈的“先进后出”特性是指（-）。" class="headerlink" title="1、单选(2分)栈的“先进后出”特性是指（ ）。"></a>1、单选(2分)栈的“先进后出”特性是指（ ）。</h2><p>A.最后进栈的元素总是最先出栈<br>B.同时进行进栈和出栈操作时，总是进栈优先<br>C.每当有出栈操作时，总要先进行一次进栈操作<br>D.每次出栈的元素总是最先进栈的元素<br><strong>正确答案：A</strong></p><p><strong>课本考据：栈是一种只能在一端进行插入或删除操作的线性表。</strong></p><h2 id="2、单选-2分-给定一个足够大的空栈，有4个元素的进栈次序为A、B、C、D，则以C、D开头的出栈序列的个数为（-）。"><a href="#2、单选-2分-给定一个足够大的空栈，有4个元素的进栈次序为A、B、C、D，则以C、D开头的出栈序列的个数为（-）。" class="headerlink" title="2、单选(2分)给定一个足够大的空栈，有4个元素的进栈次序为A、B、C、D，则以C、D开头的出栈序列的个数为（ ）。"></a>2、单选(2分)给定一个足够大的空栈，有4个元素的进栈次序为A、B、C、D，则以C、D开头的出栈序列的个数为（ ）。</h2><p>A.1<br>B.2<br>C.3<br>D.4<br><strong>正确答案：A</strong><br>解析： A、若出栈序列为CD…，则A、B、C进栈，C出栈，D进栈，D出栈，此后只有B出栈和A出栈一种情况，所以这样的出栈序列只有CDBA一个。</p><h2 id="3、单选-2分-若元素a、b、c、d、e、f依次进栈，允许进栈、退栈的操作交替进行，但不允许连续3次退栈工作，则不可能得到的出栈序列是（-）。"><a href="#3、单选-2分-若元素a、b、c、d、e、f依次进栈，允许进栈、退栈的操作交替进行，但不允许连续3次退栈工作，则不可能得到的出栈序列是（-）。" class="headerlink" title="3、单选(2分)若元素a、b、c、d、e、f依次进栈，允许进栈、退栈的操作交替进行，但不允许连续3次退栈工作，则不可能得到的出栈序列是（ ）。"></a>3、单选(2分)若元素a、b、c、d、e、f依次进栈，允许进栈、退栈的操作交替进行，但不允许连续3次退栈工作，则不可能得到的出栈序列是（ ）。</h2><p>A.dcebfa<br>B.cbdaef<br>C.bcaefd<br>D.afedcb<br><strong>正确答案：D</strong><br>解析：<br>选项A操作：a进，b进，c进，d进，d出，c出，e进，e出，b出，f进，f出，a出。<br>选项B操作：a进，b进，c进，c出，b出，d进，d出，a出，e进，e出，f进，f出。<br>选项C操作：a进，b进，b出，c进，c出，a出，d进，e进，e出，f进，f出，d出。<br>选项D操作：a进，a出，b进，c进，d进，e进，f进，f出，e出，d出，c出，b出。<br>从中看到，选项D中最后连续出栈5次，不符合要求。</p><h2 id="4、单选-2分-一个栈的进栈序列是a、b、c、d、e，则栈的不可能的输出序列是（-）。"><a href="#4、单选-2分-一个栈的进栈序列是a、b、c、d、e，则栈的不可能的输出序列是（-）。" class="headerlink" title="4、单选(2分)一个栈的进栈序列是a、b、c、d、e，则栈的不可能的输出序列是（ ）。"></a>4、单选(2分)一个栈的进栈序列是a、b、c、d、e，则栈的不可能的输出序列是（ ）。</h2><p>A.edcba<br>B.decba<br>C.dceab<br>D.abcde<br><strong>正确答案：C</strong><br>解析：<br>对于选项A，a、b、c、d、e进栈，e、d、c、b、a出栈；<br>对于选项B，a，b，c，d进栈，d出栈，e进栈，e出栈，c、b、a依次出栈；<br>对于选项C，a、b、c、d进栈，d出栈，c出栈，e进栈，e出栈，此时栈中从栈底到栈顶为a、b，不可能a先出栈，所以C是不可能的输出序列；<br>对于选项D，a进栈，a出栈，b进栈，b出栈，c进栈，c出栈，d进栈，d出栈，e进栈，e出栈。</p><h2 id="5、单选-2分-当用一个数组data-0…n-1-存放栈中元素时，栈底最好（-）。"><a href="#5、单选-2分-当用一个数组data-0…n-1-存放栈中元素时，栈底最好（-）。" class="headerlink" title="5、单选(2分)当用一个数组data[0…n-1]存放栈中元素时，栈底最好（ ）。"></a>5、单选(2分)当用一个数组data[0…n-1]存放栈中元素时，栈底最好（ ）。</h2><p>A.设置在data[0]处<br>B.设置在data[n-1]处<br>C.设置在data[0]或data[n-1]处<br>D.设置在data数组的任何位置<br><strong>正确答案：C</strong><br>解析： C、栈中元素的逻辑关系呈现线性关系，这样有两个端点，最好将栈底设置在某个端点data[0]或data[n-1]处，从而方便栈运算算法的设计。</p><p><strong>（因为栈是一种只能在一端进行插入或删除操作的线性表）</strong></p><h2 id="6、单选-2分-若一个栈用数组data-1…n-存储，初始栈顶指针top为n-1，则以下元素x进栈的正确操作是（-）。"><a href="#6、单选-2分-若一个栈用数组data-1…n-存储，初始栈顶指针top为n-1，则以下元素x进栈的正确操作是（-）。" class="headerlink" title="6、单选(2分)若一个栈用数组data[1…n]存储，初始栈顶指针top为n+1，则以下元素x进栈的正确操作是（ ）。"></a>6、单选(2分)若一个栈用数组data[1…n]存储，初始栈顶指针top为n+1，则以下元素x进栈的正确操作是（ ）。</h2><p>A.top++; data[top]&#x3D;x;<br>B.data[top]&#x3D;x; top++;<br>C.top–; data[top]&#x3D;x;<br>D.data[top]&#x3D;x; top–;<br><strong>正确答案：C</strong></p><p><strong>初始栈顶指针top为n+1，说明data[1]端作为栈顶，且元素x的进栈操作为先将栈顶指针top减1，然后将元素x放在栈顶指针处。</strong></p><h2 id="7、单选-2分-若一个栈用数组data-1…n-存储，初始栈顶指针top为0，则以下元素x进栈的正确操作是（-）。"><a href="#7、单选-2分-若一个栈用数组data-1…n-存储，初始栈顶指针top为0，则以下元素x进栈的正确操作是（-）。" class="headerlink" title="7、单选(2分)若一个栈用数组data[1…n]存储，初始栈顶指针top为0，则以下元素x进栈的正确操作是（ ）。"></a>7、单选(2分)若一个栈用数组data[1…n]存储，初始栈顶指针top为0，则以下元素x进栈的正确操作是（ ）。</h2><p>A.top++; data[top]&#x3D;x;<br>B.data[top]&#x3D;x; top++;<br>C.top–; data[top]&#x3D;x;<br>D.data[top]&#x3D;x; top–;<br><strong>正确答案：A</strong><br>解析： A、<strong>初始栈顶指针top为0，说明data[1]端作为栈底，在进栈时top应递增，由于不存在data[0]的元素，所以在进栈时应先将top递增，再将x放在top处</strong></p><h2 id="8、单选-2分-在设计链栈时，通常采用单链表作为链栈，而不采用双链表作为链栈，其准确的原因是（-）。"><a href="#8、单选-2分-在设计链栈时，通常采用单链表作为链栈，而不采用双链表作为链栈，其准确的原因是（-）。" class="headerlink" title="8、单选(2分)在设计链栈时，通常采用单链表作为链栈，而不采用双链表作为链栈，其准确的原因是（ ）。"></a>8、单选(2分)在设计链栈时，通常采用单链表作为链栈，而不采用双链表作为链栈，其准确的原因是（ ）。</h2><p>A.栈中元素是顺序存取的，用单链表就足够了<br>B.栈中元素是随机存取的，用单链表就足够了<br>C.双链表运算较单链表更复杂<br>D.双链表存储密度较单链表低<br><strong>正确答案：A</strong><br>解析： A、因为栈中元素是顺序存取的（指逐个存或取结构中的元素），而不是随机存取的，用单链表就足够了。</p><h2 id="9、单选-2分-栈和队列的不同点是（-）。"><a href="#9、单选-2分-栈和队列的不同点是（-）。" class="headerlink" title="9、单选(2分)栈和队列的不同点是（ ）。"></a>9、单选(2分)栈和队列的不同点是（ ）。</h2><p>A.都是线性表<br>B.都不是线性表<br>C.栈只能在同一端进行插入删除操作，而队列在不同端进行插入删除操作<br>D.没有不同点<br><strong>正确答案：C</strong><br>解析： C、栈和队列的不同点是，栈在同一端进行插入和删除操作，而队列在不同端进行插入和删除操作。</p><h2 id="10、单选-2分-设循环队列qu中数组data的下标是0～N-1，其队头、队尾指针分别为f和r（f指向队首元素的前一位置，r指向队尾元素），元素x进队的操作是（）-qu-data-qu-rear-x3D-x。"><a href="#10、单选-2分-设循环队列qu中数组data的下标是0～N-1，其队头、队尾指针分别为f和r（f指向队首元素的前一位置，r指向队尾元素），元素x进队的操作是（）-qu-data-qu-rear-x3D-x。" class="headerlink" title="10、单选(2分)设循环队列qu中数组data的下标是0～N-1，其队头、队尾指针分别为f和r（f指向队首元素的前一位置，r指向队尾元素），元素x进队的操作是（）;qu.data[qu.rear]&#x3D;x。"></a>10、单选(2分)设<a href="https://so.csdn.net/so/search?q=%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97&spm=1001.2101.3001.7020">循环队列</a>qu中数组data的下标是0～N-1，其队头、队尾指针分别为f和r（f指向队首元素的前一位置，r指向队尾元素），元素x进队的操作是（）;qu.data[qu.rear]&#x3D;x。</h2><p>A.qu.rear++<br>B.qu.rear&#x3D;(qu.rear+1)%N<br>C.qu.front++;<br>D.qu.front&#x3D;(qu.front+1)%N<br><strong>正确答案：B</strong><br>解析： B、对于循环队列，进队操作仅移动队尾指针，元素x进队的操作是<br>qu.rear&#x3D;(qu.rear+1)%N;<br>qu.data[qu.rear]&#x3D;x。</p><p><strong>课本考据：<br>在队列不满的条件下先将队尾指针rear循环增1，然后将元素插入到该位置。算法如下</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">bool</span> <span class="hljs-title function_">enQueue</span><span class="hljs-params">(SqQueue *&amp;q,ElemType e)</span><br>&#123;<br><span class="hljs-keyword">if</span> ((q-&gt;rear+<span class="hljs-number">1</span>)%Maxsize==q-&gt;front)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>q-&gt;rear=(q-&gt;rear+<span class="hljs-number">1</span>)%MaxSize;<br>q-&gt;data[q-&gt;rear]=e;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-number">12345678</span><br></code></pre></td></tr></table></figure><h2 id="11、单选-2分-设循环队列qu中数组data的下标是0～N-1，其队头、队尾指针分别为f和r（f指向队首元素的前一位置，r指向队尾元素），元素x出队的操作是（-）-x-x3D-qu-data-qu-front-。"><a href="#11、单选-2分-设循环队列qu中数组data的下标是0～N-1，其队头、队尾指针分别为f和r（f指向队首元素的前一位置，r指向队尾元素），元素x出队的操作是（-）-x-x3D-qu-data-qu-front-。" class="headerlink" title="11、单选(2分)设循环队列qu中数组data的下标是0～N-1，其队头、队尾指针分别为f和r（f指向队首元素的前一位置，r指向队尾元素），元素x出队的操作是（ ）;x&#x3D;qu.data[qu.front]。"></a>11、单选(2分)设循环队列qu中数组data的下标是0～N-1，其队头、队尾指针分别为f和r（f指向队首元素的前一位置，r指向队尾元素），元素x出队的操作是（ ）;x&#x3D;qu.data[qu.front]。</h2><p>A.qu.rear++<br>B.qu.rear&#x3D;(qu.rear+1)%N<br>C.qu.front++;<br>D.qu.front&#x3D;(qu.front+1)%N<br><strong>正确答案：D</strong><br>解析： D、对于循环队列，出队操作仅移动队头指针，元素x出队的操作是：qu.front&#x3D;(qu.front+1)%N;<br>x&#x3D;qu.data[qu.rear]。</p><p>课本考据：在队列q不空的条件下将队首指针front循环增1，取出该位置的元素并赋值给e。算法如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">bool</span> <span class="hljs-title function_">deQueue</span><span class="hljs-params">(SqQueue *&amp;q,ElemType e)</span><br>&#123;<br><span class="hljs-keyword">if</span> (q-&gt;front==q-&gt;rear)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>q-&gt;front=(q-&gt;front+<span class="hljs-number">1</span>)%MaxSize;<br>e=q-&gt;dara[q-&gt;front];<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-number">12345678</span><br></code></pre></td></tr></table></figure><h2 id="12、单选-2分-若某循环队列有队首指针front和队尾指针rear，在队不空时出队操作仅会改变（-）。"><a href="#12、单选-2分-若某循环队列有队首指针front和队尾指针rear，在队不空时出队操作仅会改变（-）。" class="headerlink" title="12、单选(2分)若某循环队列有队首指针front和队尾指针rear，在队不空时出队操作仅会改变（ ）。"></a>12、单选(2分)若某循环队列有队首指针front和队尾指针rear，在队不空时出队操作仅会改变（ ）。</h2><p>A.front<br>B.rear<br>C.front和rear<br>D.以上都不对<br><strong>正确答案：A</strong><br>解析： A、<strong>当循环队列不空时，出队操作只能改变队头指针front。</strong></p><h2 id="13、单选-2分-通常设置循环队列qu的队空条件（front队首指针指向队首元素的前一位置，rear队尾指针指向队尾元素）是（-）。"><a href="#13、单选-2分-通常设置循环队列qu的队空条件（front队首指针指向队首元素的前一位置，rear队尾指针指向队尾元素）是（-）。" class="headerlink" title="13、单选(2分)通常设置循环队列qu的队空条件（front队首指针指向队首元素的前一位置，rear队尾指针指向队尾元素）是（ ）。"></a>13、单选(2分)通常设置循环队列qu的队空条件（front队首指针指向队首元素的前一位置，rear队尾指针指向队尾元素）是（ ）。</h2><p>A.(qu.rear+1)%MaxSize &#x3D;&#x3D; (qu.front+1)%MaxSize<br>B.(qu.rear+1)%MaxSize &#x3D;&#x3D; qu.front+1<br>C.(qu.rear+1)%MaxSize &#x3D;&#x3D; qu.front<br>D.qu.rea r &#x3D;&#x3D; qu.front<br><strong>正确答案：D</strong><br>解析： D、在循环队列中，通常设置队头等于队尾时表示队空。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">bool</span> <span class="hljs-title function_">QueueEmpty</span><span class="hljs-params">(SqQueue * q)</span><br>&#123;<br><span class="hljs-keyword">return</span>(q-&gt;front==q-&gt;rear);<br>&#125;<br><span class="hljs-number">1234</span><br></code></pre></td></tr></table></figure><h2 id="14、单选-2分-设循环队列的存储空间为a-0…20-，且当前队头指针（f指向队首元素的前一位置）和队尾指针（r指向队尾元素）的值分别为8和3，则该队列中元素个数为（-）。"><a href="#14、单选-2分-设循环队列的存储空间为a-0…20-，且当前队头指针（f指向队首元素的前一位置）和队尾指针（r指向队尾元素）的值分别为8和3，则该队列中元素个数为（-）。" class="headerlink" title="14、单选(2分)设循环队列的存储空间为a[0…20]，且当前队头指针（f指向队首元素的前一位置）和队尾指针（r指向队尾元素）的值分别为8和3，则该队列中元素个数为（ ）。"></a>14、单选(2分)设循环队列的存储空间为a[0…20]，且当前队头指针（f指向队首元素的前一位置）和队尾指针（r指向队尾元素）的值分别为8和3，则该队列中元素个数为（ ）。</h2><p>A.5<br>B.6<br>C.16<br>D.17<br><strong>正确答案：C</strong><br>解析： C、<strong>这里MaxSize&#x3D;21，其中的元素个数&#x3D;<br>(r-f+MaxSize)%MaxSize&#x3D;16。</strong></p><h2 id="15、单选-2分-假设用一个不带头节点的单链表表示队列，队头在链表的（-）位置。"><a href="#15、单选-2分-假设用一个不带头节点的单链表表示队列，队头在链表的（-）位置。" class="headerlink" title="15、单选(2分)假设用一个不带头节点的单链表表示队列，队头在链表的（ ）位置。"></a>15、单选(2分)假设用一个不带头节点的单链表表示队列，队头在链表的（ ）位置。</h2><p>A.链头<br>B.链尾<br>C.链中<br>D.以上都可以<br><strong>正确答案：A</strong><br>解析： A、在用单链表表示的链队中，以单链表的链头作为队头，以单链表的链尾作为队尾。</p><h2 id="16、单选-2分-与顺序队相比，链队（-）。"><a href="#16、单选-2分-与顺序队相比，链队（-）。" class="headerlink" title="16、单选(2分)与顺序队相比，链队（ ）。"></a>16、单选(2分)与顺序队相比，链队（ ）。</h2><p>A.优点是可以实现无限长队列<br>B.优点是进队和出队时间性能更好<br>C.缺点是不能进行顺序访问<br>D.缺点是不能根据队首和队尾指针计算队的长度<br><strong>正确答案：D</strong><br>解析： D、尽管链队总是采用动态分配方式，其长度也受内存大小的限制，也不可能实现无限长队列。顺序队和链队的进队和出队操作时间均为O(1)。顺序队和链队都可以进行顺序访问。在顺序队中可以通过队头和队尾指针计算队中元素个数，而链队不能。</p><h2 id="17、单选-2分-若用一个大小为6的数组来实现循环队列，且当前rear和front的值分别为0和3，当从队列中删除一个元素，再加入两个元素后，rear和front的值分别为（-）。"><a href="#17、单选-2分-若用一个大小为6的数组来实现循环队列，且当前rear和front的值分别为0和3，当从队列中删除一个元素，再加入两个元素后，rear和front的值分别为（-）。" class="headerlink" title="17、单选(2分)若用一个大小为6的数组来实现循环队列，且当前rear和front的值分别为0和3，当从队列中删除一个元素，再加入两个元素后，rear和front的值分别为（ ）。"></a>17、单选(2分)若用一个大小为6的数组来实现循环队列，且当前rear和front的值分别为0和3，当从队列中删除一个元素，再加入两个元素后，rear和front的值分别为（ ）。</h2><p>A.1和5<br>B.2和4<br>C.4和2<br>D.5和1<br><strong>正确答案：B</strong><br>解析： B、rear&#x3D;0，进队2个元素后，rear循环递增2，rear&#x3D;2；front&#x3D;3，出队一个元素后，front循环递增1，front&#x3D;4。</p><h2 id="18、单选-2分-一个循环队列中用data-0…n-1-数组保存队中元素，另设置一个队尾指针rear和一个记录队中实际元素个数的变量count，则该队中最多可以存放的元素个数是（-）。"><a href="#18、单选-2分-一个循环队列中用data-0…n-1-数组保存队中元素，另设置一个队尾指针rear和一个记录队中实际元素个数的变量count，则该队中最多可以存放的元素个数是（-）。" class="headerlink" title="18、单选(2分)一个循环队列中用data[0…n-1]数组保存队中元素，另设置一个队尾指针rear和一个记录队中实际元素个数的变量count，则该队中最多可以存放的元素个数是（ ）。"></a>18、单选(2分)一个循环队列中用data[0…n-1]数组保存队中元素，另设置一个队尾指针rear和一个记录队中实际元素个数的变量count，则该队中最多可以存放的元素个数是（ ）。</h2><p>A.n-1<br>B.n<br>C.(rear+n) % n<br>D.(n-rear) % n<br><strong>正确答案：B</strong><br>解析： B、队满的条件为count&#x3D;&#x3D;n。</p><h2 id="19、单选-2分-已知循环队列存储在一维数组A-0…n-1-中，且队列非空时front和rear分别指向队头元素和队尾元素。若初始时队列空，且要求第一个进入队列的元素存储在A-0-处，则初始时front和rear的值分别是（-）。"><a href="#19、单选-2分-已知循环队列存储在一维数组A-0…n-1-中，且队列非空时front和rear分别指向队头元素和队尾元素。若初始时队列空，且要求第一个进入队列的元素存储在A-0-处，则初始时front和rear的值分别是（-）。" class="headerlink" title="19、单选(2分)已知循环队列存储在一维数组A[0…n-1]中，且队列非空时front和rear分别指向队头元素和队尾元素。若初始时队列空，且要求第一个进入队列的元素存储在A[0]处，则初始时front和rear的值分别是（ ）。"></a>19、单选(2分)已知循环队列存储在一维数组A[0…n-1]中，且队列非空时front和rear分别指向队头元素和队尾元素。若初始时队列空，且要求第一个进入队列的元素存储在A[0]处，则初始时front和rear的值分别是（ ）。</h2><p>A.0，0<br>B.0，n-1<br>C.n-1，0<br>D. n-1，n-1<br><strong>正确答案：B</strong><br>解析： B、在循环队列中，进队操作是队尾指针rear循环加1，再在该处放置进队的元素，本题要求第一个进入队列的元素存储在A[0]处，则rear应为n-1，因为这样(rear+1)%n&#x3D;0。而队头指向队头元素，此时队头位置为0，所以front的初值为0。</p><h2 id="20、单选-2分-在循环队列中，元素的排列顺序（-）。"><a href="#20、单选-2分-在循环队列中，元素的排列顺序（-）。" class="headerlink" title="20、单选(2分)在循环队列中，元素的排列顺序（ ）。"></a>20、单选(2分)在循环队列中，元素的排列顺序（ ）。</h2><p>A.由元素进队的先后顺序确定<br>B.与元素值的大小有关<br>C.与队头和队尾指针的取值有关<br>D.与队中数组大小有关<br><strong>正确答案：A</strong><br>解析： A、在循环队列中，元素的排列顺序仅与元素进队的先后顺序有关。</p><hr><h1 id="第五周测验"><a href="#第五周测验" class="headerlink" title="第五周测验"></a>第五周测验</h1><h2 id="1、单选-2分-下面关于串的叙述中，正确的是（-）。"><a href="#1、单选-2分-下面关于串的叙述中，正确的是（-）。" class="headerlink" title="1、单选(2分)下面关于串的叙述中，正确的是（ ）。"></a>1、单选(2分)下面关于串的叙述中，正确的是（ ）。</h2><p>A.串是一种特殊的<a href="https://so.csdn.net/so/search?q=%E7%BA%BF%E6%80%A7%E8%A1%A8&spm=1001.2101.3001.7020">线性表</a><br>B.串中元素只能是字母<br>C.空串就是空白串<br>D.串的长度必须大于零<br><strong>正确答案：A</strong><br>解析： A、串是一种特殊的线性表，其元素为单个字符，长度可以为0。</p><p><strong>课本考据：<br>1）字符串简称为串，串是由字符元素构成的，其中元素的逻辑关系也是一种线性关系。<br>2）在一般情况下，英文字母、数字（0，1，·····9）和常用的标点符号以及空格符等都是合法的字符。<br>3）含零个字符的串称为空串。</strong></p><h2 id="2、单选-2分-两个字符串相等的条件是（-）。"><a href="#2、单选-2分-两个字符串相等的条件是（-）。" class="headerlink" title="2、单选(2分)两个字符串相等的条件是（ ）。"></a>2、单选(2分)两个字符串相等的条件是（ ）。</h2><p>A.串的长度相等<br>B.含有相同的字符集<br>C.都是非空串<br>D.两个串的长度相等且对应位置的字符相同<br><strong>正确答案：D</strong></p><p><strong>课本考据：两个串相等当且仅当这两个串的长度相等并且个对应位置上的字符都相同。</strong></p><h2 id="3、单选-2分-若串str-x3D-“Software”，其子串的个数是（-）。"><a href="#3、单选-2分-若串str-x3D-“Software”，其子串的个数是（-）。" class="headerlink" title="3、单选(2分)若串str&#x3D;“Software”，其子串的个数是（ ）。"></a>3、单选(2分)若串str&#x3D;“Software”，其子串的个数是（ ）。</h2><p>A.8<br>B.9<br>C.36<br>D.37<br><strong>正确答案：D</strong><br>解析： D、该串中所有字符不相同，长度为0的子串1个，长度为1的子串8个，长度为2的子串7个，…，长度为7的子串2个，长度为8的子串1个，总计子串数&#x3D;1+8+7+…+2+1&#x3D;1+8×9&#x2F;2&#x3D;37。</p><h2 id="4、单选-2分-一个链串的节点类型定义为-define-NodeSize-6"><a href="#4、单选-2分-一个链串的节点类型定义为-define-NodeSize-6" class="headerlink" title="4、单选(2分)一个链串的节点类型定义为#define NodeSize 6"></a>4、单选(2分)一个链串的节点类型定义为#define NodeSize 6</h2><p>typedef struct node<br>{<br>char data[NodeSize];<br>struct node *next;<br>} LinkStrNode;<br>如果每个字符占1个字节，指针占2个字节，该链串的存储密度为（ ）。<br>A.1&#x2F;3<br>B.1&#x2F;2<br>C.2&#x2F;3<br>D.3&#x2F;4<br><strong>正确答案：D</strong><br>解析： D、链串节点大小指每个节点存放的字符个数，本题节点大小为6，存储密度&#x3D;(6 * 1)&#x2F;(6 * 1+2)&#x3D;3&#x2F;4。</p><h2 id="5、单选-2分-串采用节点大小为1的链表作为其存储结构，是指（-）。"><a href="#5、单选-2分-串采用节点大小为1的链表作为其存储结构，是指（-）。" class="headerlink" title="5、单选(2分)串采用节点大小为1的链表作为其存储结构，是指（ ）。"></a>5、单选(2分)串采用节点大小为1的链表作为其存储结构，是指（ ）。</h2><p>A.链表的长度为1<br>B.链表中只存放一个字符<br>C.链表中每个节点的数据域中只存放一个字符<br>D.以上都不对<br><strong>正确答案：C</strong><br>解析： C、链串节点大小指每个节点存放的字符个数。</p><h2 id="6、单选-2分-对于一个链串s，查找第一个字符值为x的算法的时间复杂度为（-）。"><a href="#6、单选-2分-对于一个链串s，查找第一个字符值为x的算法的时间复杂度为（-）。" class="headerlink" title="6、单选(2分)对于一个链串s，查找第一个字符值为x的算法的时间复杂度为（ ）。"></a>6、单选(2分)对于一个链串s，查找第一个字符值为x的算法的时间复杂度为（ ）。</h2><p>A.O(1)<br>B.O(n)<br>C.O(n2)<br>D.以上都不对<br><strong>正确答案：B</strong><br>解析： B、在链串查找第一个字符值为x的算法的时间复杂度为O(n)。</p><h2 id="7、单选-2分-设有两个串p和q，其中q是p的子串，则求q在p中首次出现位置的算法称为（-）。"><a href="#7、单选-2分-设有两个串p和q，其中q是p的子串，则求q在p中首次出现位置的算法称为（-）。" class="headerlink" title="7、单选(2分)设有两个串p和q，其中q是p的子串，则求q在p中首次出现位置的算法称为（ ）。"></a>7、单选(2分)设有两个串p和q，其中q是p的子串，则求q在p中首次出现位置的算法称为（ ）。</h2><p>A.求子串<br>B.串联接<br>C.模式匹配<br>D.求串长<br><strong>正确答案：C</strong><br>解析： C、模式匹配算法就是找子串在主串中的位置。</p><h2 id="8、单选-2分-在串的简单模式匹配中，当模式串位j与目标串位i比较时，两字符不相等，则i的位移方式是（-）。"><a href="#8、单选-2分-在串的简单模式匹配中，当模式串位j与目标串位i比较时，两字符不相等，则i的位移方式是（-）。" class="headerlink" title="8、单选(2分)在串的简单模式匹配中，当模式串位j与目标串位i比较时，两字符不相等，则i的位移方式是（ ）。"></a>8、单选(2分)在串的简单模式匹配中，当模式串位j与目标串位i比较时，两字符不相等，则i的位移方式是（ ）。</h2><p>A.i++<br>B.i&#x3D;j+1<br>C.i&#x3D;i-j+1<br>D.i&#x3D;j-i+1<br><strong>正确答案：C</strong><br>解析： C、在串的简单模式匹配(BF算法)中，当两字符比较不等时，目标串位i回溯到原来位置的下一个位置，即i&#x3D;i-j+1。</p><h2 id="9、单选-2分-在KMP模式匹配中，用next数组存放模式串的部分匹配信息。当模式串位j与目标串位i比较时，两字符不相等，则i的位移方式是（-）。"><a href="#9、单选-2分-在KMP模式匹配中，用next数组存放模式串的部分匹配信息。当模式串位j与目标串位i比较时，两字符不相等，则i的位移方式是（-）。" class="headerlink" title="9、单选(2分)在KMP模式匹配中，用next数组存放模式串的部分匹配信息。当模式串位j与目标串位i比较时，两字符不相等，则i的位移方式是（ ）。"></a>9、单选(2分)在KMP模式匹配中，用next数组存放模式串的部分匹配信息。当模式串位j与目标串位i比较时，两字符不相等，则i的位移方式是（ ）。</h2><p>A.i&#x3D;next[j]<br>B.i不变<br>C…j不变<br>D.j&#x3D;next[j]<br><strong>正确答案：B</strong><br>解析： B、在KMP模式匹配中，当两字符比较不等时，目标串位i不回溯，仍停留在原来的位置。</p><h2 id="10、单选-2分-在KMP模式匹配中，用next数组存放模式串的部分匹配信息。当模式串位j与目标串位i比较时，两字符不相等，则j的位移方式是（-）。"><a href="#10、单选-2分-在KMP模式匹配中，用next数组存放模式串的部分匹配信息。当模式串位j与目标串位i比较时，两字符不相等，则j的位移方式是（-）。" class="headerlink" title="10、单选(2分)在KMP模式匹配中，用next数组存放模式串的部分匹配信息。当模式串位j与目标串位i比较时，两字符不相等，则j的位移方式是（ ）。"></a>10、单选(2分)在KMP模式匹配中，用next数组存放模式串的部分匹配信息。当模式串位j与目标串位i比较时，两字符不相等，则j的位移方式是（ ）。</h2><p>A.i&#x3D;next[j]<br>B.i不变<br>C.j不变<br>D.j&#x3D;next[j]<br><strong>正确答案：D</strong><br>解析： D、在KMP模式匹配中，当两字符比较不等时，目标串位i不改变，将其位置字符与模式串中next[j]位置的字符比较，即j&#x3D;next[j]。</p><hr><h1 id="第六周测验"><a href="#第六周测验" class="headerlink" title="第六周测验"></a>第六周测验</h1><h2 id="1、单选-2分-一个正确的递归算法通常包含（-）。"><a href="#1、单选-2分-一个正确的递归算法通常包含（-）。" class="headerlink" title="1、单选(2分)一个正确的递归算法通常包含（ ）。"></a>1、单选(2分)一个正确的<a href="https://so.csdn.net/so/search?q=%E9%80%92%E5%BD%92%E7%AE%97%E6%B3%95&spm=1001.2101.3001.7020">递归算法</a>通常包含（ ）。</h2><p>A.递归出口<br>B.递归体<br>C.递归出口和递归体<br>D.以上都不包含<br><strong>正确答案：C</strong><br>解析： C、正确的递归算法应包含递归出口和递归体两部分，缺一不可。</p><p><strong>课本考据：递归算法设计的基本步骤是先确定求解问题的递归模型，在转换成对应的 C&#x2F;C++语言函数。而一个递归体模型由递归出口（确定结束条件）和递归体（确定递推关系）两部分组成。</strong></p><h2 id="2、单选-2分-递归函数f-x，y-定义如下："><a href="#2、单选-2分-递归函数f-x，y-定义如下：" class="headerlink" title="2、单选(2分)递归函数f(x，y)定义如下："></a>2、单选(2分)<a href="https://so.csdn.net/so/search?q=%E9%80%92%E5%BD%92%E5%87%BD%E6%95%B0&spm=1001.2101.3001.7020">递归函数</a>f(x，y)定义如下：</h2><p>f(x，y)&#x3D;f(x-1，y)+f(x，y-1) 当x&gt;0且y&gt;0<br>f(x，y)&#x3D;x+y 否则<br>则f(2，1)的值是（ ）。<br>A.1<br>B.2<br>C.3<br>D.4<br><strong>正确答案：D</strong><br>解析： D、f(2,1)&#x3D;f(1,1)+f(2,0)&#x3D;f(0,1)+f(1,0)+2&#x3D;1+1+2&#x3D;4。</p><h2 id="3、单选-2分-某递归算法的执行时间的递推关系如下："><a href="#3、单选-2分-某递归算法的执行时间的递推关系如下：" class="headerlink" title="3、单选(2分)某递归算法的执行时间的递推关系如下："></a>3、单选(2分)某递归算法的执行时间的递推关系如下：</h2><p>T(n)&#x3D;1 当n&#x3D;1时<br>T(n)&#x3D;T(n&#x2F;2)+1 当n&gt;1时<br>则该算法的时间复杂度为（ ）。<br>A.O(1)<br>B.O(log2n)<br>C.O(n)<br>D.O(nlog2n)<br><strong>正确答案：B</strong><br>解析： B、不妨设n&#x3D;2^k，k&#x3D;log2n。<br>T(n)&#x3D;T(n&#x2F;2)+1&#x3D; T(n&#x2F;22)+2&#x3D;…&#x3D; T(n&#x2F;2k)+k&#x3D;T(1)+log2n&#x3D;O(log2n)。</p><h2 id="4、单选-2分-某递归算法的执行时间的递推关系如下："><a href="#4、单选-2分-某递归算法的执行时间的递推关系如下：" class="headerlink" title="4、单选(2分)某递归算法的执行时间的递推关系如下："></a>4、单选(2分)某递归算法的执行时间的递推关系如下：</h2><p>T(n)&#x3D;1 当n&#x3D;1时<br>T(n)&#x3D;2T(n&#x2F;2)+1 当n&gt;1时<br>则该算法的时间复杂度为（ ）。<br>A.O(1)<br>B.O(log2n)<br>C.O(n)<br>D.O(log2n)<br><strong>正确答案：C</strong><br>解析： C、不妨设n&#x3D;2^k，k&#x3D;log2n。<br>T(n)&#x3D;21<em>T(n&#x2F;21)+1&#x3D;22</em>T(n&#x2F;22)+1+21&#x3D;…&#x3D;2kT(n&#x2F;2k)+1+21+…+2(k-1)&#x3D;2kT(1)+2k-1&#x3D;2n-1&#x3D;O(n)。</p><h2 id="5、单选-2分-将递归算法转换成非递归算法时，通常要借助的数据结构是（-）。"><a href="#5、单选-2分-将递归算法转换成非递归算法时，通常要借助的数据结构是（-）。" class="headerlink" title="5、单选(2分)将递归算法转换成非递归算法时，通常要借助的数据结构是（ ）。"></a>5、单选(2分)将递归算法转换成非递归算法时，通常要借助的数据结构是（ ）。</h2><p>A.线性表<br>B.栈<br>C.队列<br>D.树<br><strong>正确答案：B</strong><br>解析： B、递归算法转换成非递归算法时通常使用栈。</p><p><strong>课本考据：大多数CPU上的程序实现使用栈来支持函数调用操作。</strong></p><hr><h1 id="第七周测验"><a href="#第七周测验" class="headerlink" title="第七周测验"></a>第七周测验</h1><h2 id="1、单选-2分-有一个三维数组A-2…2-4…5-2…6-，其中元素个数是（-）。"><a href="#1、单选-2分-有一个三维数组A-2…2-4…5-2…6-，其中元素个数是（-）。" class="headerlink" title="1、单选(2分)有一个三维数组A[-2…2][-4…5][2…6]，其中元素个数是（ ）。"></a>1、单选(2分)有一个三维数组A[-2…2][-4…5][2…6]，其中元素个数是（ ）。</h2><p>A.144<br>B.60<br>C.396<br>D.250<br><strong>正确答案：D</strong><br>解析： D、A的第1维长度为5【2-（-2）+1：-2，-1，0，1，2】，第2维长度为10【5-（-4）+1：-4，-3，-2，-1，0，1，2，3，4，5】，第3维长度为5【6-2+1：2，3，4，5，6】，元素个数&#x3D;5×10×5&#x3D;250。</p><p><strong>课本考据：一个的二维数组可看作是每个数据元素都是相同类型的一维数组的一维数组。如下图所示：<br><img src="/images/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzAwNDU0MA==,size_16,color_FFFFFF,t_70#pic_center.png" alt="在这里插入图片描述"><br>故，任何多维数组都可看作一个线性表。</strong></p><h2 id="2、单选-2分-设C-x2F-C-二维数组a-m-n-，每个数组元素占用k个存储单元，第一个数组元素的存储地址是LOC-a-0-0-，求按行优先顺序存放的数组元素a-i-j-（0≤i≤m-1，0≤j≤n-1）的存储地址为（-）。"><a href="#2、单选-2分-设C-x2F-C-二维数组a-m-n-，每个数组元素占用k个存储单元，第一个数组元素的存储地址是LOC-a-0-0-，求按行优先顺序存放的数组元素a-i-j-（0≤i≤m-1，0≤j≤n-1）的存储地址为（-）。" class="headerlink" title="2、单选(2分)设C&#x2F;C++二维数组a[m][n]，每个数组元素占用k个存储单元，第一个数组元素的存储地址是LOC(a[0][0])，求按行优先顺序存放的数组元素a[i][j]（0≤i≤m-1，0≤j≤n-1）的存储地址为（ ）。"></a>2、单选(2分)设C&#x2F;C++<a href="https://so.csdn.net/so/search?q=%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84&spm=1001.2101.3001.7020">二维数组</a>a[m][n]，每个数组元素占用k个存储单元，第一个数组元素的存储地址是LOC(a[0][0])，求按行优先顺序存放的数组元素a[i][j]（0≤i≤m-1，0≤j≤n-1）的存储地址为（ ）。</h2><p>A.LOC(a[0][0])+[i×n+j]×k<br>B.LOC(a[0][0])+[j×m+i]×k<br>C.LOC(a[0][0])+[(j-1)×m+i-1]×k<br>D.LOC(a[0][0])+[(i-1)×n+j-1]×k<br><strong>正确答案：A</strong><br>解析： A、a[i][j]前面有0～i-1行，计i×n个元素，第i行前面有j个元素，则a[i][j]前面有i×m+ j个元素，所以a[i][j]的存储地址&#x3D;LOC(a[0][0])+[i×n+j]×k。</p><p><strong>课本考据：在内存中元素a[i][j]前面有i行，每行有n个元素，即已存放了i×n个元素，占用了i×n×k个内存单元；在第i行中元素a[i][j]前面有j个元素，即已存放了j个元素，占用了j-1乘k个内存单元；</strong></p><h2 id="3、单选-2分-设二维数组a-1…5-1…8-，若按行优先的顺序存放数组的元素，则a-4-6-元素的前面有（-）个元素。"><a href="#3、单选-2分-设二维数组a-1…5-1…8-，若按行优先的顺序存放数组的元素，则a-4-6-元素的前面有（-）个元素。" class="headerlink" title="3、单选(2分)设二维数组a[1…5][1…8]，若按行优先的顺序存放数组的元素，则a[4][6]元素的前面有（ ）个元素。"></a>3、单选(2分)设二维数组a[1…5][1…8]，若按行优先的顺序存放数组的元素，则a[4][6]元素的前面有（ ）个元素。</h2><p>A.6<br>B.28<br>C.29<br>D.40<br><strong>正确答案：C</strong><br>解析： C、m&#x3D;5，n&#x3D;8，a[4][6]元素的前面的元素个数&#x3D;(4-1) ×8+(6-1)&#x3D;29。</p><p><strong>课本考据：二维数组按行优先存放的示意图如<img src="/images/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA54yq6ISa546L,size_20,color_FFFFFF,t_70,g_se,x_16-168761569918718.png" alt="在这里插入图片描述"><br><img src="/images/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA54yq6ISa546L,size_20,color_FFFFFF,t_70,g_se,x_16-168761569778215.png" alt="在这里插入图片描述"><br>得该二维数组中任一元素a的存储地址，其中k为存储单元。</strong></p><h2 id="4、单选-2分-设C-x2F-C-二维数组a-6-10-，每个数组元素占用4个存储单元，若按行优先顺序存放所有数组元素，a-3-5-的存储地址为1000，则a-0-0-的存储地址是（-）。"><a href="#4、单选-2分-设C-x2F-C-二维数组a-6-10-，每个数组元素占用4个存储单元，若按行优先顺序存放所有数组元素，a-3-5-的存储地址为1000，则a-0-0-的存储地址是（-）。" class="headerlink" title="4、单选(2分)设C&#x2F;C++二维数组a[6][10]，每个数组元素占用4个存储单元，若按行优先顺序存放所有数组元素，a[3][5]的存储地址为1000，则a[0][0]的存储地址是（ ）。"></a>4、单选(2分)设C&#x2F;C++二维数组a[6][10]，每个<a href="https://so.csdn.net/so/search?q=%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0&spm=1001.2101.3001.7020">数组元素</a>占用4个存储单元，若按行优先顺序存放所有数组元素，a[3][5]的存储地址为1000，则a[0][0]的存储地址是（ ）。</h2><p>A.868<br>B.872<br>C.860<br>D.864<br><strong>正确答案：C</strong><br>解析： C、C&#x2F;C++二维数组下标从0开始。a[3][5]前面的元素个数&#x3D;(3-0)×10+(5-0)&#x3D;35。所以1000&#x3D;LOC(a[0][0])+35×4，LOC(a[0][0])&#x3D;860。</p><h2 id="5、单选-2分-一个n阶对称矩阵A采用压缩存储方式，将其下三角部分（含主对角线元素）按行优先存储到一维数组B中，则B中元素个数是（-）。"><a href="#5、单选-2分-一个n阶对称矩阵A采用压缩存储方式，将其下三角部分（含主对角线元素）按行优先存储到一维数组B中，则B中元素个数是（-）。" class="headerlink" title="5、单选(2分)一个n阶对称矩阵A采用压缩存储方式，将其下三角部分（含主对角线元素）按行优先存储到一维数组B中，则B中元素个数是（ ）。"></a>5、单选(2分)一个n阶对称矩阵A采用压缩存储方式，将其下三角部分（含主对角线元素）按行优先存储到一维数组B中，则B中元素个数是（ ）。</h2><p>A.n(n+1)&#x2F;2+1<br>B.n(n+1)&#x2F;2<br>C.n<br>D.n*n<br><strong>正确答案：B</strong></p><p><strong>课本考据：特殊矩阵是指非零元素或零元素得分布具有一定规律得矩阵，为了节省存储空间，特别是在高阶矩阵的情况下可以利用特殊矩阵的对它们进行压缩存储以提高存储空间效率。将特殊矩阵压缩规律如图表示<img src="/images/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA54yq6ISa546L,size_20,color_FFFFFF,t_70,g_se,x_16-168761569450612.png" alt="在这里插入图片描述"><br><img src="/images/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA54yq6ISa546L,size_20,color_FFFFFF,t_70,g_se,x_16-16876156923419.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/07eb1085969444b7a78935ee9a4abd29.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA54yq6ISa546L,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>显然，一维数组B中存放的元素个数为1+2+…+n&#x3D;n(n+1)&#x2F;2。</strong></p><h2 id="6、单选-2分-一个n阶对称矩阵A-1…n，1…n-采用压缩存储方式，将其下三角部分按行优先存储到一维数组B-1…m-中，则A-i-j-（i-lt-j）元素在B中的位置k是（-）。"><a href="#6、单选-2分-一个n阶对称矩阵A-1…n，1…n-采用压缩存储方式，将其下三角部分按行优先存储到一维数组B-1…m-中，则A-i-j-（i-lt-j）元素在B中的位置k是（-）。" class="headerlink" title="6、单选(2分)一个n阶对称矩阵A[1…n，1…n]采用压缩存储方式，将其下三角部分按行优先存储到一维数组B[1…m]中，则A[i][j]（i&lt;j）元素在B中的位置k是（ ）。"></a>6、单选(2分)一个n阶对称矩阵A[1…n，1…n]采用压缩存储方式，将其下三角部分按行优先存储到一维数组B[1…m]中，则A[i][j]（i&lt;j）元素在B中的位置k是（ ）。</h2><p>A.j(j-1)&#x2F;2+i<br>B.j(j-1)&#x2F;2+i-1<br>C.i(i-1)&#x2F;2+j-1<br>D. i(i-1)&#x2F;2+j<br><strong>正确答案：A</strong><br>解析： A、对于下三角部分或者主对角线元素a[i][j]，它存储在b[k]中，k&#x3D;i(i-1)&#x2F;2+j。对于上三角部分元素A[i][j]（i&lt;j），对应的k&#x3D;j(j-1)&#x2F;2+i。</p><h2 id="7、单选-2分-一个n阶上三角矩阵A按行优先顺序压缩存放在一维数组B，则B中元素个数是（-）。"><a href="#7、单选-2分-一个n阶上三角矩阵A按行优先顺序压缩存放在一维数组B，则B中元素个数是（-）。" class="headerlink" title="7、单选(2分)一个n阶上三角矩阵A按行优先顺序压缩存放在一维数组B，则B中元素个数是（ ）。"></a>7、单选(2分)一个n阶上三角矩阵A按行优先顺序压缩存放在一维数组B，则B中元素个数是（ ）。</h2><p>A.n*n<br>B.n(n+1)&#x2F;2+1<br>C.n<br>D.n(n+1)&#x2F;2<br><strong>正确答案：B</strong></p><p>**课本考据：对于上三角矩阵的压缩存储方法是采用 以行序为主序存储对其主对角线加上三角部分的元素，另外用一个元素存储常数c，并将压缩结果存放在一维数组B中，如图<img src="/images/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA54yq6ISa546L,size_20,color_FFFFFF,t_70,g_se,x_16-16876156836786.png" alt="在这里插入图片描述"><br><img src="/images/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA54yq6ISa546L,size_20,color_FFFFFF,t_70,g_se,x_16-16876156801933.png" alt="在这里插入图片描述"></p><p>显然，B中元素的个数为n(n+1)&#x2F;2+1，即用B[0…n(n+1)&#x2F;2]存放A 中的元素。**</p><h2 id="8、单选-2分-一个n-n-gt-3-阶三对角矩阵A按行优先顺序压缩存放在一维数组B，则B中元素个数是（-）。"><a href="#8、单选-2分-一个n-n-gt-3-阶三对角矩阵A按行优先顺序压缩存放在一维数组B，则B中元素个数是（-）。" class="headerlink" title="8、单选(2分)一个n(n&gt;3)阶三对角矩阵A按行优先顺序压缩存放在一维数组B，则B中元素个数是（ ）。"></a>8、单选(2分)一个n(n&gt;3)阶三对角矩阵A按行优先顺序压缩存放在一维数组B，则B中元素个数是（ ）。</h2><p>A.3n-2<br>B.2n<br>C.n*n<br>D.3n<br><strong>正确答案：A</strong></p><p><strong>课本考据：若 一个n阶方阵A 满足其所有非零元素都集中在对主对角线为中心的带状区域中。则称为n阶对角矩阵。<img src="/images/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA54yq6ISa546L,size_20,color_FFFFFF,t_70,g_se,x_16.png" alt="在这里插入图片描述"></strong></p><h2 id="9、单选-2分-稀疏矩阵常用的压缩存储方法有（-）。"><a href="#9、单选-2分-稀疏矩阵常用的压缩存储方法有（-）。" class="headerlink" title="9、单选(2分)稀疏矩阵常用的压缩存储方法有（ ）。"></a>9、单选(2分)稀疏矩阵常用的压缩存储方法有（ ）。</h2><p>A.二维数组<br>B.哈希表和十字链表<br>C.三元组和哈希表<br>D.三元组和十字链表<br><strong>正确答案：D</strong></p><p><strong>课本考据：把稀疏矩阵的三元组线性表按顺序存储结构存储，则称为稀疏矩阵的三元组顺序表（简称为三元组表）；十字链表是稀疏矩阵的 一种链式存储结构。</strong></p><h2 id="10、单选-2分-稀疏矩阵采用压缩存储后的缺点之一是（-）。"><a href="#10、单选-2分-稀疏矩阵采用压缩存储后的缺点之一是（-）。" class="headerlink" title="10、单选(2分)稀疏矩阵采用压缩存储后的缺点之一是（ ）。"></a>10、单选(2分)稀疏矩阵采用压缩存储后的缺点之一是（ ）。</h2><p>A.丧失随机存取特性<br>B.无法由行、列值查找某个矩阵元素<br>C.无法判断矩阵的行列数<br>D.使矩阵元素之间的逻辑关系更加复杂<br><strong>正确答案：A</strong></p>]]></content>
    
    
    <categories>
      
      <category>考试复习</category>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
      <tag>考试复习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>软件工程复习</title>
    <link href="/2023/06/23/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%A4%8D%E4%B9%A0/"/>
    <url>/2023/06/23/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%A4%8D%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="软件工程复习-考点"><a href="#软件工程复习-考点" class="headerlink" title="软件工程复习-考点"></a>软件工程复习-考点</h1><h2 id="题型"><a href="#题型" class="headerlink" title="题型"></a>题型</h2><table><thead><tr><th>题型</th><th>题量</th><th>分值</th></tr></thead><tbody><tr><td>选择题</td><td>10题*1</td><td>10</td></tr><tr><td>填空题</td><td>14空*1</td><td>14</td></tr><tr><td>名词解释🌟</td><td>5题*4</td><td>20</td></tr><tr><td>简答题🌟</td><td>7题*5</td><td>35</td></tr><tr><td>综合题🌟</td><td>3*7</td><td>21</td></tr></tbody></table><h2 id="一、简答题"><a href="#一、简答题" class="headerlink" title="一、简答题"></a>一、简答题</h2><h4 id="1、什么是软件过程模型？有哪些主要模型及各自特点？"><a href="#1、什么是软件过程模型？有哪些主要模型及各自特点？" class="headerlink" title="1、什么是软件过程模型？有哪些主要模型及各自特点？"></a>1、什么是软件过程模型？有哪些主要模型及各自特点？</h4><blockquote><p>软件过程是用于&#x3D;&#x3D;获得高质量软件的框架&#x3D;&#x3D;，它&#x3D;&#x3D;规定了开发过程每个任务的步骤&#x3D;&#x3D;</p><p>主要的模型有</p><ul><li>瀑布模型：开发过程规范，每个&#x3D;&#x3D;阶段之间靠文档驱动&#x3D;&#x3D;，阶段之间存在&#x3D;&#x3D;顺序和依赖性&#x3D;&#x3D;</li><li>快速原型：&#x3D;&#x3D;快速构建软件模型，支持用户参与&#x3D;&#x3D;</li><li>增量模型：将开发的系统模块化和组件化，通过一系列增量构建来实现产品</li><li>螺旋模型：每一个开发阶段都引入了风险分析的原型模型</li><li>喷泉模型：以用户需求为动力，以对象驱动，开发阶段无次序，可交互进行</li><li>敏捷开发：尽早地、持续地交付可评价的软件，以使客户满意</li></ul></blockquote><h3 id="2、简述增量式开发的优缺点"><a href="#2、简述增量式开发的优缺点" class="headerlink" title="2、简述增量式开发的优缺点?"></a>2、简述增量式开发的优缺点?</h3><blockquote><p>优点：</p><ul><li>根据增量&#x3D;&#x3D;不断发布软件新版本&#x3D;&#x3D;，可及时&#x3D;&#x3D;获得用户反馈&#x3D;&#x3D;用于&#x3D;&#x3D;调整软件后续开发策略&#x3D;&#x3D;&#x3D;&#x3D;</li><li>&#x3D;&#x3D;因软件需求确定&#x3D;&#x3D;，可先对软件体系结构进行设计，开发过程&#x3D;&#x3D;能保持良好的软件体系&#x3D;&#x3D;</li></ul><p>缺点：</p><ul><li>如果&#x3D;&#x3D;没有对用户变更要求规划&#x3D;&#x3D;，产生的&#x3D;&#x3D;初始增量会造成后面增量的不稳定&#x3D;&#x3D;</li><li>&#x3D;&#x3D;由于进度和配置的复杂性&#x3D;&#x3D;，可能会&#x3D;&#x3D;增大管理成本&#x3D;&#x3D;，&#x3D;&#x3D;超出组织能力&#x3D;&#x3D;</li></ul></blockquote><h3 id="3-简述软件工程的基本原理"><a href="#3-简述软件工程的基本原理" class="headerlink" title="3. 简述软件工程的基本原理"></a>3. 简述软件工程的基本原理</h3><blockquote><ul><li>&#x3D;&#x3D;阶段性&#x3D;&#x3D;的生命周期计划严格管理</li><li>&#x3D;&#x3D;坚持进&#x3D;&#x3D;行&#x3D;&#x3D;阶段审评&#x3D;&#x3D;</li><li>&#x3D;&#x3D;实行严格&#x3D;&#x3D;的产品控制</li><li>&#x3D;&#x3D;采用&#x3D;&#x3D;&#x3D;&#x3D;现代程序设计技术&#x3D;&#x3D;</li><li>&#x3D;&#x3D;&#x3D;&#x3D;结果应该能清楚的审查&#x3D;&#x3D;</li><li>&#x3D;&#x3D;开发人员&#x3D;&#x3D;应该&#x3D;&#x3D;少而精&#x3D;&#x3D;</li><li>承认&#x3D;&#x3D;不断改进软件工程实践的必要性&#x3D;&#x3D;</li></ul></blockquote><h3 id="4、软件需求分为哪几种类型？"><a href="#4、软件需求分为哪几种类型？" class="headerlink" title="4、软件需求分为哪几种类型？"></a>4、软件需求分为哪几种类型？</h3><blockquote><p>功能需求：&#x3D;&#x3D;客户要求目标软件应该具有的功能&#x3D;&#x3D;，包括软件相关功能在业务处理时应该遵循的约定或限制</p><p>质量需求：&#x3D;&#x3D;客户对目标软件提出的质量要求&#x3D;&#x3D;</p><p>约束性需求：利益相关方对目标软件在&#x3D;&#x3D;项目预算、完成时间、技术选型所遵循的标准与规范提出要求&#x3D;&#x3D;</p></blockquote><h3 id="5、列举敏捷开发的敏捷原则"><a href="#5、列举敏捷开发的敏捷原则" class="headerlink" title="5、列举敏捷开发的敏捷原则"></a>5、列举敏捷开发的敏捷原则</h3><blockquote><ul><li>尽早&#x3D;&#x3D;持续的开发&#x3D;&#x3D;有价值的软件，让客户满意</li><li>&#x3D;&#x3D;欣然面对&#x3D;&#x3D;客户需求变化</li><li>&#x3D;&#x3D;频繁交付&#x3D;&#x3D;可工作的软件</li><li>开发团队&#x3D;&#x3D;面对面交谈&#x3D;&#x3D;</li><li>整个项目过程中业务人员和开发人员&#x3D;&#x3D;每天一起工作&#x3D;&#x3D;</li><li>以&#x3D;&#x3D;激励个体&#x3D;&#x3D;为核心构建项目，为他们提供软件和支持，信任他们</li><li>&#x3D;&#x3D;可工作的软件&#x3D;&#x3D;是衡量进度的首要标准</li><li>倡导&#x3D;&#x3D;可持续开发&#x3D;&#x3D;</li><li>坚持不懈&#x3D;&#x3D;追求技术卓越&#x3D;&#x3D;和设计优越</li><li>开发&#x3D;&#x3D;以简单为基准&#x3D;&#x3D;</li><li>&#x3D;&#x3D;自组织的团队&#x3D;&#x3D;</li><li>开发团队&#x3D;&#x3D;定期反思&#x3D;&#x3D;如何提示开发效率</li></ul></blockquote><h3 id="6、什么是模块内聚度？表现形式有哪些，请逐一说明"><a href="#6、什么是模块内聚度？表现形式有哪些，请逐一说明" class="headerlink" title="6、什么是模块内聚度？表现形式有哪些，请逐一说明"></a>6、什么是模块内聚度？表现形式有哪些，请逐一说明</h3><blockquote><p>模块内聚度：表示一个模块内部各成分彼此关联的紧密程度</p><p>表现形式：</p><ul><li>偶然性内聚：模块内部各成分完成一组功能，之间具有关系也很松散</li><li>逻辑性内聚：模块完成多项功能，功能之间具有相关性</li><li>时间性内聚：模块完成的诸多功能并发执行</li><li>过程性内聚：在逻辑内聚的基础上，要求模块各功能必须按照一定次序执行</li><li>通信性内聚：模块各成分操作数据结构的同一片区域，达到通信</li><li>顺序性内聚：模块内各成分均与同一功能相关，这些处理必须依次执行</li><li>功能性内聚：模块内各成分协同完成单一功能</li></ul></blockquote><h3 id=""><a href="#" class="headerlink" title=""></a></h3>]]></content>
    
    
    <categories>
      
      <category>考试复习</category>
      
      <category>软件工程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>软件工程复习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>总复习2</title>
    <link href="/2023/06/14/%E5%A4%8D%E4%B9%A0%E6%80%BB/"/>
    <url>/2023/06/14/%E5%A4%8D%E4%B9%A0%E6%80%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="软件工程复习-考点"><a href="#软件工程复习-考点" class="headerlink" title="软件工程复习-考点"></a>软件工程复习-考点</h1><h2 id="题型"><a href="#题型" class="headerlink" title="题型"></a>题型</h2><table><thead><tr><th>题型</th><th>题量</th><th>分值</th></tr></thead><tbody><tr><td>选择题</td><td>10题*1</td><td>10</td></tr><tr><td>填空题</td><td>14空*1</td><td>14</td></tr><tr><td>名词解释🌟</td><td>5题*4</td><td>20</td></tr><tr><td>简答题🌟</td><td>7题*5</td><td>35</td></tr><tr><td>综合题🌟</td><td>3题*7</td><td>21</td></tr></tbody></table><h2 id="一、简答题-35分"><a href="#一、简答题-35分" class="headerlink" title="一、简答题(35分)"></a>一、简答题(35分)</h2><h3 id="1、什么是软件过程模型？有哪些主要模型及各自特点？"><a href="#1、什么是软件过程模型？有哪些主要模型及各自特点？" class="headerlink" title="1、什么是软件过程模型？有哪些主要模型及各自特点？"></a>1、什么是软件过程模型？有哪些主要模型及各自特点？</h3><blockquote><p>软件过程是用于获得高质量软件的框架，它规定了开发过程每个任务的步骤</p><p>主要的模型有</p><ul><li>瀑布模型：开发过程规范，每个阶段之间靠文档驱动，阶段之间存在顺序和依赖性</li><li>快速原型：快速构建软件模型，支持用户参与</li><li>增量模型：将开发的系统模块化和组件化，通过一系列增量构件来实现产品</li><li>螺旋模型：每一个开发阶段都引入了风险分析的原型模型</li><li>喷泉模型：以用户需求为动力，以对象驱动，开发阶段无次序，可交互进行</li><li>敏捷开发：尽早地、持续地交付可评价的软件，以使客户满意</li></ul></blockquote><h3 id="2、简述增量式开发的优缺点"><a href="#2、简述增量式开发的优缺点" class="headerlink" title="2、简述增量式开发的优缺点?"></a>2、简述增量式开发的优缺点?</h3><blockquote><p>优点：</p><ul><li>根据增量<font color='red'>不断发布软件新版本</font>，可及时获得用户反馈用于&#x3D;&#x3D;调整软件后续开发策略&#x3D;&#x3D;&#x3D;&#x3D;</li><li>&#x3D;&#x3D;因软件需求确定&#x3D;&#x3D;，可先对软件体系结构进行设计，开发过程&#x3D;&#x3D;能保持良好的软件体系结构&#x3D;&#x3D;</li></ul><p>缺点：</p><ul><li>如果&#x3D;&#x3D;没有对用户变更要求规划&#x3D;&#x3D;，产生的&#x3D;&#x3D;初始增量会造成后面增量的不稳定&#x3D;&#x3D;</li><li>&#x3D;&#x3D;由于进度和配置的复杂性&#x3D;&#x3D;，可能会&#x3D;&#x3D;增大管理成本&#x3D;&#x3D;，&#x3D;&#x3D;超出组织能力&#x3D;&#x3D;</li></ul></blockquote><h3 id="3-简述软件工程的基本原理"><a href="#3-简述软件工程的基本原理" class="headerlink" title="3. 简述软件工程的基本原理"></a>3. 简述软件工程的基本原理</h3><blockquote><ul><li><font color='red'><strong>阶段性的生命周期计划</strong></font>严格管理</li><li>坚持进行<font color='red'><strong>阶段审评</strong></font></li><li>实行严格的<font color='red'><strong>产品控制</strong></font></li><li>采用<font color='red'><strong>现代程序设计技术</strong></font></li><li><font color='red'><strong>结果</strong></font>应该能清楚的<font color='red'><strong>审查</strong></font></li><li><font color='red'><strong>开发人员</strong></font>应该<font color='red'><strong>少</strong></font>而<font color='red'><strong>精</strong></font></li><li>承认不<font color='red'><strong>断改进软件工程实践</strong></font>的必要性</li></ul></blockquote><h3 id="4、软件需求分为哪几种类型？"><a href="#4、软件需求分为哪几种类型？" class="headerlink" title="4、软件需求分为哪几种类型？"></a>4、软件需求分为哪几种类型？</h3><blockquote><p>功能需求：&#x3D;&#x3D;客户要求目标软件应该具有的功能&#x3D;&#x3D;，包括软件相关功能在业务处理时应该遵循的约定或限制</p><p>质量需求：&#x3D;&#x3D;客户对目标软件提出的质量要求&#x3D;&#x3D;</p><p>约束性需求：利益相关方对目标软件在&#x3D;&#x3D;项目预算、完成时间、技术选型所遵循的标准与规范提出要求&#x3D;&#x3D;</p></blockquote><h3 id="5、列举敏捷开发的敏捷原则"><a href="#5、列举敏捷开发的敏捷原则" class="headerlink" title="5、列举敏捷开发的敏捷原则"></a>5、列举敏捷开发的敏捷原则</h3><blockquote><ul><li>尽早&#x3D;&#x3D;持续的开发&#x3D;&#x3D;有价值的软件，让客户满意</li><li>&#x3D;&#x3D;欣然面对&#x3D;&#x3D;客户需求变化</li><li>&#x3D;&#x3D;频繁交付&#x3D;&#x3D;可工作的软件</li><li>开发团队&#x3D;&#x3D;面对面交谈&#x3D;&#x3D;</li><li>整个项目过程中业务人员和开发人员&#x3D;&#x3D;每天一起工作&#x3D;&#x3D;</li><li>以&#x3D;&#x3D;激励个体&#x3D;&#x3D;为核心构建项目，为他们提供软件和支持，信任他们</li><li>&#x3D;&#x3D;可工作的软件&#x3D;&#x3D;是衡量进度的首要标准</li><li>倡导&#x3D;&#x3D;可持续开发&#x3D;&#x3D;</li><li>坚持不懈&#x3D;&#x3D;追求技术卓越&#x3D;&#x3D;和设计优越</li><li>开发&#x3D;&#x3D;以简单为基准&#x3D;&#x3D;</li><li>&#x3D;&#x3D;自组织的团队&#x3D;&#x3D;</li><li>开发团队&#x3D;&#x3D;定期反思&#x3D;&#x3D;如何提示开发效率</li></ul></blockquote><h3 id="6、什么是模块内聚度？表现形式有哪些，请逐一说明"><a href="#6、什么是模块内聚度？表现形式有哪些，请逐一说明" class="headerlink" title="6、什么是模块内聚度？表现形式有哪些，请逐一说明"></a>6、什么是模块内聚度？表现形式有哪些，请逐一说明</h3><blockquote><p>模块内聚度：表示一个模块内部各成分彼此关联的紧密程度</p><p>表现形式：</p><ul><li>偶然性内聚：模块内部各成分&#x3D;&#x3D;完成一组功能&#x3D;&#x3D;，之间&#x3D;&#x3D;具有关系也很松散&#x3D;&#x3D;</li><li>逻辑性内聚：模块&#x3D;&#x3D;完成多项功能&#x3D;&#x3D;，&#x3D;&#x3D;功能之间具有相关性&#x3D;&#x3D;</li><li>时间性内聚：&#x3D;&#x3D;模块完成的诸多功能并发执行&#x3D;&#x3D;</li><li>过程性内聚：&#x3D;&#x3D;在逻辑内聚的基础上&#x3D;&#x3D;，要求模块&#x3D;&#x3D;各功能必须按照一定次序执行&#x3D;&#x3D;</li><li>通信性内聚：模块&#x3D;&#x3D;各成分&#x3D;&#x3D;&#x3D;&#x3D;操作数据结构的同一片区域&#x3D;&#x3D;，达到通信</li><li>顺序性内聚：模块内&#x3D;&#x3D;各成分均与同一功能相关&#x3D;&#x3D;，这些处理必须依次执行</li><li>功能性内聚：模块内&#x3D;&#x3D;各成分&#x3D;&#x3D;&#x3D;&#x3D;协同完成单一功能&#x3D;&#x3D;</li></ul></blockquote><h3 id="7、常用的调试策略有哪几类？请逐一说明"><a href="#7、常用的调试策略有哪几类？请逐一说明" class="headerlink" title="7、常用的调试策略有哪几类？请逐一说明"></a>7、常用的调试策略有哪几类？请逐一说明</h3><blockquote><p>原始类：在程序中&#x3D;&#x3D;安排若干输出语句&#x3D;&#x3D;，&#x3D;&#x3D;通过大量输出信息定位缺陷&#x3D;&#x3D;</p><p>回溯类：&#x3D;&#x3D;从缺陷征兆处开始&#x3D;&#x3D;，&#x3D;&#x3D;人工的按照控制流程往回追踪找到缺陷根源&#x3D;&#x3D;</p><p>排除类：&#x3D;&#x3D;收集出现缺陷的所有原因，通过测试一一排除&#x3D;&#x3D;</p></blockquote><h3 id="8、在用例模型已成的情形下为何还要构建分析模型？"><a href="#8、在用例模型已成的情形下为何还要构建分析模型？" class="headerlink" title="8、在用例模型已成的情形下为何还要构建分析模型？"></a>8、在用例模型已成的情形下为何还要构建分析模型？</h3><blockquote><ul><li>分析模型实际上也是不断深入理解用例模型的过程，对比用例模型&#x3D;&#x3D;更加结构化、更加清晰直观&#x3D;&#x3D;</li><li>分析模型&#x3D;&#x3D;是用例模型和软件设计模型之间的桥梁&#x3D;&#x3D;，比用例模型&#x3D;&#x3D;更接近设计模型&#x3D;&#x3D;，&#x3D;&#x3D;更适合软件设计师设计软件结构&#x3D;&#x3D;</li></ul></blockquote><h3 id="9、软件质量保证应做好哪几方面的工作？"><a href="#9、软件质量保证应做好哪几方面的工作？" class="headerlink" title="9、软件质量保证应做好哪几方面的工作？"></a>9、软件质量保证应做好哪几方面的工作？</h3><blockquote><p>软件质量是软件工程的重要内容</p><ul><li>开发过程始终&#x3D;&#x3D;采用技术手段和工具&#x3D;&#x3D;</li><li>每阶段开发结束&#x3D;&#x3D;组织正式技术评审&#x3D;&#x3D;</li><li>加强&#x3D;&#x3D;软件测试&#x3D;&#x3D;</li><li>推行&#x3D;&#x3D;软件工程规范&#x3D;&#x3D;</li><li>严格&#x3D;&#x3D;控制软件的变更与修改&#x3D;&#x3D;</li><li>&#x3D;&#x3D;对软件质量进行度量&#x3D;&#x3D;</li></ul></blockquote><h3 id="10-简述RUP统一过程的四个阶段及工作流"><a href="#10-简述RUP统一过程的四个阶段及工作流" class="headerlink" title="10.简述RUP统一过程的四个阶段及工作流"></a>10.简述RUP统一过程的四个阶段及工作流</h3><blockquote><p>四个阶段</p><ul><li>初始</li><li>细化</li><li>构造</li><li>交付</li></ul><p>工作流</p><ul><li>业务建模</li><li>需求</li><li>设计</li><li>实现</li><li>验证和确认</li><li>部署</li><li>配置和变更管理</li><li>项目管理</li><li>环境工作流</li></ul></blockquote><h3 id="11、对详细设计模型的质量要求包括哪些方面？请逐一说明"><a href="#11、对详细设计模型的质量要求包括哪些方面？请逐一说明" class="headerlink" title="11、对详细设计模型的质量要求包括哪些方面？请逐一说明"></a>11、对详细设计模型的质量要求包括哪些方面？请逐一说明</h3><blockquote><p>正确性：模型中的元素通过指定的协作方式能够实现所有软件的需求</p><p>优化性：模型以充分优化的方式实现软件的需求</p><p>设计充分性：模型的细化和精确程度足以作为软件编程人员的全部基础</p></blockquote><h3 id="12、请说明软件文档的作用？软件开发项目生存期各阶段都包含哪些文档？"><a href="#12、请说明软件文档的作用？软件开发项目生存期各阶段都包含哪些文档？" class="headerlink" title="12、请说明软件文档的作用？软件开发项目生存期各阶段都包含哪些文档？"></a>12、请说明软件文档的作用？软件开发项目生存期各阶段都包含哪些文档？</h3><blockquote><p>软件文档作用：</p><ul><li>提高软件开发过程可见度</li><li>提高开发效率</li><li>作为开发人员工作成果和结束标志</li><li>&#x3D;&#x3D;记录开发过程&#x3D;&#x3D;便于使用和维护</li><li>&#x3D;&#x3D;提供软件&#x3D;&#x3D;运行维护有关资料</li><li>&#x3D;&#x3D;便于用户了解软件功能&#x3D;&#x3D;</li></ul><p>包含哪些文档：</p><ul><li>可行性研究报告</li><li>项目开发计划</li><li>软件需求说明书</li><li>数据要求说明书</li><li>测试计划</li><li>概要设计说明书</li><li>详细设计说明书</li><li>用户手册</li><li>操作手册</li><li>测试分析报告</li><li>开发进度月报</li><li>项目开发总结</li><li>程序维护手册</li></ul></blockquote><h2 id="二、选择填空"><a href="#二、选择填空" class="headerlink" title="二、选择填空"></a>二、选择填空</h2><blockquote><p>1、软件生存周期一般可分为<strong>问题定义</strong>、<strong>可行性研究</strong>、需求分析、<strong>设计</strong>、<strong>编码</strong>、测试、<strong>运行</strong>与维护阶段。<br>2、按软件的功能进行划分，软件可以划分为<strong>系统软件</strong>、<strong>支撑软件</strong>和应用软件。<br>3、可行性研究主要集中在以下四个方面<strong>经济可行性</strong>、技术可行性、<strong>法律可行性</strong>和社会可行性。<br>4、用户界面的<strong>可使用性</strong>是用户界面设计最重要的也是最基本的目标。<br>5、常见的软件概要设计方法有3大类：以数据流图为基础构造模块结构的结构化设计方法（<strong>SD</strong>），以数据结构为基础构造模块的<strong>Jackson</strong>方法，以对象、类、继承和通信为基础的面向对象设计方法（<strong>OOD</strong>）。<br>6、<strong>数据流图</strong>和<strong>数据字典</strong>共同构成系统的逻辑模型。<br>7、软件测试的方法有<strong>分析方法</strong>和<strong>非分析方法</strong>（即黑盒法）。<br>8、单元测试一般以<strong>白盒测试</strong>为主，<strong>黑盒测试</strong>为辅。<br>9、成本估计方法主要有<strong>自底向上估计</strong>、<strong>自顶向下估计</strong>和<strong>算法模型估计</strong>三种类型。</p><p>10、<strong>文档</strong>（document）—一种数据媒体和其上所记录的数据。</p></blockquote><blockquote><p>11、 一般而言，需求优先级取决于三个因素的综合作用：需求项为利益相关方提供的价值、需求项的实现成本、实现过程中的风险。</p><ol start="12"><li>软件有效性（efficiency），指软件系统的时间和空间效率。</li><li>软件定义过程可通过软件系统的可行性研究和需求分析两个阶段来完成。</li><li>软件定义的基本任务是确定软件系统的工程需求，也就是要搞清“做什么”。</li><li>为了使用户需求逐步精细化、完全化、一致化，通常采用需求建模技术。</li><li>一个软件的深度是指其控制的层数。</li><li>以详细设计说明书为输入，将该输入用某种程序设计语言翻译成计算机可以理解并最终可运行的代码的过程叫编码过程。</li><li>软件维护是软件生命周期的最后一个阶段</li><li>软件工程的项目、人、过程、方法和工具、软件制品构成了软件工程五要素。</li><li>用例之间的关系主要有三种：包含（include）、扩展（extend）和继承。</li></ol></blockquote><blockquote><ol start="21"><li>数据流图就是用来刻画数据流和转换的信息系统建模技术。它用简单的图形记号分别表示数据流、转换、数据源以及外部实体。</li><li>被继承的类我们称之为基类父类，在基类的基础上新建立的类我们称之为派生类子类。</li><li>流程图也称为程序框图是最常用的一种表示法，它有顺序、分支和循环三个基本控制构件。</li><li>通用体系结构模式有：分层模式、管道与过滤器模式和黑板模式。</li><li>软件测试是执行程序发现并排除程序中潜伏的错误的过程。</li><li>软件可维护性，是指软件产品交付使用后，在实现改正潜伏的错误、改进性能等属性、适应环境变化等方面工作的难易程度。</li><li>软件可理解性，指系统具有清晰的结构，能直接反映问题的需求。<br>28 在实体-关系图简称E-R图中，数据对象实体用长方形、关系用菱形、属性用椭圆表示。</li><li>建立数据流模型要遵循的原则包括：每个加工至少应有一个输入数据流以反映被处理数据的来源和一个输出数据流来反映加工的结果</li><li>从工程管理的角度软件设计可分为概要设计和（详细）设计两大步骤。</li></ol></blockquote><blockquote><ol start="31"><li>通过向用户提供视觉和听觉上的反馈，保持用户与界面间的双向通信，是提高界面可（交互）性的措施之一。</li><li>程序设计语言的可靠性是指程序设计语言本身不出错或对错误的（纠正）能力。</li><li>对发现错误较多的程序模块，应进行（重点）测试。</li><li>测试用例中，不仅要选择合理的输入数据，还要选择（不合理）的输入数据。</li><li>用户关注软件质量的外部属性，如软件的正确性、可靠性、有效性、完整性、可用性、可维护性、可移植性、可复用性等。</li><li>软件设计基本原则包括抽象与逐步求精、强内聚及松耦合、信息隐藏及关注点分离。(顺序可互换)</li><li>需求建模的基本方法包括抽象、分解与多视点分析3种。</li><li>用于表示分析模型的UML图形机制主要是类图、活动图、交互图与状态图。</li><li>设计元素主要指出现在设计模型中的模块，这些模块的表现形式包括子系统、构件和类。</li></ol></blockquote>]]></content>
    
    
    <categories>
      
      <category>考试复习</category>
      
      <category>软件工程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>软件工程复习</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>

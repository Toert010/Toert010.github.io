<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>数据结构-考点范围</title>
    <link href="/2023/06/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E8%80%83%E7%82%B9%E8%8C%83%E5%9B%B4/"/>
    <url>/2023/06/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E8%80%83%E7%82%B9%E8%8C%83%E5%9B%B4/</url>
    
    <content type="html"><![CDATA[<h1 id="一、哈夫曼树🌟-第5章-二叉树"><a href="#一、哈夫曼树🌟-第5章-二叉树" class="headerlink" title="一、哈夫曼树🌟(第5章-二叉树)"></a>一、哈夫曼树🌟(第5章-二叉树)</h1><blockquote><p>叶子节点带有权重的最优二叉树</p><p><strong>路径</strong>：节点到节点的通路</p><p>路径长度：从根节点开始0，往后每一层+1</p><p>节点的权：赋予节点新的值</p><p>节点带权路径长度：该节点的权×该层路径长度</p><p>树的带权路径长度：书中所有叶子节点的带权路径长度之和，WPL</p><p>特征：权值越大离根节点越近</p></blockquote><h2 id="1-构造哈夫曼树"><a href="#1-构造哈夫曼树" class="headerlink" title="1.构造哈夫曼树"></a>1.构造哈夫曼树</h2><blockquote><p>1）从小到大进行排序, 将每一个数据，每个数据都是一个节点 ， 每个节点可以看成是一颗最简单的二叉树；</p><p>2）取出根节点权值最小的两颗二叉树，组成一颗新的二叉树, 该新的二叉树的根节点的权值是前面两颗二叉树根节点权值的和；</p><p>3）再将这颗新的二叉树，以根节点的权值大小再次排序， 不断重复 1-2-3 的步骤，直到数列中，所有的数据都被处理，就得到一颗赫夫曼树。</p></blockquote><h3 id="1-1-算WPL"><a href="#1-1-算WPL" class="headerlink" title="1.1 算WPL"></a>1.1 算WPL</h3><blockquote><p>构造玩哈夫曼树后计算每个叶子节点的带权路径相加</p></blockquote><h3 id="1-2-构造哈夫曼编码"><a href="#1-2-构造哈夫曼编码" class="headerlink" title="1.2 构造哈夫曼编码"></a>1.2 构造哈夫曼编码</h3><blockquote><p>根据构造好的哈夫曼树，左路径为0，右路径为1，根节点到某节点路径走向转换为对应的0和1即哈夫曼编码</p></blockquote><h1 id="二、如何构造二叉树并画出来（第5章-二叉树）"><a href="#二、如何构造二叉树并画出来（第5章-二叉树）" class="headerlink" title="二、如何构造二叉树并画出来（第5章-二叉树）"></a>二、如何构造二叉树并画出来（第5章-二叉树）</h1><h2 id="1-根据遍历画二叉树"><a href="#1-根据遍历画二叉树" class="headerlink" title="1.根据遍历画二叉树"></a>1.根据遍历画二叉树</h2><h3 id="给先序、中序"><a href="#给先序、中序" class="headerlink" title="给先序、中序"></a>给先序、中序</h3><blockquote><ul><li>看先序确定根</li><li>看中序确定左右子树</li><li>重复操作</li></ul></blockquote><h3 id="给后序、中序"><a href="#给后序、中序" class="headerlink" title="给后序、中序"></a>给后序、中序</h3><blockquote><ul><li>看后续确定根</li><li>看中序确定左右子树</li><li>重复操作</li></ul></blockquote><h2 id="2-根据遍历画线索树"><a href="#2-根据遍历画线索树" class="headerlink" title="2.根据遍历画线索树"></a>2.根据遍历画线索树</h2><blockquote><p>根据遍历补全节点中的左右子树，用虚箭头标注</p></blockquote><h2 id="3-树、森林、二叉树互转"><a href="#3-树、森林、二叉树互转" class="headerlink" title="3.树、森林、二叉树互转"></a>3.树、森林、二叉树互转</h2><h3 id="3-1-树转二叉树"><a href="#3-1-树转二叉树" class="headerlink" title="3.1 树转二叉树"></a>3.1 树转二叉树</h3><p><img src="/../imgs/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E8%80%83%E7%82%B9%E8%8C%83%E5%9B%B4/image-20230627122140935.png" alt="image-20230627122140935"></p><blockquote><ul><li>将树中所有兄弟节点连成一条虚线</li><li>删除树中所有右节点连线，只保留长子节点的连线即左节点</li><li>以根节点为中序顺时针旋转45°</li></ul><p><img src="/../imgs/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E8%80%83%E7%82%B9%E8%8C%83%E5%9B%B4/image-20230627122155969.png" alt="image-20230627122155969"></p><p><img src="/../imgs/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E8%80%83%E7%82%B9%E8%8C%83%E5%9B%B4/image-20230627122203113.png" alt="image-20230627122203113"></p><p><img src="/../imgs/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E8%80%83%E7%82%B9%E8%8C%83%E5%9B%B4/image-20230627122212043.png" alt="image-20230627122212043"></p></blockquote><h3 id="3-2-森转二叉树"><a href="#3-2-森转二叉树" class="headerlink" title="3.2 森转二叉树"></a>3.2 森转二叉树</h3><blockquote><p>将所有树转换为二叉树</p><p>第一棵树为中心，从第二棵树开始，依次将后一棵树的根节点作为前一棵树根节点的右节点</p></blockquote><h3 id="3-3-二叉树转树🌟"><a href="#3-3-二叉树转树🌟" class="headerlink" title="3.3 二叉树转树🌟"></a>3.3 二叉树转树🌟</h3><blockquote><p>若某节点是其双亲的左孩子，则把该节点的右孩子、右孩子的右孩子等都与该节点的双亲结点用连线连起来</p><p>删除右孩子节点连线</p></blockquote><h3 id="3-4-二叉树转森🌟"><a href="#3-4-二叉树转森🌟" class="headerlink" title="3.4 二叉树转森🌟"></a>3.4 二叉树转森🌟</h3><h1 id="三、深度优先和广度优先（第6章-图-图的遍历）"><a href="#三、深度优先和广度优先（第6章-图-图的遍历）" class="headerlink" title="三、深度优先和广度优先（第6章-图-图的遍历）"></a>三、深度优先和广度优先（第6章-图-图的遍历）</h1><blockquote><p>深度优先：看作树的先序遍历</p><p>广度优先：看作树的层次遍历</p></blockquote><h1 id="四、领接表和矩阵（第6章-图-图的存储结构）"><a href="#四、领接表和矩阵（第6章-图-图的存储结构）" class="headerlink" title="四、领接表和矩阵（第6章-图-图的存储结构）"></a>四、领接表和矩阵（第6章-图-图的存储结构）</h1><h2 id="有向图"><a href="#有向图" class="headerlink" title="有向图"></a>有向图</h2><blockquote><p><img src="/../imgs/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E8%80%83%E7%82%B9%E8%8C%83%E5%9B%B4/image-20230627152246340.png" alt="image-20230627152246340"></p></blockquote><h3 id="1-邻接矩阵"><a href="#1-邻接矩阵" class="headerlink" title="1.邻接矩阵"></a>1.邻接矩阵</h3><blockquote><p>略</p></blockquote><h3 id="2-邻接表"><a href="#2-邻接表" class="headerlink" title="2.邻接表"></a>2.邻接表</h3><blockquote><p><img src="/../imgs/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E8%80%83%E7%82%B9%E8%8C%83%E5%9B%B4/image-20230627152440270.png" alt="image-20230627152440270"></p></blockquote><h2 id="无向图"><a href="#无向图" class="headerlink" title="无向图"></a>无向图</h2><blockquote><p><img src="/../imgs/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E8%80%83%E7%82%B9%E8%8C%83%E5%9B%B4/image-20230627152344346.png" alt="image-20230627152344346"></p></blockquote><h3 id="1-邻接矩阵-1"><a href="#1-邻接矩阵-1" class="headerlink" title="1.邻接矩阵"></a>1.邻接矩阵</h3><blockquote><p>略</p></blockquote><h3 id="2-邻接表-1"><a href="#2-邻接表-1" class="headerlink" title="2.邻接表"></a>2.邻接表</h3><p><img src="/../imgs/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E8%80%83%E7%82%B9%E8%8C%83%E5%9B%B4/image-20230627154639049.png" alt="image-20230627154639049"></p><h1 id="五、最小生成树（第6章-图-图的应用）"><a href="#五、最小生成树（第6章-图-图的应用）" class="headerlink" title="五、最小生成树（第6章-图-图的应用）"></a>五、最小生成树（第6章-图-图的应用）</h1><blockquote><p>求无向树最小生成树问题</p></blockquote><h1 id="prim算法-权值重复多"><a href="#prim算法-权值重复多" class="headerlink" title="prim算法(权值重复多)"></a>prim算法(权值重复多)</h1><blockquote><p>选择开始节点，选择与该节点邻接边权值最小的节点并入集合看成一个整体，找出与该集合的邻接边，并入权值最小的节点然后加入集合看成整体，重复</p><p><strong>注意：选择的邻接表不能与节点之间构成环路</strong></p></blockquote><h1 id="kruskal算法-权值无冗余"><a href="#kruskal算法-权值无冗余" class="headerlink" title="kruskal算法(权值无冗余)"></a>kruskal算法(权值无冗余)</h1><blockquote><p>将所有邻接表的权值按升序排列，将每个节点看成一棵树，按照排列的权值生成，节点之间相邻不能构成环路，如果构成换下一个权值边</p></blockquote><h1 id="六、AVL树（第7章-查找）"><a href="#六、AVL树（第7章-查找）" class="headerlink" title="六、AVL树（第7章-查找）"></a>六、AVL树（第7章-查找）</h1><h1 id="七、散列表散列查找（第7章-查找-散列表的查找）"><a href="#七、散列表散列查找（第7章-查找-散列表的查找）" class="headerlink" title="七、散列表散列查找（第7章-查找-散列表的查找）"></a>七、散列表散列查找（第7章-查找-散列表的查找）</h1><h1 id="八、二叉排序树（第7章-查找-树表的查找）"><a href="#八、二叉排序树（第7章-查找-树表的查找）" class="headerlink" title="八、二叉排序树（第7章-查找-树表的查找）"></a>八、二叉排序树（第7章-查找-树表的查找）</h1><h1 id="九、排序算法（第8章排序）🌟"><a href="#九、排序算法（第8章排序）🌟" class="headerlink" title="九、排序算法（第8章排序）🌟"></a>九、排序算法（第8章排序）🌟</h1><h2 id="冒泡排序法"><a href="#冒泡排序法" class="headerlink" title="冒泡排序法"></a>冒泡排序法</h2><blockquote><p>第一个数和第二个数比较，第二个数和第一个数比较，和泡泡一样往上升</p></blockquote><h2 id="快速排序法"><a href="#快速排序法" class="headerlink" title="快速排序法"></a>快速排序法</h2><blockquote></blockquote><h2 id="直接插入排序法"><a href="#直接插入排序法" class="headerlink" title="直接插入排序法"></a>直接插入排序法</h2><h2 id="希尔排序法"><a href="#希尔排序法" class="headerlink" title="希尔排序法"></a>希尔排序法</h2>]]></content>
    
    
    <categories>
      
      <category>考试复习</category>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
      <tag>考试复习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构-刷题-知识点</title>
    <link href="/2023/06/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%88%B7%E9%A2%98-%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <url>/2023/06/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%88%B7%E9%A2%98-%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<h1 id="第一章-绪论"><a href="#第一章-绪论" class="headerlink" title="第一章-绪论"></a>第一章-绪论</h1><h4 id="1-如何判断程序的复杂程度：时间和空间复杂度"><a href="#1-如何判断程序的复杂程度：时间和空间复杂度" class="headerlink" title="1.如何判断程序的复杂程度：时间和空间复杂度"></a>1.<a href="https://blog.csdn.net/wang_8101/article/details/109017857">如何判断程序的复杂程度：时间和空间复杂度</a></h4><blockquote><p>数据结构中评价两个程序最重要的指标是<strong>时间复杂度</strong>和<strong>空间复杂度</strong></p></blockquote><h1 id="第二章-线性表"><a href="#第二章-线性表" class="headerlink" title="第二章-线性表"></a>第二章-<a href="https://www.cnblogs.com/EXQSLoveForever/p/15642885.html">线性表</a></h1><blockquote><p>线性表定义：线性表是由<em>n</em>(<em>n</em>&gt;&#x3D;0)个相同类型的数据元素组成的有限序列，标记为:L&#x3D;(<em>a</em>1,<em>a</em>2,…,ai,…,an)</p><p>线性表可以为空，当n为0时表示该线性表不包含任何元素为空表</p></blockquote><p><img src="/../imgs/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%88%B7%E9%A2%98-%E7%9F%A5%E8%AF%86%E7%82%B9/image-20230625002019566.png" alt="image-20230625002019566"></p><h4 id="顺序表"><a href="#顺序表" class="headerlink" title="顺序表"></a>顺序表</h4><blockquote><p>随机存取特性：顺序表随机存取与元素个数无关</p><p>如：数组通过下标存取值，与数组内容无关，知道下标就行</p></blockquote><blockquote><p>删除特性：顺序表删除一个元素所用时间与删除的位置和表的长度有关</p><p>理解：根据顺序表的逻辑特征，删除其中一个元素后，后面的元素下表-1覆盖删除元素的位置，删除元素的位置在最后一个元素那么花费的时间短，删除的元素在开头，直接后继一个一个的覆盖</p></blockquote><h4 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h4><blockquote><p>单链表增加头节点是为了方便元素插入和删除运算的实现</p></blockquote><blockquote><p>头节点建立单链表：后面的节点先插入到最前端</p><p>理解：数组A与1、2、3的值，头节点建立L后顺序为3、2、1</p></blockquote><blockquote><p>在长度为n&gt;&#x3D;1的L中查找和删除尾节点的时间复杂度均为O(n)</p></blockquote><blockquote><p>带头节点的循环单链表为空时满足L-next&#x3D;&#x3D;L</p><p>理解：循环单链表想象成一个环形的链表，L-next&#x3D;&#x3D;L相当于L下一个节点等于自己，即表为空</p></blockquote><h4 id="双链表"><a href="#双链表" class="headerlink" title="双链表"></a>双链表</h4><blockquote><p><strong>双链表中每个结点有指向前后结点的指针即可访问前后结点</strong></p></blockquote><blockquote><p>双链表为空的条件为L-&gt;next&#x3D;&#x3D;NULL</p><p>理解：与单链一致</p></blockquote><blockquote><p>循环双链表和非顺序双链表删除头节点和尾节点的时间复杂度，两个删除头节点复杂度为O（1），删除尾节点时循环双L为O（1），后者为O（n）</p></blockquote><h1 id="第三章-栈和队列"><a href="#第三章-栈和队列" class="headerlink" title="第三章-栈和队列"></a>第三章-栈和队列</h1><blockquote></blockquote><h3 id="一、栈"><a href="#一、栈" class="headerlink" title="一、栈"></a>一、栈</h3><blockquote><p>栈的定义：<strong>栈是一种只能在一端进行插入或删除操作的线性表</strong></p><p>入栈出栈规则：元素先进后出，后进先出</p></blockquote><h4 id="3-1-出栈顺序题（判断出栈顺序正确新）"><a href="#3-1-出栈顺序题（判断出栈顺序正确新）" class="headerlink" title="3.1 出栈顺序题（判断出栈顺序正确新）"></a>3.1 出栈顺序题（判断出栈顺序正确新）</h4><h5 id="3-1-1-递增顺序"><a href="#3-1-1-递增顺序" class="headerlink" title="3.1.1 递增顺序"></a>3.1.1 递增顺序</h5><blockquote><p><img src="/../imgs/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%88%B7%E9%A2%98-%E7%9F%A5%E8%AF%86%E7%82%B9/image-20230625022451914.png" alt="image-20230625022451914"></p><p>理解：排除法做题，设第一个出栈的元素为x，不考虑比x大的元素入栈，此时栈内元素出栈的顺序必为递减</p><p><img src="/../imgs/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%88%B7%E9%A2%98-%E7%9F%A5%E8%AF%86%E7%82%B9/image-20230625023611561.png" alt="image-20230625023611561"></p><p>分析A，此时出栈为3，不考虑比3大的元素，那么出栈必然会有3、2、1，故A正确</p><p>分析B，出栈为5，那么出栈必有5、4、3、2、1，显然1、2不对</p><p>分析C，出栈为4，那么必然有4、3、2、1，显然1、3不对</p><p>分析D，出栈为4，同上，1、2不对</p></blockquote><h5 id="3-1-2-递减顺序"><a href="#3-1-2-递减顺序" class="headerlink" title="3.1.2 递减顺序"></a>3.1.2 递减顺序</h5><blockquote><p>和递增类似，补考虑比出栈元素小的，找比出栈元素大的</p><p>例子：4、3、2、1</p><p>如果3出栈，不考虑2、1，必然有3、4</p><p>如果出栈为1，必然有1、2、3、4</p><p><img src="/../imgs/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%88%B7%E9%A2%98-%E7%9F%A5%E8%AF%86%E7%82%B9/image-20230625024234556.png" alt="image-20230625024234556"></p><p>分析A，2出栈，必然有3、4、5、6，正确</p><p>分析B，3出栈，必然有4、5、6，显然4、6不对</p><p>分析C，5出栈，必然有5、6，正确</p><p>分析D，4出栈，必然有4、5、6，正确</p></blockquote><h5 id="3-1-3-字母类型"><a href="#3-1-3-字母类型" class="headerlink" title="3.1.3 字母类型"></a>3.1.3 字母类型</h5><blockquote><p>和数字一样，麻烦点直接把字符标数字，如A&#x3D;1，B&#x3D;2</p></blockquote><h4 id="3-2-栈顶入栈和栈底入栈（top-gt-0和top-gt-n-1"><a href="#3-2-栈顶入栈和栈底入栈（top-gt-0和top-gt-n-1" class="headerlink" title="3.2 栈顶入栈和栈底入栈（top-&gt;0和top-&gt;n-1)"></a>3.2 栈顶入栈和栈底入栈（top-&gt;0和top-&gt;n-1)</h4><blockquote><p>情况1：top初始值为0，即top在栈低入栈，元素x入栈时top++,data[top]&#x3D;x,top&#x3D;n-1时栈满</p><p>情况2：top初始值为n-1，即top在栈顶入栈，元素x入栈时top–，data[top]&#x3D;x,top&#x3D;0时栈满</p></blockquote><h3 id="二、队列"><a href="#二、队列" class="headerlink" title="二、队列"></a>二、队列</h3><blockquote><p>队列的定义：<strong>是只允许在一端进行插入操作，而在另一端进行删除操作的线性表</strong></p><p>入队出队规则：先进先出</p></blockquote><blockquote><p>循环队列为空：通常用front&#x3D;&#x3D;rear来判断栈是否为空，栈满时无法判断</p></blockquote><h4 id="循环队列空还是满的三种处理方式（可能考简答题🌟）"><a href="#循环队列空还是满的三种处理方式（可能考简答题🌟）" class="headerlink" title="循环队列空还是满的三种处理方式（可能考简答题🌟）"></a>循环队列空还是满的三种处理方式（可能考简答题🌟）</h4><ol><li><p>牺牲一个单元格区分堆满或对空：当front指向rear下一个位置时为队满</p><blockquote><p>队空：Q.front&#x3D;&#x3D;Q.rear</p><p>队满：(Q.rear+1)%N&#x3D;&#x3D;Q.front</p><p>队列中元素的个数：(rear-front+N)%N</p></blockquote></li><li><p>在Q的类型中新增关于元素个数的数据成员size</p><blockquote><p>队空：size&#x3D;0</p><p>队满：size&#x3D;N</p></blockquote></li><li><p>在Q的类型中新增tag数据成员</p><blockquote><p>队空：tag&#x3D;0,因删除操作队空</p><p>队满：tag&#x3D;1，因入队操作队满</p></blockquote></li></ol><h4 id="循环队列操作（插入、删除）"><a href="#循环队列操作（插入、删除）" class="headerlink" title="循环队列操作（插入、删除）"></a>循环队列操作（插入、删除）</h4><blockquote><p>条件：循环队列qu,data下表0~n-1,队头指针front、队尾指针rear</p><p>插入：队列插入的一端为队尾rear，删除的一端为队头，x元素入队qu.rear&#x3D;(qu.rear+1)%N,qu.data[qu.rear]&#x3D;x</p><p>删除（出队）：qu.font&#x3D;(qu.font+1)%N</p><p><img src="/../imgs/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%88%B7%E9%A2%98-%E7%9F%A5%E8%AF%86%E7%82%B9/d01d208e645a8c52bd6d361abd330f19.jpeg" alt="img"></p></blockquote><h4 id="顺序队和链队的比较"><a href="#顺序队和链队的比较" class="headerlink" title="顺序队和链队的比较"></a>顺序队和链队的比较</h4><blockquote><p>尽管链队总是采用动态分配方式，其长度也受内存大小的限制，也不可能实现无限长队列。</p><p>顺序队和链队的进队和出队操作时间均为O(1)。</p><p>顺序队和链队都可以进行顺序访问。</p><p>在顺序队中可以通过队头和队尾指针计算队中元素个数，而链队不能。</p></blockquote><h1 id="第四章-串、数组、广义表"><a href="#第四章-串、数组、广义表" class="headerlink" title="第四章-串、数组、广义表"></a>第四章-串、数组、广义表</h1><h3 id="一、串"><a href="#一、串" class="headerlink" title="一、串"></a>一、串</h3><blockquote><p><strong>概念</strong>：字符串简称为串，串是由字符元素构成的，其中元素的逻辑关系也是一种线性关系。</p><p><strong>字符</strong>：在一般情况下，英文字母、数字（0，1，·····9）和常用的标点符号以及空格符等都是合法的字符。</p><p><strong>空串</strong>：含零个字符的串称为空串</p><p><strong>串相等条件</strong>：两个串相等当且仅当这两个串的长度相等并且个对应位置上的字符都相同。</p><p><strong>子串的定义</strong>：将一个字符串从开头与结尾删去任意字符，形成新的字符串，称为原字符串的子串。<br><strong>子序列的定义</strong>：将一个字符串删去任意字符，形成新的字符串，称为原字符串的子序列。</p><p><strong>真子串：</strong>指从原字符串中通过删除某些字符但不破坏余下字符的顺序而形成的新字符串，真子串不包含原本的串</p><p><strong>非空子串</strong>：不包含空串的字串</p><p><strong>非空真子串</strong>：不包含空串的真子串</p><p><strong>模式匹配算法</strong>：求字串在串中首次出现的位置</p></blockquote><h4 id="1-子串求解方法"><a href="#1-子串求解方法" class="headerlink" title="1. 子串求解方法"></a>1. 子串求解方法</h4><blockquote><ol><li>子串的求解方法<br>n(n+1)&#x2F;2 +1<br>此处n为8，所以串S的子串为37</li><li>真子串的求解方法<br>n(n+1)&#x2F;2<br>此处n为8，所以S的真子串为36</li><li>非空子串的求解方法<br>n(n+1)&#x2F;2<br>此处n为8，所以S的非空子串为36</li><li>非空真子串的求解方法<br>n(n+1)&#x2F;2-1<br>此处n为8，所以S的非空真子串为35</li></ol></blockquote><h4 id="2-链串求解"><a href="#2-链串求解" class="headerlink" title="2.链串求解"></a>2.链串求解</h4><blockquote><p>求链串密度：（节点大小*字符字节)&#x2F;(节点大小*字符所占字节大小+指针字节)</p></blockquote><h4 id="3-串的操作"><a href="#3-串的操作" class="headerlink" title="3.串的操作"></a>3.串的操作</h4><h5 id="3-1-模式匹配算法"><a href="#3-1-模式匹配算法" class="headerlink" title="3.1 模式匹配算法"></a>3.1 模式匹配算法</h5><blockquote><p>从主串找子串的位置算法，常见的两种匹配方式为BF、KMP算法</p><p> 模式串：在主串中需要寻找的子串，长度用m表示。</p></blockquote><h6 id="3-3-1-简单匹配算法（BF）"><a href="#3-3-1-简单匹配算法（BF）" class="headerlink" title="3.3.1 简单匹配算法（BF）"></a>3.3.1 简单匹配算法（BF）</h6><blockquote><p>思想：</p><p><strong>第一轮</strong>：子串中的第一个字符与主串中的第一个字符进行比较</p><ul><li><p><strong>若相等</strong>，则继续比较主串与子串的第二个字符</p></li><li><p><strong>若不相等</strong>，进行第二轮比较</p></li><li><p><strong>第二轮</strong>：子串中的第一个字符与主串中第二个字符进行比较</p></li><li><p><strong>第N轮</strong>：依次比较下去，直到所有匹配</p></li></ul><p>缺点：匹配过程屡次回溯，效率很低，时间复杂度O(主串L*子串L)</p></blockquote><p><strong>图示说明：</strong></p><p><img src="/../imgs/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%88%B7%E9%A2%98-%E7%9F%A5%E8%AF%86%E7%82%B9/image-20230626185308725.png" alt="image-20230626185308725"></p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">String::bfFind</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">String</span> &amp;s, <span class="hljs-type">int</span> pos)</span> <span class="hljs-type">const</span> </span>&#123;<br>    <span class="hljs-comment">//主串和子串的指针，i主串，j子串</span><br>    <span class="hljs-type">int</span> i, j;<br>    <span class="hljs-comment">//主串比子串小，匹配失败，curLenght为串的长度</span><br>    <span class="hljs-keyword">if</span> (curLength &lt; s.curLenght)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <br>    <span class="hljs-keyword">while</span> (i &lt; curLength &amp;&amp; j &lt; s.curLength) &#123;<br>        <span class="hljs-comment">//对应字符相等，指针后移</span><br>        <span class="hljs-keyword">if</span> (data[i] == s.data[j])<br>            i+, j++;<br>       <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">//对应字符不相等</span><br>            i = i -j + <span class="hljs-number">1</span>;<span class="hljs-comment">//主串指针移动</span><br>            j = <span class="hljs-number">0</span>; <span class="hljs-comment">//子串从头开始</span><br>        &#125;<br>        <span class="hljs-comment">//返回子串在主串的位置</span><br>        <span class="hljs-keyword">if</span> (j &gt;= s.curLength) <br>            <span class="hljs-keyword">return</span> (i - s.curLength);<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;    <br>    &#125;<br></code></pre></td></tr></table></figure><h6 id="3-3-2-KMP模式匹配算法"><a href="#3-3-2-KMP模式匹配算法" class="headerlink" title="3.3.2 KMP模式匹配算法"></a>3.3.2 KMP模式匹配算法</h6><blockquote><p>KMP算法用于改进BF算法匹配失败的次数，通过获取第一次匹配失败的信息滑块移动模式串J，目标串I不后退正常前进</p><p>复杂度：O(m+n)</p><p><img src="/../imgs/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%88%B7%E9%A2%98-%E7%9F%A5%E8%AF%86%E7%82%B9/image-20230626191930112.png" alt="image-20230626191930112"></p></blockquote><h3 id="二、数组"><a href="#二、数组" class="headerlink" title="二、数组"></a>二、数组</h3><blockquote><p>给出n维数组求元素个数：计算每个维度的长度相乘得到元素个个数</p><p>例：A[1-3][2-3]元素个数</p><blockquote><p>A的一维数组长度：1、2、3&#x3D;3</p><p>A的二维数组长度：2、3</p><p>A数组元素个数&#x3D;2*3&#x3D;6</p></blockquote></blockquote><h4 id="1-数组行优先顺序"><a href="#1-数组行优先顺序" class="headerlink" title="1. 数组行优先顺序"></a>1. 数组行优先顺序</h4><blockquote><p>二维数组a[m][n]<strong>求a[i][j]存储地址</strong>：Loc(a[0][0])+[i*n+j]*k</p><p>m：一维长度</p><p>n：二维长度</p><p>k：每个元素所占存储单元大小</p><p>Loc：根据索引取地址</p></blockquote><blockquote><p>假设二维数组a中，行数为m，列数为n，则按行优先存储时，某个元素a[i][j]之前的元素个数可以用以下公式计算：</p><p><strong>前面的元素个数</strong> &#x3D; (i - 1) × n + j - 1</p></blockquote><h3 id="三、特殊矩阵"><a href="#三、特殊矩阵" class="headerlink" title="三、特殊矩阵"></a>三、特殊矩阵</h3><h4 id="1-n阶对称矩阵压缩方式"><a href="#1-n阶对称矩阵压缩方式" class="headerlink" title="1.n阶对称矩阵压缩方式"></a>1.n阶对称矩阵压缩方式</h4><blockquote><p>求该矩阵下三角元素放入一维数组中的个数：n(n+1)&#x2F;2</p></blockquote><blockquote><p>该A矩阵下三角元素放入一维数组，求A[i][j]在一维数组中位置K：j(j-1)&#x2F;2+i</p></blockquote><h4 id="2-n阶上三角矩阵按行优先压缩"><a href="#2-n阶上三角矩阵按行优先压缩" class="headerlink" title="2.n阶上三角矩阵按行优先压缩"></a>2.n阶上三角矩阵按行优先压缩</h4><blockquote><p>放入数组求数组元素个数：n(n+1)&#x2F;2+1</p></blockquote><h4 id="3-n阶三对角矩阵按行优先"><a href="#3-n阶三对角矩阵按行优先" class="headerlink" title="3.n阶三对角矩阵按行优先"></a>3.n阶三对角矩阵按行优先</h4><blockquote><p>放入数组求数组元素个数：3n-2</p></blockquote><h4 id="4-稀疏矩阵压缩存储"><a href="#4-稀疏矩阵压缩存储" class="headerlink" title="4.稀疏矩阵压缩存储"></a>4.稀疏矩阵压缩存储</h4><h1 id="第五章-树和二叉树"><a href="#第五章-树和二叉树" class="headerlink" title="第五章-树和二叉树"></a>第五章-树和二叉树</h1><h2 id="一、树（概念性，便于理解）"><a href="#一、树（概念性，便于理解）" class="headerlink" title="一、树（概念性，便于理解）"></a>一、树（概念性，便于理解）</h2><h3 id="1-概念"><a href="#1-概念" class="headerlink" title="1.概念"></a>1.概念</h3><blockquote><p>树形结构是一种非线性结构，与线性结构的区别在于树形结构一对多的关系，线性结构是一对一的关系，</p><p>树形结构节点之间具有分支，具有层次结构</p><p>树结生活中的例子：家谱、行政组织、编程语句块缩进、数据库信息组织</p><p><strong>树的定义</strong>：树是n(n&gt;0)个节点的有限集合T</p><ul><li>当n&gt;0时，树有且只有一个根节点</li><li>其余节点为m(m&gt;&#x3D;0)个互不相交的有限集合，每个m节点又可以组成一个树，该m节点称之为根节点的子树</li></ul><p><strong>空树</strong>：n&#x3D;0,0个节点的树</p></blockquote><h3 id="2-特点"><a href="#2-特点" class="headerlink" title="2.特点"></a>2.特点</h3><blockquote><p>根节点：有且只有一个节点没有直接前驱</p><p>叶子节点：有一个或多个节点没有直接后继</p><p>除根节点外，其余节点有且只有一个直接前驱</p><p>除叶子节点外，其余节点有一个或多个直接后继</p></blockquote><h3 id="3-术语"><a href="#3-术语" class="headerlink" title="3.术语"></a>3.术语</h3><blockquote><p>节点：树中包含一个数据元素及若干指向子树的分支</p><p>节点的度：一个节点所具有子树的个数</p><p>树的度：树的度等于树种节点最大的度</p><p>叶子：度为0的节点</p><p>非终端节点：除根节点之外度不为0的节点</p><p>双亲、孩子节点：树中某个节点所组成子树的根称之为该节点的孩子节点，该节点为孩子节点的双亲节点</p><p>兄弟节点：具有同一个双亲节点的多个节点称之为兄弟节点</p><p>祖先：从该节点往根节经过的分支节点称之为该节点的祖先</p><p>子孙：以某一结点为根的子树中的任意节点都称之为该节点的子孙</p><p>树的高度：树中节点的最大层数称之为树的高度</p><p>有序树：子节点之间存在某种顺序关系，谁在左谁在右</p><p>无序树：子节点之间不存在顺序关系的树</p><p>森林：m棵互补相交的树的集合</p></blockquote><h2 id="二、二叉树🌟"><a href="#二、二叉树🌟" class="headerlink" title="二、二叉树🌟"></a>二、二叉树🌟</h2><blockquote><p>定义：由n&gt;&#x3D;o个节点所组成的有限序集合，当n&gt;0时由一个根节点1以及两棵互不相交的左子树和右子树的子二叉树组成</p></blockquote><h3 id="1-特征"><a href="#1-特征" class="headerlink" title="1.特征"></a>1.特征</h3><blockquote><p>二叉树中每个节点做多只能拥有两棵子书</p><p>二叉树的度最大为2，即树的度最多为2</p><p>每个孩子节点都有左右之分</p></blockquote><h3 id="2-二叉树五种基本状态"><a href="#2-二叉树五种基本状态" class="headerlink" title="2.二叉树五种基本状态"></a>2.二叉树五种基本状态</h3><p><img src="/../imgs/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%88%B7%E9%A2%98-%E7%9F%A5%E8%AF%86%E7%82%B9/image-20230627024108720.png" alt="image-20230627024108720"></p><h3 id="3-性质"><a href="#3-性质" class="headerlink" title="3.性质"></a>3.性质</h3><blockquote><ul><li>在二叉树中第i层中(i&gt;&#x3D;1),最多有2^(i-1)个节点</li><li>根据上述的性质，深度为k的二叉树最多有(2^k)-1个节点</li><li>对于任意二叉树，设叶子节点为n0,度为2节点的个数为n2,则有n0&#x3D;n2+1</li></ul></blockquote><h2 id="三、特殊二叉树"><a href="#三、特殊二叉树" class="headerlink" title="三、特殊二叉树"></a>三、特殊二叉树</h2><h3 id="1-满二叉树"><a href="#1-满二叉树" class="headerlink" title="1.满二叉树"></a>1.满二叉树</h3><blockquote><p>深度为k且有(2^k)-1个节点的二叉树称之为满二叉树</p></blockquote><h4 id="特征：每一层上的节点都达到最大值，节点树为-2-k-1-叶子节点都在最下面一层"><a href="#特征：每一层上的节点都达到最大值，节点树为-2-k-1-叶子节点都在最下面一层" class="headerlink" title="特征：每一层上的节点都达到最大值，节点树为(2^k)-1,叶子节点都在最下面一层"></a>特征：每一层上的节点都达到最大值，节点树为(2^k)-1,叶子节点都在最下面一层</h4><h3 id="2-完全二叉树"><a href="#2-完全二叉树" class="headerlink" title="2.完全二叉树"></a>2.完全二叉树</h3><blockquote><p>对一颗具有n个结点的二叉树按层序编号，如果编号为i的结点与同样深度的满二叉树中编号为i的结点在二叉树中的位置相同，则这棵二叉树称为完全二叉树</p></blockquote><h4 id="特征："><a href="#特征：" class="headerlink" title="特征："></a>特征：</h4><ul><li>叶子结点只能出现在最下两层。</li><li>最下层的叶子一定集中在左部连续位置。</li><li>倒数第二层，若有叶子结点，一定都在右部连续位置。</li><li>如果结点度为1，则该结点只有左孩子。</li><li>同样结点数为2的二叉树，完全二叉树的深度最小。</li></ul><h2 id="四、二叉树遍历"><a href="#四、二叉树遍历" class="headerlink" title="四、二叉树遍历"></a>四、二叉树遍历</h2><h3 id="1-先序遍历"><a href="#1-先序遍历" class="headerlink" title="1.先序遍历"></a>1.先序遍历</h3><blockquote><p>规则：先从根节点开始，先遍历左子树，再遍历右子树</p></blockquote><p><img src="/../imgs/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%88%B7%E9%A2%98-%E7%9F%A5%E8%AF%86%E7%82%B9/image-20230627031937171.png" alt="image-20230627031937171"></p><p>顺序：1、2、3、4、5、6</p><h3 id="2-中序遍历"><a href="#2-中序遍历" class="headerlink" title="2.中序遍历"></a>2.中序遍历</h3><blockquote><p>先遍历左子树、访问根节点、遍历右子树</p><p><img src="/../imgs/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%88%B7%E9%A2%98-%E7%9F%A5%E8%AF%86%E7%82%B9/image-20230627032525022.png" alt="image-20230627032525022"></p></blockquote><p>顺序：4、2、5、1、6、3、7</p><h3 id="3-后序遍历"><a href="#3-后序遍历" class="headerlink" title="3.后序遍历"></a>3.后序遍历</h3><blockquote><p>先遍历左子树，后遍历右子树，最后根</p><p><img src="/../imgs/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%88%B7%E9%A2%98-%E7%9F%A5%E8%AF%86%E7%82%B9/image-20230627032742272.png" alt="image-20230627032742272"></p></blockquote><p>顺序：4526731</p>]]></content>
    
    
    <categories>
      
      <category>考试复习</category>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
      <tag>考试复习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构-书本复习</title>
    <link href="/2023/06/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%B9%A6%E6%9C%AC%E5%A4%8D%E4%B9%A0/"/>
    <url>/2023/06/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%B9%A6%E6%9C%AC%E5%A4%8D%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="一、"><a href="#一、" class="headerlink" title="一、"></a>一、</h1>]]></content>
    
    
    <categories>
      
      <category>考试复习</category>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
      <tag>考试复习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构-刷题</title>
    <link href="/2023/06/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%88%B7%E9%A2%98/"/>
    <url>/2023/06/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%88%B7%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="第一周测验"><a href="#第一周测验" class="headerlink" title="第一周测验"></a>第一周测验</h1><h2 id="1、计算机所处理的数据一般具备某种内在联系，这是指（-）。"><a href="#1、计算机所处理的数据一般具备某种内在联系，这是指（-）。" class="headerlink" title="1、计算机所处理的数据一般具备某种内在联系，这是指（ ）。"></a>1、计算机所处理的数据一般具备某种内在联系，这是指（ ）。</h2><p>A.数据和数据之间存在某种关系<br>B.元素和元素之间存在某种关系<br>C.元素内部具有某种结构<br>D.数据项和数据项之间存在某种关系<br><strong>正确答案：B</strong><br>解析： B、在<a href="https://so.csdn.net/so/search?q=%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84&spm=1001.2101.3001.7020">数据结构</a>中讨论的关系指的是元素和元素之间的关系。</p><p><strong>课本考据：数据是描述客观事物的数和字符的集合，人们通常以数据元素作为数据的基本单位。其中数据元素也成为元素、结点、顶点或者记录。</strong></p><h2 id="2、在数据结构中，与所使用的计算机无关的是数据的（-）结构。"><a href="#2、在数据结构中，与所使用的计算机无关的是数据的（-）结构。" class="headerlink" title="2、在数据结构中，与所使用的计算机无关的是数据的（ ）结构。"></a>2、在数据结构中，与所使用的计算机无关的是数据的（ ）结构。</h2><p>A.逻辑<br>B.存储<br>C.逻辑和存储<br>D.物理<br><strong>正确答案：A</strong><br>解析： A、逻辑结构与存储结构无关，也就是与使用的计算机无关。</p><p><strong>课本考据：数据的逻辑结构由数据元素之间的逻辑关系构成，数据逻辑结构与数据的存储无关，是独立于计算机的，因此数据的逻辑结构可以看作是从具体问题抽象出来的数学模型。</strong></p><h2 id="3、在计算机中存储数据时，通常不仅要存储各数据元素的值，而且还要存储（-）。"><a href="#3、在计算机中存储数据时，通常不仅要存储各数据元素的值，而且还要存储（-）。" class="headerlink" title="3、在计算机中存储数据时，通常不仅要存储各数据元素的值，而且还要存储（ ）。"></a>3、在计算机中存储数据时，通常不仅要存储各数据元素的值，而且还要存储（ ）。</h2><p>A.数据的处理方法<br>B.数据元素的类型<br>C.数据元素之间的关系<br>D.数据的存储方法<br><strong>正确答案：C</strong><br>解析： C、将数据逻辑结构映射成存储数据时，需要存储所有数据元素的值和数据元素之间关系。</p><h2 id="4、数据结构在计算机内存中的表示是指（-）。"><a href="#4、数据结构在计算机内存中的表示是指（-）。" class="headerlink" title="4、数据结构在计算机内存中的表示是指（ ）。"></a>4、数据结构在计算机内存中的表示是指（ ）。</h2><p>A.数据的存储结构<br>B.数据结构<br>C.数据的逻辑结构<br>D.数据元素之间的关系<br><strong>正确答案：A</strong><br>解析： A、数据的存储结构是逻辑结构在计算机内存中的表示，它既保存数据元素，也保存数据元素之间的关系。</p><p><strong>课本考据：数据逻辑结构在计算机存储器中的存储表示成为数据的存储结构（也称为映像），也就是逻辑结构在计算机中的存储实现。</strong></p><h2 id="5、数据在计算机的存储器中表示时，逻辑上相邻的两个元素对应的物理地址也是相邻的，这种存储结构称之为（-）。"><a href="#5、数据在计算机的存储器中表示时，逻辑上相邻的两个元素对应的物理地址也是相邻的，这种存储结构称之为（-）。" class="headerlink" title="5、数据在计算机的存储器中表示时，逻辑上相邻的两个元素对应的物理地址也是相邻的，这种存储结构称之为（ ）。"></a>5、数据在计算机的存储器中表示时，逻辑上相邻的两个元素对应的物理地址也是相邻的，这种存储结构称之为（ ）。</h2><p>A.逻辑结构<br>B.顺序存储结构<br>C.链式存储结构<br>D.以上都对<br><strong>正确答案：B</strong><br>解析： B、顺序存储结构是逻辑结构的一种直接映射，通过数据元素之间的物理关系来表示逻辑关系。</p><p><strong>课本考据：顺序存储结构的定义——是采用一组连续的存储单元存放的数据元素，也就是说所有数据元素在存储器中占有一整块存储空间，而且两个逻辑上相邻的元素在存储器中的存储位置也相邻。</strong></p><h2 id="6、数据采用链式存储结构时，要求（-）。"><a href="#6、数据采用链式存储结构时，要求（-）。" class="headerlink" title="6、数据采用链式存储结构时，要求（ ）。"></a>6、数据采用链式存储结构时，要求（ ）。</h2><p>A.每个节点占用一片连续的存储区域<br>B.所有节点占用一片连续的存储区域<br>C.节点的最后一个域必须是指针域<br>D.每个节点有多少后继节点，就必须设多少个指针域<br><strong>正确答案：A</strong><br>解析： A、在链式存储结构中，通常一个结点是整体分配存储空间的，所以每个结点占用一片连续的存储区域，所有结点的存储地址既可以连续也可以不连续，所以所有结点不一定占用一片连续的存储区域。</p><p><strong>课本考据：在链式存储结构中，每个逻辑元素用一个内存节点存储，每个节点是单独分配的，所有的节点地址不一定是连续的，所有无须占用一整块存储空间。</strong></p><h2 id="7、可以用（-）定义一个完整的数据结构。"><a href="#7、可以用（-）定义一个完整的数据结构。" class="headerlink" title="7、可以用（ ）定义一个完整的数据结构。"></a>7、可以用（ ）定义一个完整的数据结构。</h2><p>A.数据元素<br>B.数据对象<br>C.数据关系<br>D.抽象数据类型<br><strong>正确答案：D</strong><br>解析： D、抽象数据类型指的是用户进行软件系统设计时从问题的数学模型中抽象出来的逻辑数据结构和逻辑数据结构上的运算，可以定义一个完整的数据结构。</p><p><strong>补充：抽象数据类型不考虑计算机的具体存储结构和运算的具体实现算法。</strong></p><h2 id="8、算法指的是（-）。"><a href="#8、算法指的是（-）。" class="headerlink" title="8、算法指的是（ ）。"></a>8、算法指的是（ ）。</h2><p>A.计算机程序<br>B.解决问题的方法<br>C.查找或排序过程<br>D.求解特定问题的指令有限序列<br><strong>正确答案：D</strong><br>解析： D、算法是求解特定问题的指令有限序列。</p><p><strong>补充：数据元素之间有逻辑关系和物理关系，对应的运算有基于逻辑结构的运算描述和居于存储结构的运算实现——通常我们把基于存储结构的运算实现的步骤或过程称为算法。</strong></p><h2 id="9、在算法设计时，若实参和形参同步发生改变，则应把形参变量说明为（-）型参数。"><a href="#9、在算法设计时，若实参和形参同步发生改变，则应把形参变量说明为（-）型参数。" class="headerlink" title="9、在算法设计时，若实参和形参同步发生改变，则应把形参变量说明为（ ）型参数。"></a>9、在算法设计时，若实参和形参同步发生改变，则应把形参变量说明为（ ）型参数。</h2><p>A.指针<br>B.引用<br>C.传值<br>D.常数<br><strong>正确答案：B</strong><br>解析： B、函数的形参变量与对应的实参共享相同的存储空间，可以将形参值回传给对应的实参。</p><h2 id="10、某算法的时间复杂度为O-n2-，表明该算法的（-）。"><a href="#10、某算法的时间复杂度为O-n2-，表明该算法的（-）。" class="headerlink" title="10、某算法的时间复杂度为O(n2)，表明该算法的（ ）。"></a>10、某算法的时间复杂度为O(n2)，表明该算法的（ ）。</h2><p>A.问题规模是<br>B.执行时间等于<br>C.执行时间与n2成正比<br>D.问题规模与n2成正比<br><strong>正确答案：C</strong><br>解析： C、<strong>算法的时间复杂度是问题规模n的函数，某算法的时间复杂度为O(n2),表示该算法的频度为cn2（c为一个正常量），即执行时间与n2成正比。</strong></p><h1 id="第二周测验"><a href="#第二周测验" class="headerlink" title="第二周测验"></a>第二周测验</h1><h2 id="1、线性表是（-）。"><a href="#1、线性表是（-）。" class="headerlink" title="1、线性表是（ ）。"></a>1、<a href="https://so.csdn.net/so/search?q=%E7%BA%BF%E6%80%A7%E8%A1%A8&spm=1001.2101.3001.7020">线性表</a>是（ ）。</h2><p>A.一个有限序列，可以为空<br>B.一个有限序列，不可以为空<br>C.一个无限序列，可以为空<br>D.一个无限序列，不可以为空<br><strong>正确答案：A</strong><br>解析： A、线性表是具有n（n≥0）个数据元素的有限序列。</p><p><strong>课本考据：线性表是具有相同特征的数据元素的一个有限序列。当 n&#x3D;0时，表示线性表是一个空表，即不包含任何元素。</strong></p><h2 id="2、线性表的基本运算ListInsert-amp-L-i-e-表示在线性表L中第i个位置上插入一个元素e，若L的长度为n，则i的合法取值是（-）。"><a href="#2、线性表的基本运算ListInsert-amp-L-i-e-表示在线性表L中第i个位置上插入一个元素e，若L的长度为n，则i的合法取值是（-）。" class="headerlink" title="2、线性表的基本运算ListInsert(&amp;L,i,e)表示在线性表L中第i个位置上插入一个元素e，若L的长度为n，则i的合法取值是（ ）。"></a>2、线性表的基本运算ListInsert(&amp;L,i,e)表示在线性表L中第i个位置上插入一个元素e，若L的长度为n，则i的合法取值是（ ）。</h2><p>A.1≤i≤n<br>B.1≤i≤n+1<br>C.0≤i≤n-1<br>D. 0≤i≤n<br><strong>正确答案：B</strong><br>解析： B、线性表的基本运算ListInsert(&amp;L，i，e)中，位置i是指逻辑序号，可以在L的位置1到位置n+1插入元素。</p><p><strong>课本考据：插入数据元素，在L的第i（1&lt;&#x3D;i&lt;&#x3D;n+1）个位置插入一个新的元素e，L的长度增一。</strong></p><h2 id="3、顺序表具有随机存取特性，指的是（-）。"><a href="#3、顺序表具有随机存取特性，指的是（-）。" class="headerlink" title="3、顺序表具有随机存取特性，指的是（ ）。"></a>3、顺序表具有随机存取特性，指的是（ ）。</h2><p>A.查找值为x的元素与顺序表中元素个数n无关<br>B.查找值为x的元素与顺序表中元素个数n有关<br>C.查找序号为i的元素与顺序表中元素个数n无关<br>D.查找序号为i的元素与顺序表中元素个数n有关<br><strong>正确答案：C</strong><br>解析： C、一种存储结构具有随机存取特性指的是，对于给定的序号i，在O(1)时间内找到对应元素值。</p><p><strong>课本考据：顺序表示线性表的直接映射，可从求线性表中的某个数据元素的值的算法得知<br>&#x3D;&gt;<br>一个没有循环（或者有循环，但循环的次数与问题规模 n无关）的算法中原操作执行次数与问题规模无关，记作O（1），也成为常数阶</strong>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">bool</span> <span class="hljs-title function_">GetElem</span><span class="hljs-params">(SqList * L,<span class="hljs-type">int</span> i, ElemType &amp;e)</span><br>&#123;<br><span class="hljs-keyword">if</span>(i&lt;<span class="hljs-number">1</span> || i&gt;L-&gt;length)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>e=L-&gt;data[i<span class="hljs-number">-1</span>];<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4、在顺序表中删除一个元素所需要的时间（-）。"><a href="#4、在顺序表中删除一个元素所需要的时间（-）。" class="headerlink" title="4、在顺序表中删除一个元素所需要的时间（ ）。"></a>4、在顺序表中删除一个元素所需要的时间（ ）。</h2><p>A.与删除元素的位置及顺序表的长度都有关<br>B.只与删除元素的位置有关<br>C.与删除任何其他元素所需要的时间相等<br>D.只与顺序表的长度有关<br><strong>正确答案：A</strong><br>解析： A、当从顺序表中删除元素时，为了保持顺序表的逻辑特性，需要移动元素以覆盖该删除的元素。因此在顺序表中删除一个元素与该元素的位置及顺序表的长度都有关。</p><p><strong>课本考据：元素移动的次数与表长n&#x3D;L-&gt;length和删除元素的位置i有关，共有n个元素可被删除。</strong></p><h2 id="5、在n（n-gt-1）个运算的顺序表中，算法时间复杂度为O-1-的运算是（-）。"><a href="#5、在n（n-gt-1）个运算的顺序表中，算法时间复杂度为O-1-的运算是（-）。" class="headerlink" title="5、在n（n&gt;1）个运算的顺序表中，算法时间复杂度为O(1)的运算是（ ）。"></a>5、在n（n&gt;1）个运算的顺序表中，算法时间复杂度为O(1)的运算是（ ）。</h2><p>A.访问第i个元素（2≤i≤n）并求其前驱元素<br>B.在第i个元素之后插入一个新元素<br>C.删除第i个元素<br>D.将这n个元素递增排序<br><strong>正确答案：A</strong><br>解析： A、访问第i个元素（2≤i≤n）即L-&gt;data[i-1]和求其前驱元素L-&gt;data[i-2]的时间复杂度均为O(1)。</p><p><strong>课本考据：元素移动的次数不仅与表长n&#x3D;L-&gt;length有关，而且与插入、删除的位置i有关，平均时间复杂度为O（n）。</strong></p><h2 id="6、关于线性表的顺序存储结构和链式存储结构的描述中，正确的是（-）。"><a href="#6、关于线性表的顺序存储结构和链式存储结构的描述中，正确的是（-）。" class="headerlink" title="6、关于线性表的顺序存储结构和链式存储结构的描述中，正确的是（ ）。"></a>6、关于线性表的顺序存储结构和链式存储结构的描述中，正确的是（ ）。</h2><p>Ⅰ.线性表的顺序存储结构优于链式存储结构<br>Ⅱ.顺序存储结构比链式存储结构的存储密度高<br>Ⅲ.如需要频繁插入和删除元素，最好采用顺序存储结构<br>Ⅳ.如需要频繁插入和删除元素，最好采用链式存储结构<br>A.Ⅰ、Ⅱ、Ⅲ<br>B.Ⅱ、Ⅳ<br>C.Ⅱ、Ⅲ<br>D.Ⅲ、Ⅳ<br><strong>正确答案：B</strong><br>解析： B、线性表的顺序存储结构和链式存储结构各有优缺点，不能简单比较好坏，所以Ⅰ错误。链式存储结构使用指针表示逻辑关系，所以存储密度比较低，所以Ⅱ正确。如频繁使用插入和删除操作，链式存储结构更优于顺序存储结构，所以Ⅲ错误，Ⅳ正确。</p><h2 id="7、在单链表中，增加一个头节点的目的是为了（-）。"><a href="#7、在单链表中，增加一个头节点的目的是为了（-）。" class="headerlink" title="7、在单链表中，增加一个头节点的目的是为了（ ）。"></a>7、在单链表中，增加一个头节点的目的是为了（ ）。</h2><p>A.使单链表至少有一个节点<br>B.标识链表中某个重要节点的位置<br>C.方便插入和删除运算的实现<br>D.表示单链表是线性表的链式存储结构<br><strong>正确答案：C</strong><br>解析： C、在单链表中增加一个头节点的主要目的是使删除和插入节点操作更简单，方便运算的实现。</p><h2 id="8、通过含有n（n≥1）个元素的数组a，采用头插法建立一个单链表L，则L中节点值的次序（-）。"><a href="#8、通过含有n（n≥1）个元素的数组a，采用头插法建立一个单链表L，则L中节点值的次序（-）。" class="headerlink" title="8、通过含有n（n≥1）个元素的数组a，采用头插法建立一个单链表L，则L中节点值的次序（ ）。"></a>8、通过含有n（n≥1）个元素的数组a，采用头插法建立一个单链表L，则L中节点值的次序（ ）。</h2><p>A.与数组a的元素次序相同<br>B.与数组a的元素次序相反<br>C.与数组a的元素次序无关<br>D.以上都不对<br><strong>正确答案：B</strong><br>解析： B、采用头插法建立单链表时，后面的节点插入到最前端，所以L的节点值次序与数组a的元素次序相反。</p><h2 id="9、某算法在含有n（n≥1）个节点的单链表中查找值为x节点，其时间复杂度是（-）。"><a href="#9、某算法在含有n（n≥1）个节点的单链表中查找值为x节点，其时间复杂度是（-）。" class="headerlink" title="9、某算法在含有n（n≥1）个节点的单链表中查找值为x节点，其时间复杂度是（ ）。"></a>9、某算法在含有n（n≥1）个节点的单链表中查找值为x节点，其时间复杂度是（ ）。</h2><p>A.O(log2n)<br>B.O(1)<br>C.O(n2)<br>D.O(n)<br><strong>正确答案：D</strong><br>解析： D、需要从首节点出发逐一查找每个节点。</p><p><strong>课本考据：按元素值查找的算法在单链表L中从头开始找第一个值域与e相等的结点，若存在这样的结点，则返回逻辑序号，否则返回0；</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">LocateElem</span><span class="hljs-params">(LinkNode * ElemType)</span><br>&#123;<br><span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;<br>LinkNode * p=L-&gt;next;<br><span class="hljs-keyword">while</span>(p != UNLL &amp;&amp; p-&gt;data != e)<br>&#123;<br>p=p-&gt;next;<br>i++;<br>&#125;<br><span class="hljs-keyword">if</span>(p==<span class="hljs-literal">NULL</span>)<br><span class="hljs-keyword">return</span>(<span class="hljs-number">0</span>);<br><span class="hljs-keyword">else</span><br><span class="hljs-keyword">return</span>(i);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="10、在长度为n（n≥1）的单链表中删除尾节点的时间复杂度为（-）。"><a href="#10、在长度为n（n≥1）的单链表中删除尾节点的时间复杂度为（-）。" class="headerlink" title="10、在长度为n（n≥1）的单链表中删除尾节点的时间复杂度为（ ）。"></a>10、在长度为n（n≥1）的单链表中删除尾节点的时间复杂度为（ ）。</h2><p>A.O(1)<br>B.O(log2n)<br>C.O(n)<br>D.O(n2)<br><strong>正确答案：C</strong><br>解析： C、在长度为n（n≥1）的单链表中删除尾节点时，需要找倒数第2个节点，此时时间复杂度为O(n)。</p><p><strong>课本考据L：删除数据元素的实现过程是先在单链表L中找到第i-1个结点，由p指向它。若存在这样的结点，且也存在后继结点（也由p指向它），则删除q所指的结点，返回true；否则返回false，表示参数i错误。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">bool</span> <span class="hljs-title function_">ListDelete</span><span class="hljs-params">(LinkNode *&amp; L,<span class="hljs-type">int</span> i,ElemType &amp; e)</span><br>&#123;<br><span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;<br>LinkNode * p=L,*q;<br><span class="hljs-keyword">if</span>(i&lt;=<span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">while</span>(j&lt;i<span class="hljs-number">-1</span> &amp;&amp; p != <span class="hljs-literal">NULL</span>)<br>&#123;<br>j++;<br>p=p-&gt;next;<br>&#125;<br><span class="hljs-keyword">if</span>(p==<span class="hljs-literal">NULL</span>)<br>ruturn <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">else</span><br>&#123;<br>q=p-&gt;next;<br><span class="hljs-keyword">if</span>(q==<span class="hljs-literal">NULL</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>e=q-&gt;data;<br>p-&gt;next=q-&gt;next;<br><span class="hljs-built_in">free</span>(q);<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="11、关于线性表的正确说法是（-）。"><a href="#11、关于线性表的正确说法是（-）。" class="headerlink" title="11、关于线性表的正确说法是（ ）。"></a>11、关于线性表的正确说法是（ ）。</h2><p>A.每个元素都有一个前驱和一个后继元素<br>B.线性表中至少有一个元素<br>C.表中元素的排序顺序必须是由小到大或由大到小<br>D.除第一个元素和最后一个元素外，其余每个元素有且仅有一个前驱和一个后继元素<br><strong>正确答案：D</strong><br>解析： D、线性表属典型的线性结构。</p><h2 id="12、以下关于顺序表的叙述中，正确的是（-）。"><a href="#12、以下关于顺序表的叙述中，正确的是（-）。" class="headerlink" title="12、以下关于顺序表的叙述中，正确的是（ ）。"></a>12、以下关于顺序表的叙述中，正确的是（ ）。</h2><p>A.顺序表可以利用一维数组表示，因此顺序表与一维数组在结构上是一致的，它们可以通用<br>B.在顺序表中，逻辑上相邻的元素在物理位置上不一定相邻<br>C.顺序表和一维数组一样，都可以进行随机存取<br>D.在顺序表中每一个元素的类型不必相同<br><strong>正确答案：C</strong><br>解析： C、顺序表中所有元素必须连续存放，而一维数组中所有元素可以不连续存放，另外，一维数组只有按下标的存、取两个操作，而顺序表可以进行线性表的插入、删除等操作，所以选项A错误。在顺序表中，逻辑上相邻的元素在物理位置上也一定相邻，所以选项B错误。顺序表中每一个元素的类型必须相同，所以选项D错误。</p><h2 id="13、以下属于顺序表的优点是（-）。"><a href="#13、以下属于顺序表的优点是（-）。" class="headerlink" title="13、以下属于顺序表的优点是（ ）。"></a>13、以下属于顺序表的优点是（ ）。</h2><p>A.插入元素方便<br>B.删除元素方便<br>C.存储密度大<br>D.以上都不对<br><strong>正确答案：C</strong><br>解析： C、顺序表的存储密度为1，所以其存储密度大。</p><h2 id="14、设线性表中有n个元素，以下运算中，（-）在单链表上实现要比在顺序表上实现效率更高。"><a href="#14、设线性表中有n个元素，以下运算中，（-）在单链表上实现要比在顺序表上实现效率更高。" class="headerlink" title="14、设线性表中有n个元素，以下运算中，（ ）在单链表上实现要比在顺序表上实现效率更高。"></a>14、设线性表中有n个元素，以下运算中，（ ）在单链表上实现要比在顺序表上实现效率更高。</h2><p>A.删除指定位置元素的后一个元素<br>B.在尾元素的后面插入一个新元素<br>C.顺序输出前k个元素<br>D.交换第i个元素和第n-i+1个元素的值（i&#x3D;1，2，…，n）<br><strong>正确答案：A</strong><br>解析： A、在顺序表中插入元素和删除元素时需要移动较多元素，而在单链表上执行同样的操作不需要移动元素，只需修改相关节点的指针域。</p><h2 id="15、以下关于单链表的叙述中正确的是（-）。"><a href="#15、以下关于单链表的叙述中正确的是（-）。" class="headerlink" title="15、以下关于单链表的叙述中正确的是（ ）。"></a>15、以下关于单链表的叙述中正确的是（ ）。</h2><p>Ⅰ.节点除自身信息外还包括指针域，存储密度小于顺序表<br>Ⅱ.找第i个节点的时间为O(1)<br>Ⅲ.在插入、删除运算时不必移动节点<br>A.仅Ⅰ、Ⅱ<br>B.仅Ⅱ、Ⅲ<br>C.仅Ⅰ、Ⅲ<br>D.Ⅰ、Ⅱ、Ⅲ<br><strong>正确答案：C</strong><br>解析： C、单链表不具有随机存取特性，即不能在O(1)的时间内找到第i个节点。</p><p><strong>课本考据：在链表中，逻辑上相邻的元素对应的存储位置是通过指针来连接的，因而每个结点的存储位置可以任意安排，不必要求相邻，所以当进行插入或删除操作时只需要修改相关结点的指针域即可。（方便省时）</strong></p><hr><h1 id="第三周测验"><a href="#第三周测验" class="headerlink" title="第三周测验"></a>第三周测验</h1><h2 id="1、与单链表相比，双链表的优点之一是（-）。"><a href="#1、与单链表相比，双链表的优点之一是（-）。" class="headerlink" title="1、与单链表相比，双链表的优点之一是（ ）。"></a>1、与<a href="https://so.csdn.net/so/search?q=%E5%8D%95%E9%93%BE%E8%A1%A8&spm=1001.2101.3001.7020">单链表</a>相比，双链表的优点之一是（ ）。</h2><p>A.插入、删除操作更简单<br>B.可以进行随机访问<br>C.可以省略表头指针或表尾指针<br>D.访问前后相邻节点更方便<br><strong>正确答案：D</strong><br>解析： D、在双链表中可以访问任一节点的前后相邻节点，而单链表中只能访问任一节点的下一个节点。</p><p>课本考据：由于双链表的每个结点既包含一个指向后继结点的指针，又包含一个指向前驱结点的指针，所以当访问过一个结点后既可以依次向后访问每一个结点，也可以依次向前访问每一个结点。<strong>（双链表中每个结点有指向前后结点的指针即可访问前后结点）</strong></p><h2 id="2、带头节点的双链表L为空表时应满足（-）。"><a href="#2、带头节点的双链表L为空表时应满足（-）。" class="headerlink" title="2、带头节点的双链表L为空表时应满足（ ）。"></a>2、带头节点的双链表L为空表时应满足（ ）。</h2><p>A.L &#x3D;&#x3D; NULL<br>B.L-&gt;prior &#x3D;&#x3D; L-&gt;next<br>C.L-&gt;prior &#x3D;&#x3D; NULL<br>D.L-&gt;nex t &#x3D;&#x3D; NULL<br><strong>正确答案：D</strong></p><p><strong>课本考据：除了插入和删除结点，双链表其他运算的算法与单链表中相应的算法相同。</strong></p><h2 id="3、在长度为n（n≥1）的双链表中插入一个节点（非尾节点）要修改（-）个指针域。"><a href="#3、在长度为n（n≥1）的双链表中插入一个节点（非尾节点）要修改（-）个指针域。" class="headerlink" title="3、在长度为n（n≥1）的双链表中插入一个节点（非尾节点）要修改（ ）个指针域。"></a>3、在长度为n（n≥1）的双链表中插入一个节点（非尾节点）要修改（ ）个指针域。</h2><p>A.1<br>B.2<br>C.3<br>D.4<br><strong>正确答案：D</strong><br>解析： D、需要修改插入节点的prior、next域，前驱节点的next域和后继节点的prior域。</p><p><strong>课本考据：原理参考第二题，如图<img src="/../imgs/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%88%B7%E9%A2%98/20201110165354598.png" alt="在这里插入图片描述"></strong><br><strong>操作语句如下：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">s-&gt;next=p-&gt;next;<br>p-&gt;next-&gt;prior=s;<br>s-&gt;prior=p;<br>p-&gt;next=s;<br><span class="hljs-number">1234</span><br></code></pre></td></tr></table></figure><h2 id="4、对于长度为n（n≥1）的双链表L，在p所指节点之前插入一个新节点的算法的时间复杂度为（-）。"><a href="#4、对于长度为n（n≥1）的双链表L，在p所指节点之前插入一个新节点的算法的时间复杂度为（-）。" class="headerlink" title="4、对于长度为n（n≥1）的双链表L，在p所指节点之前插入一个新节点的算法的时间复杂度为（ ）。"></a>4、对于长度为n（n≥1）的双链表L，在p所指节点之前插入一个新节点的算法的时间复杂度为（ ）。</h2><p>A.O(1)<br>B.O(n)<br>C.O(n2)<br>D.O(nlog2n)<br><strong>正确答案：A</strong><br>解析： A、设新节点指针为q，操作是：p-&gt;prior-&gt;next&#x3D;p; q-&gt;prior&#x3D;p-&gt;prior; p-&gt;prior&#x3D;q; q-&gt;next&#x3D;p;</p><h2 id="5、在长度为n（n≥1）的双链表中删除一个节点（非尾节点）要修改（-）个指针域。"><a href="#5、在长度为n（n≥1）的双链表中删除一个节点（非尾节点）要修改（-）个指针域。" class="headerlink" title="5、在长度为n（n≥1）的双链表中删除一个节点（非尾节点）要修改（ ）个指针域。"></a>5、在长度为n（n≥1）的双链表中删除一个节点（非尾节点）要修改（ ）个指针域。</h2><p>A.1<br>B.2<br>C.3<br>D.4<br><strong>正确答案：B</strong><br>解析： B、需要修改前驱节点的next域和后继节点的prior域。</p><h2 id="6、与非循环单链表相比，循环单链表的主要优点是（-）。"><a href="#6、与非循环单链表相比，循环单链表的主要优点是（-）。" class="headerlink" title="6、与非循环单链表相比，循环单链表的主要优点是（ ）。"></a>6、与非循环单链表相比，循环单链表的主要优点是（ ）。</h2><p>A.不再需要头指针<br>B.已知某个节点的位置后，能够容易找到它的前驱节点<br>C.在进行插入、删除操作时，能更好地保证链表不断开<br>D.从表中任意节点出发都能扫描到整个链表<br><strong>正确答案：D</strong><br>解析： D、循环单链表中可以循环扫描，因此从表中任意节点出发都能扫描到整个链表。</p><h2 id="7、设有带头节点的循环单链表L，当这种链表成为空链表时，有（-）。"><a href="#7、设有带头节点的循环单链表L，当这种链表成为空链表时，有（-）。" class="headerlink" title="7、设有带头节点的循环单链表L，当这种链表成为空链表时，有（ ）。"></a>7、设有带头节点的循环单链表L，当这种链表成为空链表时，有（ ）。</h2><p>A.表头节点指针域next为空<br>B.L的值为NULL<br>C.表头节点的指针域next与L的值相等<br>D.表头节点的指针域next与L的地址相等<br><strong>正确答案：C</strong><br>解析： C、带头节点的循环单链表L成为空链表时满足L-&gt;next&#x3D;&#x3D;L，即表头节点<em>L的指针域next与L的值相等，而不是表头节点</em>L的指针域next与L的地址相等。</p><h2 id="8、在长度为n（n≥1）的循环双链表L中，删除尾节点的时间复杂度为（-）。"><a href="#8、在长度为n（n≥1）的循环双链表L中，删除尾节点的时间复杂度为（-）。" class="headerlink" title="8、在长度为n（n≥1）的循环双链表L中，删除尾节点的时间复杂度为（ ）。"></a>8、在长度为n（n≥1）的循环双链表L中，删除尾节点的时间复杂度为（ ）。</h2><p>A.O(1)<br>B.O(n)<br>C.O(n2)<br>D.O(nlog2n)<br><strong>正确答案：A</strong><br>解析： A、通过头节点指针直接找到尾节点，然后再删除该尾节点，对应的时间复杂度为O(1)。</p><h2 id="9、将两个分别含有m、n个节点的有序单链表归并成一个有序单链表，要求不破坏原有的单链表，对应算法的空间复杂度是（-）（MIN表示取最小值）。"><a href="#9、将两个分别含有m、n个节点的有序单链表归并成一个有序单链表，要求不破坏原有的单链表，对应算法的空间复杂度是（-）（MIN表示取最小值）。" class="headerlink" title="9、将两个分别含有m、n个节点的有序单链表归并成一个有序单链表，要求不破坏原有的单链表，对应算法的空间复杂度是（ ）（MIN表示取最小值）。"></a>9、将两个分别含有m、n个节点的有序单链表归并成一个有序单链表，要求不破坏原有的单链表，对应算法的空间复杂度是（ ）（MIN表示取最小值）。</h2><p>A.O(n)<br>B.O(m)<br>C.O(m+n)<br>D.O(MIN(m,n))<br><strong>正确答案：C</strong><br>解析： C、将两个有序单链表A、B归并到C中时，通过比较A、B中的节点，将比较小的节点复制到C中，复制次数为m+n，即新建m+n个节点，对应的空间复杂度为O(m+n)。</p><h2 id="10、已知两个长度分别为m-和n-的升序单链表，若将它们合并为一个长度为m-n-的降序单链表，则时间复杂度是（-）。"><a href="#10、已知两个长度分别为m-和n-的升序单链表，若将它们合并为一个长度为m-n-的降序单链表，则时间复杂度是（-）。" class="headerlink" title="10、已知两个长度分别为m 和n 的升序单链表，若将它们合并为一个长度为m+n 的降序单链表，则时间复杂度是（ ）。"></a>10、已知两个长度分别为m 和n 的升序单链表，若将它们合并为一个长度为m+n 的降序单链表，则时间复杂度是（ ）。</h2><p>A.O(n)<br>B.O(m×n)<br>C.O(m)<br>D.O(m+n)<br><strong>正确答案：D</strong></p><h2 id="11、在长度为n（n≥1）的双链表L中，删除p所指节点的时间复杂度为（-）。"><a href="#11、在长度为n（n≥1）的双链表L中，删除p所指节点的时间复杂度为（-）。" class="headerlink" title="11、在长度为n（n≥1）的双链表L中，删除p所指节点的时间复杂度为（ ）。"></a>11、在长度为n（n≥1）的双链表L中，删除p所指节点的时间复杂度为（ ）。</h2><p>A.O(1)<br>B.O(n)<br>C.O(n2)<br>D.O(nlog2n)<br><strong>正确答案：A</strong><br>解析： A、在双链表中，通过p所指节点可以找到前后节点，通过其前后节点来删除p所指节点，对应的时间复杂度为O(1)。</p><h2 id="12、在长度为n（n≥1）的循环单链表L中，删除尾节点的时间复杂度为（-）。"><a href="#12、在长度为n（n≥1）的循环单链表L中，删除尾节点的时间复杂度为（-）。" class="headerlink" title="12、在长度为n（n≥1）的循环单链表L中，删除尾节点的时间复杂度为（ ）。"></a>12、在长度为n（n≥1）的循环单链表L中，删除尾节点的时间复杂度为（ ）。</h2><p>A.O(1)<br>B.O(n)<br>C.O(n2)<br>D.O(nlog2n)<br><strong>正确答案：B</strong><br>解析： B、通过L查找到尾节点的前驱节点，然后删除尾节点，对应的时间复杂度为O(n)。</p><h2 id="13、在只有尾节点指针rear没有头节点的非空循环单链表中，删除尾节点的时间复杂度为（-）。"><a href="#13、在只有尾节点指针rear没有头节点的非空循环单链表中，删除尾节点的时间复杂度为（-）。" class="headerlink" title="13、在只有尾节点指针rear没有头节点的非空循环单链表中，删除尾节点的时间复杂度为（ ）。"></a>13、在只有尾节点指针rear没有头节点的非空循环单链表中，删除尾节点的时间复杂度为（ ）。</h2><p>A.O(1)<br>B.O(n)<br>C.O(n2)<br>D.O(nlog2n)<br><strong>正确答案：B</strong><br>解析： B、通过rear查找到尾节点的前驱节点，然后删除尾节点，对应的时间复杂度为O(n)。</p><h2 id="14、在只有尾节点指针rear没有头节点的非空循环单链表中，删除开始节点的时间复杂度为（-）。"><a href="#14、在只有尾节点指针rear没有头节点的非空循环单链表中，删除开始节点的时间复杂度为（-）。" class="headerlink" title="14、在只有尾节点指针rear没有头节点的非空循环单链表中，删除开始节点的时间复杂度为（ ）。"></a>14、在只有尾节点指针rear没有头节点的非空循环单链表中，删除开始节点的时间复杂度为（ ）。</h2><p>A.O(1)<br>B.O(n)<br>C.O(n2)<br>D.O(nlog2n)<br><strong>正确答案：A</strong><br>解析： A、通过rear指针直接删除开始节点。</p><h2 id="15、两个长度为n的双链表，节点类型相同，若以h1为头指针的双链表是非循环的，以h2为头指针指针的双链表是循环的，则（-）。"><a href="#15、两个长度为n的双链表，节点类型相同，若以h1为头指针的双链表是非循环的，以h2为头指针指针的双链表是循环的，则（-）。" class="headerlink" title="15、两个长度为n的双链表，节点类型相同，若以h1为头指针的双链表是非循环的，以h2为头指针指针的双链表是循环的，则（ ）。"></a>15、两个长度为n的双链表，节点类型相同，若以h1为头指针的双链表是非循环的，以h2为头指针指针的双链表是循环的，则（ ）。</h2><p>A.对于非循环双链表来说，删除首节点的操作，其时间复杂度都是O(n)<br>B.对于循环双链表来说，删除首节点的操作，其时间复杂度都是O(n)<br>C.对于非循环双链表来说，删除尾节点的操作，其时间复杂度都是O(1)<br>D.对于循环双链表来说，删除尾节点的操作，其时间复杂度都是O(1)<br><strong>正确答案：D</strong><br>解析： D、对于这两个双链表来说，删除首节点的操作的时间复杂度都是O(1)。对于非循环双链表来说，删除尾节点的操作的时间复杂度都是O(n)，对于循环双链表来说，删除尾节点的操作的时间复杂度都是O(1)。</p><hr><h1 id="第四周测验"><a href="#第四周测验" class="headerlink" title="第四周测验"></a>第四周测验</h1><h2 id="1、栈的“先进后出”特性是指（-）。"><a href="#1、栈的“先进后出”特性是指（-）。" class="headerlink" title="1、栈的“先进后出”特性是指（ ）。"></a>1、栈的“先进后出”特性是指（ ）。</h2><p>A.最后进栈的元素总是最先出栈<br>B.同时进行进栈和出栈操作时，总是进栈优先<br>C.每当有出栈操作时，总要先进行一次进栈操作<br>D.每次出栈的元素总是最先进栈的元素<br><strong>正确答案：A</strong></p><p><strong>课本考据：栈是一种只能在一端进行插入或删除操作的线性表。</strong></p><h2 id="2、给定一个足够大的空栈，有4个元素的进栈次序为A、B、C、D，则以C、D开头的出栈序列的个数为（-）。"><a href="#2、给定一个足够大的空栈，有4个元素的进栈次序为A、B、C、D，则以C、D开头的出栈序列的个数为（-）。" class="headerlink" title="2、给定一个足够大的空栈，有4个元素的进栈次序为A、B、C、D，则以C、D开头的出栈序列的个数为（ ）。"></a>2、给定一个足够大的空栈，有4个元素的进栈次序为A、B、C、D，则以C、D开头的出栈序列的个数为（ ）。</h2><p>A.1<br>B.2<br>C.3<br>D.4<br><strong>正确答案：A</strong><br>解析： A、若出栈序列为CD…，则A、B、C进栈，C出栈，D进栈，D出栈，此后只有B出栈和A出栈一种情况，所以这样的出栈序列只有CDBA一个。</p><h2 id="3、若元素a、b、c、d、e、f依次进栈，允许进栈、退栈的操作交替进行，但不允许连续3次退栈工作，则不可能得到的出栈序列是（-）。"><a href="#3、若元素a、b、c、d、e、f依次进栈，允许进栈、退栈的操作交替进行，但不允许连续3次退栈工作，则不可能得到的出栈序列是（-）。" class="headerlink" title="3、若元素a、b、c、d、e、f依次进栈，允许进栈、退栈的操作交替进行，但不允许连续3次退栈工作，则不可能得到的出栈序列是（ ）。"></a>3、若元素a、b、c、d、e、f依次进栈，允许进栈、退栈的操作交替进行，但不允许连续3次退栈工作，则不可能得到的出栈序列是（ ）。</h2><p>A.dcebfa<br>B.cbdaef<br>C.bcaefd<br>D.afedcb<br><strong>正确答案：D</strong><br>解析：<br>选项A操作：a进，b进，c进，d进，d出，c出，e进，e出，b出，f进，f出，a出。<br>选项B操作：a进，b进，c进，c出，b出，d进，d出，a出，e进，e出，f进，f出。<br>选项C操作：a进，b进，b出，c进，c出，a出，d进，e进，e出，f进，f出，d出。<br>选项D操作：a进，a出，b进，c进，d进，e进，f进，f出，e出，d出，c出，b出。<br>从中看到，选项D中最后连续出栈5次，不符合要求。</p><h2 id="4、一个栈的进栈序列是a、b、c、d、e，则栈的不可能的输出序列是（-）。"><a href="#4、一个栈的进栈序列是a、b、c、d、e，则栈的不可能的输出序列是（-）。" class="headerlink" title="4、一个栈的进栈序列是a、b、c、d、e，则栈的不可能的输出序列是（ ）。"></a>4、一个栈的进栈序列是a、b、c、d、e，则栈的不可能的输出序列是（ ）。</h2><p>A.edcba<br>B.decba<br>C.dceab<br>D.abcde<br><strong>正确答案：C</strong><br>解析：<br>对于选项A，a、b、c、d、e进栈，e、d、c、b、a出栈；<br>对于选项B，a，b，c，d进栈，d出栈，e进栈，e出栈，c、b、a依次出栈；<br>对于选项C，a、b、c、d进栈，d出栈，c出栈，e进栈，e出栈，此时栈中从栈底到栈顶为a、b，不可能a先出栈，所以C是不可能的输出序列；<br>对于选项D，a进栈，a出栈，b进栈，b出栈，c进栈，c出栈，d进栈，d出栈，e进栈，e出栈。</p><h2 id="5、当用一个数组data-0…n-1-存放栈中元素时，栈底最好（-）。"><a href="#5、当用一个数组data-0…n-1-存放栈中元素时，栈底最好（-）。" class="headerlink" title="5、当用一个数组data[0…n-1]存放栈中元素时，栈底最好（ ）。"></a>5、当用一个数组data[0…n-1]存放栈中元素时，栈底最好（ ）。</h2><p>A.设置在data[0]处<br>B.设置在data[n-1]处<br>C.设置在data[0]或data[n-1]处<br>D.设置在data数组的任何位置<br><strong>正确答案：C</strong><br>解析： C、栈中元素的逻辑关系呈现线性关系，这样有两个端点，最好将栈底设置在某个端点data[0]或data[n-1]处，从而方便栈运算算法的设计。</p><p><strong>（因为栈是一种只能在一端进行插入或删除操作的线性表）</strong></p><h2 id="6、若一个栈用数组data-1…n-存储，初始栈顶指针top为n-1，则以下元素x进栈的正确操作是（-）。"><a href="#6、若一个栈用数组data-1…n-存储，初始栈顶指针top为n-1，则以下元素x进栈的正确操作是（-）。" class="headerlink" title="6、若一个栈用数组data[1…n]存储，初始栈顶指针top为n+1，则以下元素x进栈的正确操作是（ ）。"></a>6、若一个栈用数组data[1…n]存储，初始栈顶指针top为n+1，则以下元素x进栈的正确操作是（ ）。</h2><p>A.top++; data[top]&#x3D;x;<br>B.data[top]&#x3D;x; top++;<br>C.top–; data[top]&#x3D;x;<br>D.data[top]&#x3D;x; top–;<br><strong>正确答案：C</strong></p><p><strong>初始栈顶指针top为n+1，说明data[1]端作为栈顶，且元素x的进栈操作为先将栈顶指针top减1，然后将元素x放在栈顶指针处。</strong></p><h2 id="7、若一个栈用数组data-1…n-存储，初始栈顶指针top为0，则以下元素x进栈的正确操作是（-）。"><a href="#7、若一个栈用数组data-1…n-存储，初始栈顶指针top为0，则以下元素x进栈的正确操作是（-）。" class="headerlink" title="7、若一个栈用数组data[1…n]存储，初始栈顶指针top为0，则以下元素x进栈的正确操作是（ ）。"></a>7、若一个栈用数组data[1…n]存储，初始栈顶指针top为0，则以下元素x进栈的正确操作是（ ）。</h2><p>A.top++; data[top]&#x3D;x;<br>B.data[top]&#x3D;x; top++;<br>C.top–; data[top]&#x3D;x;<br>D.data[top]&#x3D;x; top–;<br><strong>正确答案：A</strong><br>解析： A、<strong>初始栈顶指针top为0，说明data[1]端作为栈底，在进栈时top应递增，由于不存在data[0]的元素，所以在进栈时应先将top递增，再将x放在top处</strong></p><h2 id="8、在设计链栈时，通常采用单链表作为链栈，而不采用双链表作为链栈，其准确的原因是（-）。"><a href="#8、在设计链栈时，通常采用单链表作为链栈，而不采用双链表作为链栈，其准确的原因是（-）。" class="headerlink" title="8、在设计链栈时，通常采用单链表作为链栈，而不采用双链表作为链栈，其准确的原因是（ ）。"></a>8、在设计链栈时，通常采用单链表作为链栈，而不采用双链表作为链栈，其准确的原因是（ ）。</h2><p>A.栈中元素是顺序存取的，用单链表就足够了<br>B.栈中元素是随机存取的，用单链表就足够了<br>C.双链表运算较单链表更复杂<br>D.双链表存储密度较单链表低<br><strong>正确答案：A</strong><br>解析： A、因为栈中元素是顺序存取的（指逐个存或取结构中的元素），而不是随机存取的，用单链表就足够了。</p><h2 id="9、栈和队列的不同点是（-）。"><a href="#9、栈和队列的不同点是（-）。" class="headerlink" title="9、栈和队列的不同点是（ ）。"></a>9、栈和队列的不同点是（ ）。</h2><p>A.都是线性表<br>B.都不是线性表<br>C.栈只能在同一端进行插入删除操作，而队列在不同端进行插入删除操作<br>D.没有不同点<br><strong>正确答案：C</strong><br>解析： C、栈和队列的不同点是，栈在同一端进行插入和删除操作，而队列在不同端进行插入和删除操作。</p><h2 id="10、设循环队列qu中数组data的下标是0～N-1，其队头、队尾指针分别为f和r（f指向队首元素的前一位置，r指向队尾元素），元素x进队的操作是（）-qu-data-qu-rear-x3D-x。"><a href="#10、设循环队列qu中数组data的下标是0～N-1，其队头、队尾指针分别为f和r（f指向队首元素的前一位置，r指向队尾元素），元素x进队的操作是（）-qu-data-qu-rear-x3D-x。" class="headerlink" title="10、设循环队列qu中数组data的下标是0～N-1，其队头、队尾指针分别为f和r（f指向队首元素的前一位置，r指向队尾元素），元素x进队的操作是（）;qu.data[qu.rear]&#x3D;x。"></a>10、设<a href="https://so.csdn.net/so/search?q=%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97&spm=1001.2101.3001.7020">循环队列</a>qu中数组data的下标是0～N-1，其队头、队尾指针分别为f和r（f指向队首元素的前一位置，r指向队尾元素），元素x进队的操作是（）;qu.data[qu.rear]&#x3D;x。</h2><p>A.qu.rear++<br>B.qu.rear&#x3D;(qu.rear+1)%N<br>C.qu.front++;<br>D.qu.front&#x3D;(qu.front+1)%N<br><strong>正确答案：B</strong><br>解析： B、对于循环队列，进队操作仅移动队尾指针，元素x进队的操作是<br>qu.rear&#x3D;(qu.rear+1)%N;<br>qu.data[qu.rear]&#x3D;x。</p><p><strong>课本考据：<br>在队列不满的条件下先将队尾指针rear循环增1，然后将元素插入到该位置。算法如下</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">bool</span> <span class="hljs-title function_">enQueue</span><span class="hljs-params">(SqQueue *&amp;q,ElemType e)</span><br>&#123;<br><span class="hljs-keyword">if</span> ((q-&gt;rear+<span class="hljs-number">1</span>)%Maxsize==q-&gt;front)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>q-&gt;rear=(q-&gt;rear+<span class="hljs-number">1</span>)%MaxSize;<br>q-&gt;data[q-&gt;rear]=e;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-number">12345678</span><br></code></pre></td></tr></table></figure><h2 id="11、设循环队列qu中数组data的下标是0～N-1，其队头、队尾指针分别为f和r（f指向队首元素的前一位置，r指向队尾元素），元素x出队的操作是（-）-x-x3D-qu-data-qu-front-。"><a href="#11、设循环队列qu中数组data的下标是0～N-1，其队头、队尾指针分别为f和r（f指向队首元素的前一位置，r指向队尾元素），元素x出队的操作是（-）-x-x3D-qu-data-qu-front-。" class="headerlink" title="11、设循环队列qu中数组data的下标是0～N-1，其队头、队尾指针分别为f和r（f指向队首元素的前一位置，r指向队尾元素），元素x出队的操作是（ ）;x&#x3D;qu.data[qu.front]。"></a>11、设循环队列qu中数组data的下标是0～N-1，其队头、队尾指针分别为f和r（f指向队首元素的前一位置，r指向队尾元素），元素x出队的操作是（ ）;x&#x3D;qu.data[qu.front]。</h2><p>A.qu.rear++<br>B.qu.rear&#x3D;(qu.rear+1)%N<br>C.qu.front++;<br>D.qu.front&#x3D;(qu.front+1)%N<br><strong>正确答案：D</strong><br>解析： D、对于循环队列，出队操作仅移动队头指针，元素x出队的操作是：qu.front&#x3D;(qu.front+1)%N;<br>x&#x3D;qu.data[qu.rear]。</p><p>课本考据：在队列q不空的条件下将队首指针front循环增1，取出该位置的元素并赋值给e。算法如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">bool</span> <span class="hljs-title function_">deQueue</span><span class="hljs-params">(SqQueue *&amp;q,ElemType e)</span><br>&#123;<br><span class="hljs-keyword">if</span> (q-&gt;front==q-&gt;rear)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>q-&gt;front=(q-&gt;front+<span class="hljs-number">1</span>)%MaxSize;<br>e=q-&gt;dara[q-&gt;front];<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-number">12345678</span><br></code></pre></td></tr></table></figure><h2 id="12、若某循环队列有队首指针front和队尾指针rear，在队不空时出队操作仅会改变（-）。"><a href="#12、若某循环队列有队首指针front和队尾指针rear，在队不空时出队操作仅会改变（-）。" class="headerlink" title="12、若某循环队列有队首指针front和队尾指针rear，在队不空时出队操作仅会改变（ ）。"></a>12、若某循环队列有队首指针front和队尾指针rear，在队不空时出队操作仅会改变（ ）。</h2><p>A.front<br>B.rear<br>C.front和rear<br>D.以上都不对<br><strong>正确答案：A</strong><br>解析： A、<strong>当循环队列不空时，出队操作只能改变队头指针front。</strong></p><h2 id="13、通常设置循环队列qu的队空条件（front队首指针指向队首元素的前一位置，rear队尾指针指向队尾元素）是（-）。"><a href="#13、通常设置循环队列qu的队空条件（front队首指针指向队首元素的前一位置，rear队尾指针指向队尾元素）是（-）。" class="headerlink" title="13、通常设置循环队列qu的队空条件（front队首指针指向队首元素的前一位置，rear队尾指针指向队尾元素）是（ ）。"></a>13、通常设置循环队列qu的队空条件（front队首指针指向队首元素的前一位置，rear队尾指针指向队尾元素）是（ ）。</h2><p>A.(qu.rear+1)%MaxSize &#x3D;&#x3D; (qu.front+1)%MaxSize<br>B.(qu.rear+1)%MaxSize &#x3D;&#x3D; qu.front+1<br>C.(qu.rear+1)%MaxSize &#x3D;&#x3D; qu.front<br>D.qu.rea r &#x3D;&#x3D; qu.front<br><strong>正确答案：D</strong><br>解析： D、在循环队列中，通常设置队头等于队尾时表示队空。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">bool</span> <span class="hljs-title function_">QueueEmpty</span><span class="hljs-params">(SqQueue * q)</span><br>&#123;<br><span class="hljs-keyword">return</span>(q-&gt;front==q-&gt;rear);<br>&#125;<br><span class="hljs-number">1234</span><br></code></pre></td></tr></table></figure><h2 id="14、设循环队列的存储空间为a-0…20-，且当前队头指针（f指向队首元素的前一位置）和队尾指针（r指向队尾元素）的值分别为8和3，则该队列中元素个数为（-）。"><a href="#14、设循环队列的存储空间为a-0…20-，且当前队头指针（f指向队首元素的前一位置）和队尾指针（r指向队尾元素）的值分别为8和3，则该队列中元素个数为（-）。" class="headerlink" title="14、设循环队列的存储空间为a[0…20]，且当前队头指针（f指向队首元素的前一位置）和队尾指针（r指向队尾元素）的值分别为8和3，则该队列中元素个数为（ ）。"></a>14、设循环队列的存储空间为a[0…20]，且当前队头指针（f指向队首元素的前一位置）和队尾指针（r指向队尾元素）的值分别为8和3，则该队列中元素个数为（ ）。</h2><p>A.5<br>B.6<br>C.16<br>D.17<br><strong>正确答案：C</strong><br>解析： C、<strong>这里MaxSize&#x3D;21，其中的元素个数&#x3D;<br>(r-f+MaxSize)%MaxSize&#x3D;16。</strong></p><h2 id="15、假设用一个不带头节点的单链表表示队列，队头在链表的（-）位置。"><a href="#15、假设用一个不带头节点的单链表表示队列，队头在链表的（-）位置。" class="headerlink" title="15、假设用一个不带头节点的单链表表示队列，队头在链表的（ ）位置。"></a>15、假设用一个不带头节点的单链表表示队列，队头在链表的（ ）位置。</h2><p>A.链头<br>B.链尾<br>C.链中<br>D.以上都可以<br><strong>正确答案：A</strong><br>解析： A、在用单链表表示的链队中，以单链表的链头作为队头，以单链表的链尾作为队尾。</p><h2 id="16、与顺序队相比，链队（-）。"><a href="#16、与顺序队相比，链队（-）。" class="headerlink" title="16、与顺序队相比，链队（ ）。"></a>16、与顺序队相比，链队（ ）。</h2><p>A.优点是可以实现无限长队列<br>B.优点是进队和出队时间性能更好<br>C.缺点是不能进行顺序访问<br>D.缺点是不能根据队首和队尾指针计算队的长度<br><strong>正确答案：D</strong><br>解析： D、尽管链队总是采用动态分配方式，其长度也受内存大小的限制，也不可能实现无限长队列。顺序队和链队的进队和出队操作时间均为O(1)。顺序队和链队都可以进行顺序访问。在顺序队中可以通过队头和队尾指针计算队中元素个数，而链队不能。</p><h2 id="17、若用一个大小为6的数组来实现循环队列，且当前rear和front的值分别为0和3，当从队列中删除一个元素，再加入两个元素后，rear和front的值分别为（-）。"><a href="#17、若用一个大小为6的数组来实现循环队列，且当前rear和front的值分别为0和3，当从队列中删除一个元素，再加入两个元素后，rear和front的值分别为（-）。" class="headerlink" title="17、若用一个大小为6的数组来实现循环队列，且当前rear和front的值分别为0和3，当从队列中删除一个元素，再加入两个元素后，rear和front的值分别为（ ）。"></a>17、若用一个大小为6的数组来实现循环队列，且当前rear和front的值分别为0和3，当从队列中删除一个元素，再加入两个元素后，rear和front的值分别为（ ）。</h2><p>A.1和5<br>B.2和4<br>C.4和2<br>D.5和1<br><strong>正确答案：B</strong><br>解析： B、rear&#x3D;0，进队2个元素后，rear循环递增2，rear&#x3D;2；front&#x3D;3，出队一个元素后，front循环递增1，front&#x3D;4。</p><h2 id="18、一个循环队列中用data-0…n-1-数组保存队中元素，另设置一个队尾指针rear和一个记录队中实际元素个数的变量count，则该队中最多可以存放的元素个数是（-）。"><a href="#18、一个循环队列中用data-0…n-1-数组保存队中元素，另设置一个队尾指针rear和一个记录队中实际元素个数的变量count，则该队中最多可以存放的元素个数是（-）。" class="headerlink" title="18、一个循环队列中用data[0…n-1]数组保存队中元素，另设置一个队尾指针rear和一个记录队中实际元素个数的变量count，则该队中最多可以存放的元素个数是（ ）。"></a>18、一个循环队列中用data[0…n-1]数组保存队中元素，另设置一个队尾指针rear和一个记录队中实际元素个数的变量count，则该队中最多可以存放的元素个数是（ ）。</h2><p>A.n-1<br>B.n<br>C.(rear+n) % n<br>D.(n-rear) % n<br><strong>正确答案：B</strong><br>解析： B、队满的条件为count&#x3D;&#x3D;n。</p><h2 id="19、已知循环队列存储在一维数组A-0…n-1-中，且队列非空时front和rear分别指向队头元素和队尾元素。若初始时队列空，且要求第一个进入队列的元素存储在A-0-处，则初始时front和rear的值分别是（-）。"><a href="#19、已知循环队列存储在一维数组A-0…n-1-中，且队列非空时front和rear分别指向队头元素和队尾元素。若初始时队列空，且要求第一个进入队列的元素存储在A-0-处，则初始时front和rear的值分别是（-）。" class="headerlink" title="19、已知循环队列存储在一维数组A[0…n-1]中，且队列非空时front和rear分别指向队头元素和队尾元素。若初始时队列空，且要求第一个进入队列的元素存储在A[0]处，则初始时front和rear的值分别是（ ）。"></a>19、已知循环队列存储在一维数组A[0…n-1]中，且队列非空时front和rear分别指向队头元素和队尾元素。若初始时队列空，且要求第一个进入队列的元素存储在A[0]处，则初始时front和rear的值分别是（ ）。</h2><p>A.0，0<br>B.0，n-1<br>C.n-1，0<br>D. n-1，n-1<br><strong>正确答案：B</strong><br>解析： B、在循环队列中，进队操作是队尾指针rear循环加1，再在该处放置进队的元素，本题要求第一个进入队列的元素存储在A[0]处，则rear应为n-1，因为这样(rear+1)%n&#x3D;0。而队头指向队头元素，此时队头位置为0，所以front的初值为0。</p><h2 id="20、在循环队列中，元素的排列顺序（-）。"><a href="#20、在循环队列中，元素的排列顺序（-）。" class="headerlink" title="20、在循环队列中，元素的排列顺序（ ）。"></a>20、在循环队列中，元素的排列顺序（ ）。</h2><p>A.由元素进队的先后顺序确定<br>B.与元素值的大小有关<br>C.与队头和队尾指针的取值有关<br>D.与队中数组大小有关<br><strong>正确答案：A</strong><br>解析： A、在循环队列中，元素的排列顺序仅与元素进队的先后顺序有关。</p><hr><h1 id="第五周测验"><a href="#第五周测验" class="headerlink" title="第五周测验"></a>第五周测验</h1><h2 id="1、下面关于串的叙述中，正确的是（-）。"><a href="#1、下面关于串的叙述中，正确的是（-）。" class="headerlink" title="1、下面关于串的叙述中，正确的是（ ）。"></a>1、下面关于串的叙述中，正确的是（ ）。</h2><p>A.串是一种特殊的<a href="https://so.csdn.net/so/search?q=%E7%BA%BF%E6%80%A7%E8%A1%A8&spm=1001.2101.3001.7020">线性表</a><br>B.串中元素只能是字母<br>C.空串就是空白串<br>D.串的长度必须大于零<br><strong>正确答案：A</strong><br>解析： A、串是一种特殊的线性表，其元素为单个字符，长度可以为0。</p><p><strong>课本考据：<br>1）字符串简称为串，串是由字符元素构成的，其中元素的逻辑关系也是一种线性关系。<br>2）在一般情况下，英文字母、数字（0，1，·····9）和常用的标点符号以及空格符等都是合法的字符。<br>3）含零个字符的串称为空串。</strong></p><h2 id="2、两个字符串相等的条件是（-）。"><a href="#2、两个字符串相等的条件是（-）。" class="headerlink" title="2、两个字符串相等的条件是（ ）。"></a>2、两个字符串相等的条件是（ ）。</h2><p>A.串的长度相等<br>B.含有相同的字符集<br>C.都是非空串<br>D.两个串的长度相等且对应位置的字符相同<br><strong>正确答案：D</strong></p><p><strong>课本考据：两个串相等当且仅当这两个串的长度相等并且个对应位置上的字符都相同。</strong></p><h2 id="3、若串str-x3D-“Software”，其子串的个数是（-）。"><a href="#3、若串str-x3D-“Software”，其子串的个数是（-）。" class="headerlink" title="3、若串str&#x3D;“Software”，其子串的个数是（ ）。"></a>3、若串str&#x3D;“Software”，其子串的个数是（ ）。</h2><p>A.8<br>B.9<br>C.36<br>D.37<br><strong>正确答案：D</strong><br>解析： D、该串中所有字符不相同，长度为0的子串1个，长度为1的子串8个，长度为2的子串7个，…，长度为7的子串2个，长度为8的子串1个，总计子串数&#x3D;1+8+7+…+2+1&#x3D;1+8×9&#x2F;2&#x3D;37。</p><h2 id="4、一个链串的节点类型定义为-define-NodeSize-6"><a href="#4、一个链串的节点类型定义为-define-NodeSize-6" class="headerlink" title="4、一个链串的节点类型定义为#define NodeSize 6"></a>4、一个链串的节点类型定义为#define NodeSize 6</h2><p>typedef struct node<br>{<br>char data[NodeSize];<br>struct node *next;<br>} LinkStrNode;<br>如果每个字符占1个字节，指针占2个字节，该链串的存储密度为（ ）。<br>A.1&#x2F;3<br>B.1&#x2F;2<br>C.2&#x2F;3<br>D.3&#x2F;4<br><strong>正确答案：D</strong><br>解析： D、链串节点大小指每个节点存放的字符个数，本题节点大小为6，存储密度&#x3D;(6 * 1)&#x2F;(6 * 1+2)&#x3D;3&#x2F;4。</p><h2 id="5、串采用节点大小为1的链表作为其存储结构，是指（-）。"><a href="#5、串采用节点大小为1的链表作为其存储结构，是指（-）。" class="headerlink" title="5、串采用节点大小为1的链表作为其存储结构，是指（ ）。"></a>5、串采用节点大小为1的链表作为其存储结构，是指（ ）。</h2><p>A.链表的长度为1<br>B.链表中只存放一个字符<br>C.链表中每个节点的数据域中只存放一个字符<br>D.以上都不对<br><strong>正确答案：C</strong><br>解析： C、链串节点大小指每个节点存放的字符个数。</p><h2 id="6、对于一个链串s，查找第一个字符值为x的算法的时间复杂度为（-）。"><a href="#6、对于一个链串s，查找第一个字符值为x的算法的时间复杂度为（-）。" class="headerlink" title="6、对于一个链串s，查找第一个字符值为x的算法的时间复杂度为（ ）。"></a>6、对于一个链串s，查找第一个字符值为x的算法的时间复杂度为（ ）。</h2><p>A.O(1)<br>B.O(n)<br>C.O(n2)<br>D.以上都不对<br><strong>正确答案：B</strong><br>解析： B、在链串查找第一个字符值为x的算法的时间复杂度为O(n)。</p><h2 id="7、设有两个串p和q，其中q是p的子串，则求q在p中首次出现位置的算法称为（-）。"><a href="#7、设有两个串p和q，其中q是p的子串，则求q在p中首次出现位置的算法称为（-）。" class="headerlink" title="7、设有两个串p和q，其中q是p的子串，则求q在p中首次出现位置的算法称为（ ）。"></a>7、设有两个串p和q，其中q是p的子串，则求q在p中首次出现位置的算法称为（ ）。</h2><p>A.求子串<br>B.串联接<br>C.模式匹配<br>D.求串长<br><strong>正确答案：C</strong><br>解析： C、模式匹配算法就是找子串在主串中的位置。</p><h2 id="8、在串的简单模式匹配中，当模式串位j与目标串位i比较时，两字符不相等，则i的位移方式是（-）。"><a href="#8、在串的简单模式匹配中，当模式串位j与目标串位i比较时，两字符不相等，则i的位移方式是（-）。" class="headerlink" title="8、在串的简单模式匹配中，当模式串位j与目标串位i比较时，两字符不相等，则i的位移方式是（ ）。"></a>8、在串的简单模式匹配中，当模式串位j与目标串位i比较时，两字符不相等，则i的位移方式是（ ）。</h2><p>A.i++<br>B.i&#x3D;j+1<br>C.i&#x3D;i-j+1<br>D.i&#x3D;j-i+1<br><strong>正确答案：C</strong><br>解析： C、在串的简单模式匹配(BF算法)中，当两字符比较不等时，目标串位i回溯到原来位置的下一个位置，即i&#x3D;i-j+1。</p><h2 id="9、在KMP模式匹配中，用next数组存放模式串的部分匹配信息。当模式串位j与目标串位i比较时，两字符不相等，则i的位移方式是（-）。"><a href="#9、在KMP模式匹配中，用next数组存放模式串的部分匹配信息。当模式串位j与目标串位i比较时，两字符不相等，则i的位移方式是（-）。" class="headerlink" title="9、在KMP模式匹配中，用next数组存放模式串的部分匹配信息。当模式串位j与目标串位i比较时，两字符不相等，则i的位移方式是（ ）。"></a>9、在KMP模式匹配中，用next数组存放模式串的部分匹配信息。当模式串位j与目标串位i比较时，两字符不相等，则i的位移方式是（ ）。</h2><p>A.i&#x3D;next[j]<br>B.i不变<br>C…j不变<br>D.j&#x3D;next[j]<br><strong>正确答案：B</strong><br>解析： B、在KMP模式匹配中，当两字符比较不等时，目标串位i不回溯，仍停留在原来的位置。</p><h2 id="10、在KMP模式匹配中，用next数组存放模式串的部分匹配信息。当模式串位j与目标串位i比较时，两字符不相等，则j的位移方式是（-）。"><a href="#10、在KMP模式匹配中，用next数组存放模式串的部分匹配信息。当模式串位j与目标串位i比较时，两字符不相等，则j的位移方式是（-）。" class="headerlink" title="10、在KMP模式匹配中，用next数组存放模式串的部分匹配信息。当模式串位j与目标串位i比较时，两字符不相等，则j的位移方式是（ ）。"></a>10、在KMP模式匹配中，用next数组存放模式串的部分匹配信息。当模式串位j与目标串位i比较时，两字符不相等，则j的位移方式是（ ）。</h2><p>A.i&#x3D;next[j]<br>B.i不变<br>C.j不变<br>D.j&#x3D;next[j]<br><strong>正确答案：D</strong><br>解析： D、在KMP模式匹配中，当两字符比较不等时，目标串位i不改变，将其位置字符与模式串中next[j]位置的字符比较，即j&#x3D;next[j]。</p><hr><h1 id="第六周测验"><a href="#第六周测验" class="headerlink" title="第六周测验"></a>第六周测验</h1><h2 id="1、一个正确的递归算法通常包含（-）。"><a href="#1、一个正确的递归算法通常包含（-）。" class="headerlink" title="1、一个正确的递归算法通常包含（ ）。"></a>1、一个正确的<a href="https://so.csdn.net/so/search?q=%E9%80%92%E5%BD%92%E7%AE%97%E6%B3%95&spm=1001.2101.3001.7020">递归算法</a>通常包含（ ）。</h2><p>A.递归出口<br>B.递归体<br>C.递归出口和递归体<br>D.以上都不包含<br><strong>正确答案：C</strong><br>解析： C、正确的递归算法应包含递归出口和递归体两部分，缺一不可。</p><p><strong>课本考据：递归算法设计的基本步骤是先确定求解问题的递归模型，在转换成对应的 C&#x2F;C++语言函数。而一个递归体模型由递归出口（确定结束条件）和递归体（确定递推关系）两部分组成。</strong></p><h2 id="2、递归函数f-x，y-定义如下："><a href="#2、递归函数f-x，y-定义如下：" class="headerlink" title="2、递归函数f(x，y)定义如下："></a>2、<a href="https://so.csdn.net/so/search?q=%E9%80%92%E5%BD%92%E5%87%BD%E6%95%B0&spm=1001.2101.3001.7020">递归函数</a>f(x，y)定义如下：</h2><p>f(x，y)&#x3D;f(x-1，y)+f(x，y-1) 当x&gt;0且y&gt;0<br>f(x，y)&#x3D;x+y 否则<br>则f(2，1)的值是（ ）。<br>A.1<br>B.2<br>C.3<br>D.4<br><strong>正确答案：D</strong><br>解析： D、f(2,1)&#x3D;f(1,1)+f(2,0)&#x3D;f(0,1)+f(1,0)+2&#x3D;1+1+2&#x3D;4。</p><h2 id="3、某递归算法的执行时间的递推关系如下："><a href="#3、某递归算法的执行时间的递推关系如下：" class="headerlink" title="3、某递归算法的执行时间的递推关系如下："></a>3、某递归算法的执行时间的递推关系如下：</h2><p>T(n)&#x3D;1 当n&#x3D;1时<br>T(n)&#x3D;T(n&#x2F;2)+1 当n&gt;1时<br>则该算法的时间复杂度为（ ）。<br>A.O(1)<br>B.O(log2n)<br>C.O(n)<br>D.O(nlog2n)<br><strong>正确答案：B</strong><br>解析： B、不妨设n&#x3D;2^k，k&#x3D;log2n。<br>T(n)&#x3D;T(n&#x2F;2)+1&#x3D; T(n&#x2F;22)+2&#x3D;…&#x3D; T(n&#x2F;2k)+k&#x3D;T(1)+log2n&#x3D;O(log2n)。</p><h2 id="4、某递归算法的执行时间的递推关系如下："><a href="#4、某递归算法的执行时间的递推关系如下：" class="headerlink" title="4、某递归算法的执行时间的递推关系如下："></a>4、某递归算法的执行时间的递推关系如下：</h2><p>T(n)&#x3D;1 当n&#x3D;1时<br>T(n)&#x3D;2T(n&#x2F;2)+1 当n&gt;1时<br>则该算法的时间复杂度为（ ）。<br>A.O(1)<br>B.O(log2n)<br>C.O(n)<br>D.O(log2n)<br><strong>正确答案：C</strong><br>解析： C、不妨设n&#x3D;2^k，k&#x3D;log2n。<br>T(n)&#x3D;21<em>T(n&#x2F;21)+1&#x3D;22</em>T(n&#x2F;22)+1+21&#x3D;…&#x3D;2kT(n&#x2F;2k)+1+21+…+2(k-1)&#x3D;2kT(1)+2k-1&#x3D;2n-1&#x3D;O(n)。</p><h2 id="5、将递归算法转换成非递归算法时，通常要借助的数据结构是（-）。"><a href="#5、将递归算法转换成非递归算法时，通常要借助的数据结构是（-）。" class="headerlink" title="5、将递归算法转换成非递归算法时，通常要借助的数据结构是（ ）。"></a>5、将递归算法转换成非递归算法时，通常要借助的数据结构是（ ）。</h2><p>A.线性表<br>B.栈<br>C.队列<br>D.树<br><strong>正确答案：B</strong><br>解析： B、递归算法转换成非递归算法时通常使用栈。</p><p><strong>课本考据：大多数CPU上的程序实现使用栈来支持函数调用操作。</strong></p><hr><h1 id="第七周测验"><a href="#第七周测验" class="headerlink" title="第七周测验"></a>第七周测验</h1><h2 id="1、有一个三维数组A-2…2-4…5-2…6-，其中元素个数是（-）。"><a href="#1、有一个三维数组A-2…2-4…5-2…6-，其中元素个数是（-）。" class="headerlink" title="1、有一个三维数组A[-2…2][-4…5][2…6]，其中元素个数是（ ）。"></a>1、有一个三维数组A[-2…2][-4…5][2…6]，其中元素个数是（ ）。</h2><p>A.144<br>B.60<br>C.396<br>D.250<br><strong>正确答案：D</strong><br>解析： D、A的第1维长度为5【2-（-2）+1：-2，-1，0，1，2】，第2维长度为10【5-（-4）+1：-4，-3，-2，-1，0，1，2，3，4，5】，第3维长度为5【6-2+1：2，3，4，5，6】，元素个数&#x3D;5×10×5&#x3D;250。</p><p><strong>课本考据：一个的二维数组可看作是每个数据元素都是相同类型的一维数组的一维数组。如下图所示：</strong><br><img src="/../imgs/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%88%B7%E9%A2%98/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzAwNDU0MA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>故，任何多维数组都可看作一个线性表。**</p><h2 id="2、设C-x2F-C-二维数组a-m-n-，每个数组元素占用k个存储单元，第一个数组元素的存储地址是LOC-a-0-0-，求按行优先顺序存放的数组元素a-i-j-（0≤i≤m-1，0≤j≤n-1）的存储地址为（-）。"><a href="#2、设C-x2F-C-二维数组a-m-n-，每个数组元素占用k个存储单元，第一个数组元素的存储地址是LOC-a-0-0-，求按行优先顺序存放的数组元素a-i-j-（0≤i≤m-1，0≤j≤n-1）的存储地址为（-）。" class="headerlink" title="2、设C&#x2F;C++二维数组a[m][n]，每个数组元素占用k个存储单元，第一个数组元素的存储地址是LOC(a[0][0])，求按行优先顺序存放的数组元素a[i][j]（0≤i≤m-1，0≤j≤n-1）的存储地址为（ ）。"></a>2、设C&#x2F;C++<a href="https://so.csdn.net/so/search?q=%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84&spm=1001.2101.3001.7020">二维数组</a>a[m][n]，每个数组元素占用k个存储单元，第一个数组元素的存储地址是LOC(a[0][0])，求按行优先顺序存放的数组元素a[i][j]（0≤i≤m-1，0≤j≤n-1）的存储地址为（ ）。</h2><p>A.LOC(a[0][0])+[i×n+j]×k<br>B.LOC(a[0][0])+[j×m+i]×k<br>C.LOC(a[0][0])+[(j-1)×m+i-1]×k<br>D.LOC(a[0][0])+[(i-1)×n+j-1]×k<br><strong>正确答案：A</strong><br>解析： A、a[i][j]前面有0～i-1行，计i×n个元素，第i行前面有j个元素，则a[i][j]前面有i×m+ j个元素，所以a[i][j]的存储地址&#x3D;LOC(a[0][0])+[i×n+j]×k。</p><p><strong>课本考据：在内存中元素a[i][j]前面有i行，每行有n个元素，即已存放了i×n个元素，占用了i×n×k个内存单元；在第i行中元素a[i][j]前面有j个元素，即已存放了j个元素，占用了j-1乘k个内存单元；</strong></p><h2 id="3、设二维数组a-1…5-1…8-，若按行优先的顺序存放数组的元素，则a-4-6-元素的前面有（-）个元素。"><a href="#3、设二维数组a-1…5-1…8-，若按行优先的顺序存放数组的元素，则a-4-6-元素的前面有（-）个元素。" class="headerlink" title="3、设二维数组a[1…5][1…8]，若按行优先的顺序存放数组的元素，则a[4][6]元素的前面有（ ）个元素。"></a>3、设二维数组a[1…5][1…8]，若按行优先的顺序存放数组的元素，则a[4][6]元素的前面有（ ）个元素。</h2><p>A.6<br>B.28<br>C.29<br>D.40<br><strong>正确答案：C</strong><br>解析： C、m&#x3D;5，n&#x3D;8，a[4][6]元素的前面的元素个数&#x3D;(4-1) ×8+(6-1)&#x3D;29。</p><p><strong>课本考据：二维数组按行优先存放的示意图如<img src="/../imgs/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%88%B7%E9%A2%98/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA54yq6ISa546L,size_20,color_FFFFFF,t_70,g_se,x_16-168761569918718.png" alt="在这里插入图片描述"><br><img src="/../imgs/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%88%B7%E9%A2%98/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA54yq6ISa546L,size_20,color_FFFFFF,t_70,g_se,x_16-168761569778215.png" alt="在这里插入图片描述"><br>得该二维数组中任一元素a的存储地址，其中k为存储单元。</strong></p><h2 id="4、设C-x2F-C-二维数组a-6-10-，每个数组元素占用4个存储单元，若按行优先顺序存放所有数组元素，a-3-5-的存储地址为1000，则a-0-0-的存储地址是（-）。"><a href="#4、设C-x2F-C-二维数组a-6-10-，每个数组元素占用4个存储单元，若按行优先顺序存放所有数组元素，a-3-5-的存储地址为1000，则a-0-0-的存储地址是（-）。" class="headerlink" title="4、设C&#x2F;C++二维数组a[6][10]，每个数组元素占用4个存储单元，若按行优先顺序存放所有数组元素，a[3][5]的存储地址为1000，则a[0][0]的存储地址是（ ）。"></a>4、设C&#x2F;C++二维数组a[6][10]，每个<a href="https://so.csdn.net/so/search?q=%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0&spm=1001.2101.3001.7020">数组元素</a>占用4个存储单元，若按行优先顺序存放所有数组元素，a[3][5]的存储地址为1000，则a[0][0]的存储地址是（ ）。</h2><p>A.868<br>B.872<br>C.860<br>D.864<br><strong>正确答案：C</strong><br>解析： C、C&#x2F;C++二维数组下标从0开始。a[3][5]前面的元素个数&#x3D;(3-0)×10+(5-0)&#x3D;35。所以1000&#x3D;LOC(a[0][0])+35×4，LOC(a[0][0])&#x3D;860。</p><h2 id="5、一个n阶对称矩阵A采用压缩存储方式，将其下三角部分（含主对角线元素）按行优先存储到一维数组B中，则B中元素个数是（-）。"><a href="#5、一个n阶对称矩阵A采用压缩存储方式，将其下三角部分（含主对角线元素）按行优先存储到一维数组B中，则B中元素个数是（-）。" class="headerlink" title="5、一个n阶对称矩阵A采用压缩存储方式，将其下三角部分（含主对角线元素）按行优先存储到一维数组B中，则B中元素个数是（ ）。"></a>5、一个n阶对称矩阵A采用压缩存储方式，将其下三角部分（含主对角线元素）按行优先存储到一维数组B中，则B中元素个数是（ ）。</h2><p>A.n(n+1)&#x2F;2+1<br>B.n(n+1)&#x2F;2<br>C.n<br>D.n*n<br><strong>正确答案：B</strong></p><p><strong>课本考据：特殊矩阵是指非零元素或零元素得分布具有一定规律得矩阵，为了节省存储空间，特别是在高阶矩阵的情况下可以利用特殊矩阵的对它们进行压缩存储以提高存储空间效率。将特殊矩阵压缩规律如图表示<img src="/../imgs/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%88%B7%E9%A2%98/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA54yq6ISa546L,size_20,color_FFFFFF,t_70,g_se,x_16-168761569450612.png" alt="在这里插入图片描述"><br><img src="/../imgs/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%88%B7%E9%A2%98/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA54yq6ISa546L,size_20,color_FFFFFF,t_70,g_se,x_16-16876156923419.png" alt="在这里插入图片描述"><br><img src="/../imgs/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%88%B7%E9%A2%98/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA54yq6ISa546L,size_20,color_FFFFFF,t_70,g_se,x_16.png" alt="在这里插入图片描述"><br>显然，一维数组B中存放的元素个数为1+2+…+n&#x3D;n(n+1)&#x2F;2。</strong></p><h2 id="6、一个n阶对称矩阵A-1…n，1…n-采用压缩存储方式，将其下三角部分按行优先存储到一维数组B-1…m-中，则A-i-j-（i-lt-j）元素在B中的位置k是（-）。"><a href="#6、一个n阶对称矩阵A-1…n，1…n-采用压缩存储方式，将其下三角部分按行优先存储到一维数组B-1…m-中，则A-i-j-（i-lt-j）元素在B中的位置k是（-）。" class="headerlink" title="6、一个n阶对称矩阵A[1…n，1…n]采用压缩存储方式，将其下三角部分按行优先存储到一维数组B[1…m]中，则A[i][j]（i&lt;j）元素在B中的位置k是（ ）。"></a>6、一个n阶对称矩阵A[1…n，1…n]采用压缩存储方式，将其下三角部分按行优先存储到一维数组B[1…m]中，则A[i][j]（i&lt;j）元素在B中的位置k是（ ）。</h2><p>A.j(j-1)&#x2F;2+i<br>B.j(j-1)&#x2F;2+i-1<br>C.i(i-1)&#x2F;2+j-1<br>D. i(i-1)&#x2F;2+j<br><strong>正确答案：A</strong><br>解析： A、对于下三角部分或者主对角线元素a[i][j]，它存储在b[k]中，k&#x3D;i(i-1)&#x2F;2+j。对于上三角部分元素A[i][j]（i&lt;j），对应的k&#x3D;j(j-1)&#x2F;2+i。</p><h2 id="7、一个n阶上三角矩阵A按行优先顺序压缩存放在一维数组B，则B中元素个数是（-）。"><a href="#7、一个n阶上三角矩阵A按行优先顺序压缩存放在一维数组B，则B中元素个数是（-）。" class="headerlink" title="7、一个n阶上三角矩阵A按行优先顺序压缩存放在一维数组B，则B中元素个数是（ ）。"></a>7、一个n阶上三角矩阵A按行优先顺序压缩存放在一维数组B，则B中元素个数是（ ）。</h2><p>A.n*n<br>B.n(n+1)&#x2F;2+1<br>C.n<br>D.n(n+1)&#x2F;2<br><strong>正确答案：B</strong></p><p>**课本考据：对于上三角矩阵的压缩存储方法是采用 以行序为主序存储对其主对角线加上三角部分的元素，另外用一个元素存储常数c，并将压缩结果存放在一维数组B中，如图<img src="/../imgs/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%88%B7%E9%A2%98/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA54yq6ISa546L,size_20,color_FFFFFF,t_70,g_se,x_16-16876156836786.png" alt="在这里插入图片描述"><br><img src="/../imgs/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%88%B7%E9%A2%98/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA54yq6ISa546L,size_20,color_FFFFFF,t_70,g_se,x_16-16876156801933.png" alt="在这里插入图片描述"></p><p>显然，B中元素的个数为n(n+1)&#x2F;2+1，即用B[0…n(n+1)&#x2F;2]存放A 中的元素。**</p><h2 id="8、一个n-n-gt-3-阶三对角矩阵A按行优先顺序压缩存放在一维数组B，则B中元素个数是（-）。"><a href="#8、一个n-n-gt-3-阶三对角矩阵A按行优先顺序压缩存放在一维数组B，则B中元素个数是（-）。" class="headerlink" title="8、一个n(n&gt;3)阶三对角矩阵A按行优先顺序压缩存放在一维数组B，则B中元素个数是（ ）。"></a>8、一个n(n&gt;3)阶三对角矩阵A按行优先顺序压缩存放在一维数组B，则B中元素个数是（ ）。</h2><p>A.3n-2<br>B.2n<br>C.n*n<br>D.3n<br><strong>正确答案：A</strong></p><p><strong>课本考据：若 一个n阶方阵A 满足其所有非零元素都集中在对主对角线为中心的带状区域中。则称为n阶对角矩阵。<img src="/../imgs/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%88%B7%E9%A2%98/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA54yq6ISa546L,size_20,color_FFFFFF,t_70,g_se,x_16-168761996540033.png" alt="在这里插入图片描述"></strong></p><h2 id="9、稀疏矩阵常用的压缩存储方法有（-）。"><a href="#9、稀疏矩阵常用的压缩存储方法有（-）。" class="headerlink" title="9、稀疏矩阵常用的压缩存储方法有（ ）。"></a>9、稀疏矩阵常用的压缩存储方法有（ ）。</h2><p>A.二维数组<br>B.哈希表和十字链表<br>C.三元组和哈希表<br>D.三元组和十字链表<br><strong>正确答案：D</strong></p><p><strong>课本考据：把稀疏矩阵的三元组线性表按顺序存储结构存储，则称为稀疏矩阵的三元组顺序表（简称为三元组表）；十字链表是稀疏矩阵的 一种链式存储结构。</strong></p><h2 id="10、稀疏矩阵采用压缩存储后的缺点之一是（-）。"><a href="#10、稀疏矩阵采用压缩存储后的缺点之一是（-）。" class="headerlink" title="10、稀疏矩阵采用压缩存储后的缺点之一是（ ）。"></a>10、稀疏矩阵采用压缩存储后的缺点之一是（ ）。</h2><p>A.丧失随机存取特性<br>B.无法由行、列值查找某个矩阵元素<br>C.无法判断矩阵的行列数<br>D.使矩阵元素之间的逻辑关系更加复杂<br><strong>正确答案：A</strong></p><h1 id="第八周测验"><a href="#第八周测验" class="headerlink" title="第八周测验"></a>第八周测验</h1><h2 id="1树最适合用来表示（-）。"><a href="#1树最适合用来表示（-）。" class="headerlink" title="1树最适合用来表示（ ）。"></a>1树最适合用来表示（ ）。</h2><p>A.元素之间无联系的数据<br>B.元素之间具有层次关系的数据<br>C.有序数据元素<br>D.无序数据元素<br>正确答案：B</p><p><strong>课本考据：树结构常用于表示具有层次关系的数据。</strong></p><h2 id="2现有一“遗传”关系，设x是y的父亲，则x可以把他的属性遗传给y。表示该遗传关系最适合的数据结构为（-）。"><a href="#2现有一“遗传”关系，设x是y的父亲，则x可以把他的属性遗传给y。表示该遗传关系最适合的数据结构为（-）。" class="headerlink" title="2现有一“遗传”关系，设x是y的父亲，则x可以把他的属性遗传给y。表示该遗传关系最适合的数据结构为（ ）。"></a>2现有一“遗传”关系，设x是y的父亲，则x可以把他的属性遗传给y。表示该遗传关系最适合的数据结构为（ ）。</h2><p>A.线性表<br>B.数组<br>C.树<br>D.图<br>正确答案：C</p><p><strong>课本考据：在一颗树中，每个节点的后继结点被称为改结点的孩子结点。相应的该结点被称为孩子结点的双亲结点。</strong></p><h2 id="3一棵节点个数为n、高度为h的m（m≥3）次树中，其分支数是（-）。"><a href="#3一棵节点个数为n、高度为h的m（m≥3）次树中，其分支数是（-）。" class="headerlink" title="3一棵节点个数为n、高度为h的m（m≥3）次树中，其分支数是（ ）。"></a>3一棵节点个数为n、高度为h的m（m≥3）次树中，其分支数是（ ）。</h2><p>A.n+h<br>B.h-1<br>C.n-1<br>D.nh<br>正确答案：C</p><p><strong>课本考据：<br>1.树中某个结点的<code>子树的个数</code>称为该结点的度。<br>2.树中所有结点的<code>度中的最大值</code>称为树的度。<br>3.通常将<code>度为m</code>的树称为m次树。<br>4.树中的每个结点都处在一定的层次上。结点层次或结点深度是从树根开始定义的，根结点为第一层，他的孩子结点为第二层，依此类推，一个结点所在的层次为其双亲结点的层次加1。<br>5.树中结点<code>最大层次</code>称为树的高度或树的深度。<br><code>6.树中的结点数等于所有结点的度数之和加1。</code></strong></p><h2 id="4若一棵3次树中有2个度为3的节点，1个度为2的节点，2个度为1的节点，该树一共有（-）个节点。"><a href="#4若一棵3次树中有2个度为3的节点，1个度为2的节点，2个度为1的节点，该树一共有（-）个节点。" class="headerlink" title="4若一棵3次树中有2个度为3的节点，1个度为2的节点，2个度为1的节点，该树一共有（ ）个节点。"></a>4若一棵3次树中有2个度为3的节点，1个度为2的节点，2个度为1的节点，该树一共有（ ）个节点。</h2><p>A.11<br>B.8<br>C.5<br>D.10<br>正确答案：A<br>解析： A、对于该3次树，其中有n3&#x3D;2，n2&#x3D;1，n1&#x3D;2，总分支数&#x3D;总度数&#x3D;n-1，总度数&#x3D;1×n1+2×n2+3×n3&#x3D;10，则n&#x3D;总度数+1&#x3D;11。</p><p><strong>课本考据：<br>1、任何非空树中：分支数 &#x3D; 所有节点度之和，分支数&#x3D;n-1。<br>2、度为m的树中：n &#x3D; n0+n1+n2+…+nm。<br>3、度为m的树中：所有结点度之和 &#x3D; n1+2n2+…+mnm。</strong></p><h2 id="5设树T的度为4，其中度为1、2、3、4的节点个数分别为4、2、1、1，则T中的叶子节点个数是（-）。"><a href="#5设树T的度为4，其中度为1、2、3、4的节点个数分别为4、2、1、1，则T中的叶子节点个数是（-）。" class="headerlink" title="5设树T的度为4，其中度为1、2、3、4的节点个数分别为4、2、1、1，则T中的叶子节点个数是（ ）。"></a>5设树T的度为4，其中度为1、2、3、4的节点个数分别为4、2、1、1，则T中的叶子节点个数是（ ）。</h2><p>A.6<br>B.5<br>C.7<br>D.8<br>正确答案：D<br>解析： D、这里n1&#x3D;4，n2&#x3D;2，n3&#x3D;1，n4&#x3D;1，度之和&#x3D;n-1&#x3D;n1+2n2+3n3+4n4&#x3D;15，所以n&#x3D;16，则n0&#x3D;n-n1-n2-n3-n4&#x3D;16-8&#x3D;8。</p><h2 id="6有一棵三次树，其中n3-x3D-2，n2-x3D-1，n0-x3D-6，则该树的节点个数为（-）。"><a href="#6有一棵三次树，其中n3-x3D-2，n2-x3D-1，n0-x3D-6，则该树的节点个数为（-）。" class="headerlink" title="6有一棵三次树，其中n3&#x3D;2，n2&#x3D;1，n0&#x3D;6，则该树的节点个数为（ ）。"></a>6有一棵三次树，其中n3&#x3D;2，n2&#x3D;1，n0&#x3D;6，则该树的节点个数为（ ）。</h2><p>A.大于等于9的任意整数<br>B.10<br>C.9<br>D.12<br>正确答案：A<br>解析： A、n&#x3D;n0+n1+n2+n3&#x3D;6+n1+1+2&#x3D;9+n1。</p><h2 id="7假设每个节点值为单个字符，而一棵树的后根遍历序列为ABCDEFGHIJ，则其根节点值是（-）。"><a href="#7假设每个节点值为单个字符，而一棵树的后根遍历序列为ABCDEFGHIJ，则其根节点值是（-）。" class="headerlink" title="7假设每个节点值为单个字符，而一棵树的后根遍历序列为ABCDEFGHIJ，则其根节点值是（ ）。"></a>7假设每个节点值为单个字符，而一棵树的后根遍历序列为ABCDEFGHIJ，则其根节点值是（ ）。</h2><p>A.A<br>B.以上都不对<br>C.B<br>D.J<br>正确答案：D</p><p><strong>课本考据：后根遍历的过程（1、按照从左到右的顺序后根遍历根结点的每一颗子树。2、访问跟结点。）</strong></p><h2 id="8一棵度为5、节点个数为n的树采用孩子链存储结构时，其中空指针域的个数是（-）。"><a href="#8一棵度为5、节点个数为n的树采用孩子链存储结构时，其中空指针域的个数是（-）。" class="headerlink" title="8一棵度为5、节点个数为n的树采用孩子链存储结构时，其中空指针域的个数是（ ）。"></a>8一棵度为5、节点个数为n的树采用孩子链存储结构时，其中空指针域的个数是（ ）。</h2><p>A.4n+1<br>B.5n<br>C.4n-1<br>D.4n<br>正确答案：A<br>解析： A、总指针数&#x3D;5n，非空总指针数&#x3D;分支数&#x3D;n-1，空指针域的个数&#x3D;5n-(n-1)&#x3D;4n+1。</p><h2 id="9‌有一棵三次树，其中n3-x3D-2，n2-x3D-2，n1-x3D-1，该树采用孩子兄弟链存储结构时，则总的指针域数为（-）。"><a href="#9‌有一棵三次树，其中n3-x3D-2，n2-x3D-2，n1-x3D-1，该树采用孩子兄弟链存储结构时，则总的指针域数为（-）。" class="headerlink" title="9‌有一棵三次树，其中n3&#x3D;2，n2&#x3D;2，n1&#x3D;1，该树采用孩子兄弟链存储结构时，则总的指针域数为（ ）。"></a>9‌有一棵三次树，其中n3&#x3D;2，n2&#x3D;2，n1&#x3D;1，该树采用孩子兄弟链存储结构时，则总的指针域数为（ ）。</h2><p>A.16<br>B.24<br>C.10<br>D.36<br>正确答案：B<br>解析： B、度之和&#x3D;n-1&#x3D;n1+2n2+3n3&#x3D;11，n&#x3D;12，每个节点有两个指针域，所以总的指针域数为24。</p><h2 id="10以下关于二叉树的说法中正确的是（-）"><a href="#10以下关于二叉树的说法中正确的是（-）" class="headerlink" title="10以下关于二叉树的说法中正确的是（ ）"></a>10以下关于二叉树的说法中正确的是（ ）</h2><p>A.二叉树中每个节点的度都为2<br>B.二叉树中不存在度大于2的节点<br>C.二叉树就是度为2的树<br>D.二叉树就是度为2有序树<br>正确答案：B</p><p><strong>课本考据：二叉树是一个有限的结点集合，这个集合或者空，或者由一个根结点和两颗互不相交的称为左子树和右子树的二叉树组成。</strong></p><h2 id="11按照二叉树的定义，具有3个节点的二叉树有（-）种。"><a href="#11按照二叉树的定义，具有3个节点的二叉树有（-）种。" class="headerlink" title="11按照二叉树的定义，具有3个节点的二叉树有（ ）种。"></a>11按照二叉树的定义，具有3个节点的二叉树有（ ）种。</h2><p>A.6<br>B.4<br>C.5<br>D.3<br>正确答案：C</p><h2 id="12一棵完全二叉树中有1000个节点，其中度为1的节点个数是（-）。"><a href="#12一棵完全二叉树中有1000个节点，其中度为1的节点个数是（-）。" class="headerlink" title="12一棵完全二叉树中有1000个节点，其中度为1的节点个数是（ ）。"></a>12一棵完全二叉树中有1000个节点，其中度为1的节点个数是（ ）。</h2><p>A.不确定<br>B.1<br>C.0<br>D.2<br>正确答案：B<br>解析： B、完全二叉树中节点个数n为奇数时，n1&#x3D;0；n为偶数时，n1&#x3D;1。</p><p><strong>课本考据：在一颗二叉树中，如果所有分支结节点都有左孩子结点和右孩子结点，并且叶子结点都集中在二叉树的最下一层，这样的二叉树称为满二叉树。</strong></p><h2 id="13一棵满二叉树有m个叶子节点和n个节点，其高度为h，则有（-）。"><a href="#13一棵满二叉树有m个叶子节点和n个节点，其高度为h，则有（-）。" class="headerlink" title="13一棵满二叉树有m个叶子节点和n个节点，其高度为h，则有（ ）。"></a>13一棵<a href="https://so.csdn.net/so/search?q=%E6%BB%A1%E4%BA%8C%E5%8F%89%E6%A0%91&spm=1001.2101.3001.7020">满二叉树</a>有m个叶子节点和n个节点，其高度为h，则有（ ）。</h2><p>A.m&#x3D;h-1<br>B.n&#x3D;h+m<br>C.n&#x3D;2^h-1<br>D.h+m&#x3D;2n<br>正确答案：C</p><p><strong>课本考据：高度为h的二叉树最多有2h-1个结点。</strong></p><h2 id="14设森林F中有4棵树，第1、2、3、4棵树的节点个数分别为a、b、c、d，将森林F转换为二叉树B，则B中根节点的左子树上的节点个数是（）。"><a href="#14设森林F中有4棵树，第1、2、3、4棵树的节点个数分别为a、b、c、d，将森林F转换为二叉树B，则B中根节点的左子树上的节点个数是（）。" class="headerlink" title="14设森林F中有4棵树，第1、2、3、4棵树的节点个数分别为a、b、c、d，将森林F转换为二叉树B，则B中根节点的左子树上的节点个数是（）。"></a>14设森林F中有4棵树，第1、2、3、4棵树的节点个数分别为a、b、c、d，将森林F转换为二叉树B，则B中根节点的左子树上的节点个数是（）。</h2><p>A.a-1<br>B.b+c+d<br>C.a+b+c<br>D.a<br>正确答案：A</p><p><strong>课本考据：树、森林与二叉树之间有一个自然的对应关系，他们之间可以互相转换，即任何一个树林或一颗树都可以唯一地对应一颗二叉树，反之任一棵二叉树也能唯一地对应到一个森林或一棵树上。</strong></p><h2 id="15‌一棵完全二叉树中有501个叶子节点，则至少有（-）个节点。"><a href="#15‌一棵完全二叉树中有501个叶子节点，则至少有（-）个节点。" class="headerlink" title="15‌一棵完全二叉树中有501个叶子节点，则至少有（ ）个节点。"></a>15‌一棵完全二叉树中有501个叶子节点，则至少有（ ）个节点。</h2><p>A.502<br>B.501<br>C.1002<br>D.1001<br>正确答案：D<br>解析： D、n0&#x3D;n2+1，这里n0&#x3D;501，所以，n2&#x3D;500，n&#x3D;n0+n1+n2&#x3D;1001+n1，n1为0或者1，所以有n≥1001。</p><h1 id="第九周测验"><a href="#第九周测验" class="headerlink" title="第九周测验"></a>第九周测验</h1><h2 id="1一颗二叉树的括号表示为”1-2-4，5-6，7-，3-”。设N代表二叉树的根，L代表根节点的左子树，R代表根节点的右子树。若遍历后的节点序列为3，1，7，5，6，2，4，则其遍历方式是（-）。"><a href="#1一颗二叉树的括号表示为”1-2-4，5-6，7-，3-”。设N代表二叉树的根，L代表根节点的左子树，R代表根节点的右子树。若遍历后的节点序列为3，1，7，5，6，2，4，则其遍历方式是（-）。" class="headerlink" title="1一颗二叉树的括号表示为”1(2(4，5(6，7))，3)”。设N代表二叉树的根，L代表根节点的左子树，R代表根节点的右子树。若遍历后的节点序列为3，1，7，5，6，2，4，则其遍历方式是（ ）。"></a>1一颗二叉树的括号表示为”1(2(4，5(6，7))，3)”。设N代表二叉树的根，L代表根节点的左子树，R代表根节点的右子树。若遍历后的节点序列为3，1，7，5，6，2，4，则其遍历方式是（ ）。</h2><p>A.RLN<br>B.RNL<br>C.NRL<br>D.<a href="https://so.csdn.net/so/search?q=LRN&spm=1001.2101.3001.7020">LRN</a><br>正确答案：B</p><p><strong>课本考据：二叉树的遍历有6种方式NLR、LNR、LRN、NRL、RNL、RLN。</strong></p><h2 id="2若二叉树（每个节点值为单个字符）的中序遍历序列是abcdef，且c为根节点，则（-）。"><a href="#2若二叉树（每个节点值为单个字符）的中序遍历序列是abcdef，且c为根节点，则（-）。" class="headerlink" title="2若二叉树（每个节点值为单个字符）的中序遍历序列是abcdef，且c为根节点，则（ ）。"></a>2若二叉树（每个节点值为单个字符）的<a href="https://so.csdn.net/so/search?q=%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86&spm=1001.2101.3001.7020">中序遍历</a>序列是abcdef，且c为根节点，则（ ）。</h2><p>A.节点c有两个孩子<br>B.以上都不对<br>C.二叉树有两个度为0的节点<br>D.二叉树的高度为5<br>正确答案：A<br>解析： A、从中序序列看出，节点c的左右子树均不空。</p><p><strong>课本考据：中序遍历过程（1、中序遍历左子树。2、访问根节点。3、中序遍历右子树）。</strong></p><h2 id="3若知道一棵二叉树的（-），便可以唯一确定该二叉树。"><a href="#3若知道一棵二叉树的（-），便可以唯一确定该二叉树。" class="headerlink" title="3若知道一棵二叉树的（ ），便可以唯一确定该二叉树。"></a>3若知道一棵二叉树的（ ），便可以唯一确定该二叉树。</h2><p>A.先序序列<br>B.中序和后序序列<br>C.先序和后序序列<br>D.中序序列<br>正确答案：B</p><p><strong>课本考据：任何n个不同结点的二叉树，都可由它的中序序列和先序序列（中序序列和后序序列）唯一地确定。</strong></p><h2 id="4‍一棵二叉树的先序遍历序列为ABCDEFG，它的中序遍历序列可能是（-）。"><a href="#4‍一棵二叉树的先序遍历序列为ABCDEFG，它的中序遍历序列可能是（-）。" class="headerlink" title="4‍一棵二叉树的先序遍历序列为ABCDEFG，它的中序遍历序列可能是（ ）。"></a>4‍一棵二叉树的先序遍历序列为ABCDEFG，它的中序遍历序列可能是（ ）。</h2><p>A.ADCFEG<br>B.ABCDEFG<br>C.CABDEFG<br>D.DACEFBG<br>正确答案：B<br>解析： B、当一棵二叉树所有节点的左子树为空时，先序遍历序列和中序遍历序列相同。先序序列和中序序列可以确定一棵二叉树，这里由选项A、C和D的中序序列无法确定一棵二叉树。</p><p><strong>课本考据：先序遍历过程（1、先访问根节点。2、先序遍历左子树。3、先序遍历后子树）。</strong></p><h2 id="5‌一棵二叉树的先序遍历序列为ABCDEF，中序遍历序列为CBAEDF，则后序遍历序列为（-）"><a href="#5‌一棵二叉树的先序遍历序列为ABCDEF，中序遍历序列为CBAEDF，则后序遍历序列为（-）" class="headerlink" title="5‌一棵二叉树的先序遍历序列为ABCDEF，中序遍历序列为CBAEDF，则后序遍历序列为（ ）"></a>5‌一棵二叉树的先序遍历序列为ABCDEF，中序遍历序列为CBAEDF，则后序遍历序列为（ ）</h2><p>A.FEDCBA<br>B.不确定<br>C.CBEFDA<br>D.CBEDFA<br>正确答案：C</p><p><strong>课本考据：后序遍历过程（1、后序遍历左子树。2、后序遍历右子树。3、访问根结点）。</strong></p><h2 id="6某棵二叉树中，X节点有左孩子Y节点，则在其先序遍历中（-）。"><a href="#6某棵二叉树中，X节点有左孩子Y节点，则在其先序遍历中（-）。" class="headerlink" title="6某棵二叉树中，X节点有左孩子Y节点，则在其先序遍历中（ ）。"></a>6某棵二叉树中，X节点有左孩子Y节点，则在其先序遍历中（ ）。</h2><p>A.访问X节点后，接着遍历Y节点的左子树，然后访问Y节点<br>B.访问Y节点后立即访问X节点<br>C.访问X节点后立即访问Y节点<br>D.访问Y节点后，接着遍历Y节点的左子树，然后访问X节点<br>正确答案：C<br>解析： C、其先序遍历序列为…XY…。</p><h2 id="7关于二叉树（含2个以上的节点）的先序遍历序列中，以下正确的是（-）。"><a href="#7关于二叉树（含2个以上的节点）的先序遍历序列中，以下正确的是（-）。" class="headerlink" title="7关于二叉树（含2个以上的节点）的先序遍历序列中，以下正确的是（ ）。"></a>7关于二叉树（含2个以上的节点）的先序遍历序列中，以下正确的是（ ）。</h2><p>A.以上都不对<br>B.先序遍历序列的最后一个节点一定是叶子节点<br>C.先序遍历序列的最后一个节点是根节点<br>D.先序遍历序列的第一个节点一定是叶子节点<br>正确答案：B<br>解析： B、先序遍历过程是：NLR，最后访问的节点的L、R均为空，所以为叶子节点。</p><h2 id="8若一棵完全二叉树中每个节点值为单个字符，其后序遍历序列为CDBFGEA，则其先序遍历序列是（-）。"><a href="#8若一棵完全二叉树中每个节点值为单个字符，其后序遍历序列为CDBFGEA，则其先序遍历序列是（-）。" class="headerlink" title="8若一棵完全二叉树中每个节点值为单个字符，其后序遍历序列为CDBFGEA，则其先序遍历序列是（ ）。"></a>8若一棵完全二叉树中每个节点值为单个字符，其后序遍历序列为CDBFGEA，则其先序遍历序列是（ ）。</h2><p>A.ABCDEFG<br>B.ABECDFG<br>C.CBDAFEG<br>D.无法确定<br>正确答案：A</p><h2 id="9‏任何一棵二叉树的叶子节点在先序、中序和后序遍历序列中的相对次序（-）。"><a href="#9‏任何一棵二叉树的叶子节点在先序、中序和后序遍历序列中的相对次序（-）。" class="headerlink" title="9‏任何一棵二叉树的叶子节点在先序、中序和后序遍历序列中的相对次序（ ）。"></a>9‏任何一棵二叉树的叶子节点在先序、中序和后序遍历序列中的相对次序（ ）。</h2><p>A.不能确定<br>B.相同<br>C.不相同<br>D.以上都不对<br>正确答案：B<br>解析： B、这三种遍历都是从左向右进行的，先序遍历：根左右，中序遍历：左根右，后序遍历：左右根，对于叶子节点，其左、右均为空，所以在这三种序列中叶子节点总是从左向右的。</p><h2 id="10若二叉树采用二叉链存储结构，要删除该二叉链中所有节点并释放它们占用的空间，利用（-）遍历方法最合适。"><a href="#10若二叉树采用二叉链存储结构，要删除该二叉链中所有节点并释放它们占用的空间，利用（-）遍历方法最合适。" class="headerlink" title="10若二叉树采用二叉链存储结构，要删除该二叉链中所有节点并释放它们占用的空间，利用（ ）遍历方法最合适。"></a>10若二叉树采用二叉链存储结构，要删除该二叉链中所有节点并释放它们占用的空间，利用（ ）遍历方法最合适。</h2><p>A.先序<br>B.中序<br>C.层次<br>D.后序<br>正确答案：D<br>解析： D、先释放左子树的空间，再释放右子树的空间，最后释放根节点的空间。</p><h2 id="11‌判断线索二叉树中p节点为叶子节点的条件是（-）。"><a href="#11‌判断线索二叉树中p节点为叶子节点的条件是（-）。" class="headerlink" title="11‌判断线索二叉树中p节点为叶子节点的条件是（ ）。"></a>11‌判断线索二叉树中p节点为叶子节点的条件是（ ）。</h2><p>A.p-&gt;lchildNULL &amp;&amp; p-&gt;rchildNULL<br>B.p-&gt;ltag0 &amp;&amp; p-&gt;rtag0<br>C.p-&gt;ltag1 &amp;&amp; p-&gt;rtag1<br>D.p-&gt;ltag&#x3D;&#x3D;1<br>正确答案：C<br>解析： C、p节点左、右指针均为线索，表示它们原来都为空，即为叶子节点。</p><p><strong>课本考据：遍历某种次序的线索二叉树就是从该次序下的开始结点出发，反复周到该结点在该次序下的后继结点，直到头结点。在中序线索二叉树中，开始结点是根结点的最左下结点，该结点的左指针域韦线索（指向头结点的线索），即ltag&#x3D;1。</strong></p><h2 id="12‌n个节点的线索二叉树上含有的线索个数为（-）。"><a href="#12‌n个节点的线索二叉树上含有的线索个数为（-）。" class="headerlink" title="12‌n个节点的线索二叉树上含有的线索个数为（ ）。"></a>12‌n个节点的线索二叉树上含有的线索个数为（ ）。</h2><p>A.n<br>B.n-1<br>C.n+1<br>D.2n<br>正确答案：C<br>解析： C、n个节点的指针域个数为2n，指向孩子的指针域个数为n-1，所以线索个数&#x3D;2n-(n-1)&#x3D;n+1。</p><h2 id="13设有一棵哈夫曼树的节点总数为35，则该哈夫曼树共有（-）个叶子节点。"><a href="#13设有一棵哈夫曼树的节点总数为35，则该哈夫曼树共有（-）个叶子节点。" class="headerlink" title="13设有一棵哈夫曼树的节点总数为35，则该哈夫曼树共有（ ）个叶子节点。"></a>13设有一棵哈夫曼树的节点总数为35，则该哈夫曼树共有（ ）个叶子节点。</h2><p>A.20<br>B.18<br>C.30<br>D.35<br>正确答案：B<br>解析： B、2n0-1&#x3D;35，则n0&#x3D;18。</p><p><strong>课本考据：n&#x3D;35，n1&#x3D;0，n0&#x3D;n2+1，n&#x3D;n0+n2&#x3D;2n0-1，即n0&#x3D;(n+1)&#x2F;2。</strong></p><h2 id="14‍根据使用频率为5个字符设计的哈夫曼编码不可能是（-）。"><a href="#14‍根据使用频率为5个字符设计的哈夫曼编码不可能是（-）。" class="headerlink" title="14‍根据使用频率为5个字符设计的哈夫曼编码不可能是（ ）。"></a>14‍根据使用频率为5个字符设计的哈夫曼编码不可能是（ ）。</h2><p>A.000，001，010，011，1<br>B.111，110，10，01，00<br>C.001，000，01，11，10<br>D.100，11，10，1，0<br>正确答案：D<br>解析： D、在选项D中，10和100冲突，10是100的前缀，即一个节点既是叶子节点又是内部节点，哈夫曼树中不可能出现这种情况。</p><p><strong>课本考据：在一组字符的哈夫曼编码中，任一字符的哈夫曼编码不可能是另一字符哈夫曼编码的前缀。</strong></p><h2 id="15‏下面关于哈夫曼树的说法，错误的是（-）。"><a href="#15‏下面关于哈夫曼树的说法，错误的是（-）。" class="headerlink" title="15‏下面关于哈夫曼树的说法，错误的是（ ）。"></a>15‏下面关于哈夫曼树的说法，错误的是（ ）。</h2><p>A.哈夫曼树中除了度为1的节点外，还有度为2的节点和叶子节点<br>B.哈夫曼树中没有度为1的节点<br>C.哈夫曼树具有最小带权路径长度<br>D.对应于一组权值构造出的哈夫曼树可能不是唯一的<br>正确答案：A<br>解析： A、哈夫曼树中没有度为1的节点，只有度为2的节点和叶子节点。</p><p><strong>课本考据：在森林F中选取两颗结点的全职最小的子树分别作为左、右子树构造一颗新的二叉树，并且置新的二叉树的根结点的权值为其左右子树上根的权值之和。</strong></p><h1 id="第十周测验"><a href="#第十周测验" class="headerlink" title="第十周测验"></a>第十周测验</h1><h2 id="1‌在一个具有n个顶点的无向连通图中至少有（-）条边。"><a href="#1‌在一个具有n个顶点的无向连通图中至少有（-）条边。" class="headerlink" title="1‌在一个具有n个顶点的无向连通图中至少有（ ）条边。"></a>1‌在一个具有n个顶点的无向<a href="https://so.csdn.net/so/search?q=%E8%BF%9E%E9%80%9A%E5%9B%BE&spm=1001.2101.3001.7020">连通图</a>中至少有（ ）条边。</h2><p>A.n&#x2F;2<br>B.n+1<br>C.n-1<br>D.n<br>正确答案：C<br>解析： C、树图是边数最少的连通图，其边数&#x3D;n-1。</p><p><strong>课本考据：1、在无向图G中，若从顶点i到顶点j有路径，则称顶点i和顶点j是连通的。2、若图G中的任意两个顶点多是连通的，则称G为连通图。</strong></p><h2 id="2‏设G是一个含有6个顶点的无向图，该图至多有（-）条边。"><a href="#2‏设G是一个含有6个顶点的无向图，该图至多有（-）条边。" class="headerlink" title="2‏设G是一个含有6个顶点的无向图，该图至多有（ ）条边。"></a>2‏设G是一个含有6个顶点的<a href="https://so.csdn.net/so/search?q=%E6%97%A0%E5%90%91%E5%9B%BE&spm=1001.2101.3001.7020">无向图</a>，该图至多有（ ）条边。</h2><p>A.6<br>B.15<br>C.7<br>D.5<br>正确答案：B<br>解析： B、边数最多时为完全无向图，有n(n-1)&#x2F;2&#x3D;15条边。</p><p><strong>课本考据：若无向图中的每两个顶点之间都存在者一条边，有向图中的每两个顶点之间都存在着方向相反的两条边，则称此图为完全有向图。无向完全图包含有n(n-1)&#x2F;2条边，有向完全图包含有n(n-1)条边。</strong></p><h2 id="3在一个具有n个顶点的有向图中，构成强连通图时至少有（-）条边。"><a href="#3在一个具有n个顶点的有向图中，构成强连通图时至少有（-）条边。" class="headerlink" title="3在一个具有n个顶点的有向图中，构成强连通图时至少有（ ）条边。"></a>3在一个具有n个顶点的<a href="https://so.csdn.net/so/search?q=%E6%9C%89%E5%90%91%E5%9B%BE&spm=1001.2101.3001.7020">有向图</a>中，构成强连通图时至少有（ ）条边。</h2><p>A.n-1<br>B.n+1<br>C.n<br>D.n&#x2F;2<br>正确答案：C<br>解析： C、边数最少的有向强连通图是一个环，其边数&#x3D;n。</p><p><strong>课本考据：在有向图G中若从顶点i到顶点j有路径，则称从顶点i到顶点j是连通的。若图G中的任意两个顶点i和j都，即从顶点i到顶点j和顶点j到顶点i都有路径，则称图G是强连图。</strong></p><h2 id="4‏以下关于有向图的说法中，正确的是（-）。"><a href="#4‏以下关于有向图的说法中，正确的是（-）。" class="headerlink" title="4‏以下关于有向图的说法中，正确的是（ ）。"></a>4‏以下关于有向图的说法中，正确的是（ ）。</h2><p>A.强连通图是任何顶点到其他所有顶点都有边<br>B.以上都不对<br>C.有向图中任一顶点的入度等于出度<br>D.完全有向图一定是强连通图<br>正确答案：D<br>解析： D、强连通图是任何顶点到其他所有顶点都有路径，所以选项A错误。有向图中一个顶点的入度不一定等于出度，所以选项C错误。完全有向图的任意两个顶点之间有边，一定是强连通图，所以选项D正确。</p><p><strong>课本考据：若无向图中的每两个顶点之间都存在着一条边，有向图中的每两个顶点之间都存在着方向相反的两条边，则称此图为完全图。</strong></p><h2 id="5非空无向图的邻接矩阵是一个（-）。"><a href="#5非空无向图的邻接矩阵是一个（-）。" class="headerlink" title="5非空无向图的邻接矩阵是一个（ ）。"></a>5非空无向图的邻接矩阵是一个（ ）。</h2><p>A.上三角矩阵<br>B.对称矩阵<br>C.对角矩阵<br>D.零矩阵<br>正确答案：B</p><p><strong>课本考据：图的邻接矩阵是一种采用邻接矩阵数组表示顶点之间相邻关系的存储结构。无向图的邻接矩阵数组一定一个对称矩阵。</strong></p><h2 id="6‍一个图的邻接矩阵是对称矩阵，则该图是（-）。"><a href="#6‍一个图的邻接矩阵是对称矩阵，则该图是（-）。" class="headerlink" title="6‍一个图的邻接矩阵是对称矩阵，则该图是（ ）。"></a>6‍一个图的邻接矩阵是对称矩阵，则该图是（ ）。</h2><p>A.以上都不对<br>B.有向图<br>C.无向图<br>D.无向图或有向图<br>正确答案：D<br>解析： D、有向图的邻接矩阵也可能是对称矩阵，如强连通图。</p><h2 id="7在含有n个顶点e条边的不带权无向图的邻接矩阵中，零元素的个数为（-）。"><a href="#7在含有n个顶点e条边的不带权无向图的邻接矩阵中，零元素的个数为（-）。" class="headerlink" title="7在含有n个顶点e条边的不带权无向图的邻接矩阵中，零元素的个数为（ ）。"></a>7在含有n个顶点e条边的不带权无向图的邻接矩阵中，零元素的个数为（ ）。</h2><p>A.e<br>B.n2-2e<br>C.n2-e<br>D.2e<br>正确答案：B<br>解析： B、在含有n个顶点e条边的不带权无向图的邻接矩阵中，为0的元素恰好2e个，其他为0元素。</p><h2 id="8‍若用邻接矩阵表示一个含有n个顶点不带权的有向图，则其中第i（0≤i≤n-1）列中包含的1的个数为（-）。"><a href="#8‍若用邻接矩阵表示一个含有n个顶点不带权的有向图，则其中第i（0≤i≤n-1）列中包含的1的个数为（-）。" class="headerlink" title="8‍若用邻接矩阵表示一个含有n个顶点不带权的有向图，则其中第i（0≤i≤n-1）列中包含的1的个数为（ ）。"></a>8‍若用邻接矩阵表示一个含有n个顶点不带权的有向图，则其中第i（0≤i≤n-1）列中包含的1的个数为（ ）。</h2><p>A.图中顶点i的入度<br>B.图中顶点i的出度<br>C.图中边的数目<br>D.图中强连通分量的数目<br>正确答案：A<br>解析： A、不带权有向图的邻接矩阵表示中，第i（0≤i≤n-1）行中包含的1的个数为顶点i的出度，第i列行中包含的1的个数为顶点i的入度。</p><p><strong>课本考据：在有向图中顶点的度分为入度和出度，以顶点j为终点的边数目，称为改顶点的入度。以顶点i为起点的边数目，称为改顶点的出度。</strong></p><h2 id="9一个图的邻接表表示中有奇数个边节点，则该图是（-）。"><a href="#9一个图的邻接表表示中有奇数个边节点，则该图是（-）。" class="headerlink" title="9一个图的邻接表表示中有奇数个边节点，则该图是（ ）。"></a>9一个图的邻接表表示中有奇数个边节点，则该图是（ ）。</h2><p>A.以上都不对<br>B.无向图或有向图<br>C.无向图<br>D.有向图<br>正确答案：D<br>解析： D、对于含有e条边的无向图，其邻接表表示中恰好有2e个边节点，所以一个图的邻接表表示中有奇数个边节点，则它一定是有向图。</p><h2 id="10‏以下叙述中错误的是（-）。"><a href="#10‏以下叙述中错误的是（-）。" class="headerlink" title="10‏以下叙述中错误的是（ ）。"></a>10‏以下叙述中错误的是（ ）。</h2><p>A.图的深度优先遍历算法是一个递归过程<br>B.图的深度优先遍历算法适合无向图<br>C.图的广度优先遍历算法适合有向图<br>D.图的深度优先遍历算法不适合有向图<br>正确答案：D<br>解析： D、图的深度优先遍历算法既适合无向图也适合有向图的遍历。</p><h2 id="11如果从无向图的任一顶点出发进行一次广度优先遍历即可访问所有顶点，则该图一定是（-）。"><a href="#11如果从无向图的任一顶点出发进行一次广度优先遍历即可访问所有顶点，则该图一定是（-）。" class="headerlink" title="11如果从无向图的任一顶点出发进行一次广度优先遍历即可访问所有顶点，则该图一定是（ ）。"></a>11如果从无向图的任一顶点出发进行一次广度优先遍历即可访问所有顶点，则该图一定是（ ）。</h2><p>A.一棵树<br>B.连通图<br>C.完全图<br>D.有回路<br>正确答案：B<br>解析： B、对于无向图，从其中任一顶点出发进行一次广度优先遍历能够访问所有的顶点，表示所有顶点之间都有路径，所以它是连通图。</p><h2 id="12‌对有n个顶点、e条边且使用邻接表存储的有向图进行深度优先遍历，其算法的时间复杂度是（-）。"><a href="#12‌对有n个顶点、e条边且使用邻接表存储的有向图进行深度优先遍历，其算法的时间复杂度是（-）。" class="headerlink" title="12‌对有n个顶点、e条边且使用邻接表存储的有向图进行深度优先遍历，其算法的时间复杂度是（ ）。"></a>12‌对有n个顶点、e条边且使用邻接表存储的有向图进行深度优先遍历，其算法的时间复杂度是（ ）。</h2><p>A.O(n)<br>B.O(e)<br>C.O(n*e)<br>D.O(n+e)<br>正确答案：D<br>解析： D、使用邻接表存储时，深度优先遍历过程恰好访问所有的头节点和边节点一次。</p><h2 id="13‌对有n个顶点、e条边且使用邻接矩阵存储的有向图进行广度优先遍历，其算法的时间复杂度是（-）。"><a href="#13‌对有n个顶点、e条边且使用邻接矩阵存储的有向图进行广度优先遍历，其算法的时间复杂度是（-）。" class="headerlink" title="13‌对有n个顶点、e条边且使用邻接矩阵存储的有向图进行广度优先遍历，其算法的时间复杂度是（ ）。"></a>13‌对有n个顶点、e条边且使用邻接矩阵存储的有向图进行广度优先遍历，其算法的时间复杂度是（ ）。</h2><p>A.O(n2)<br>B.O(nlog2n)<br>C.O(n*e)<br>D.O(n)<br>正确答案：A<br>解析： A、使用邻接矩阵存储时，广度优先遍历过程中找相邻的时间复杂度为O(n)，另要循环n次处理每个顶点。</p><h2 id="14‏一个有向图G-x3D-V，E-，V-x3D-0，1，2，3，4-，‏E-x3D-lt-0，1-gt-，-lt-1，2-gt-，-lt-0，3-gt-，-lt-1，2-gt-，-lt-1，4-gt-，-lt-2，4-gt-，-lt-4，3-gt-，‏现按深度优先遍历算法遍历，从顶点0出发，所得到的顶点序列是（-）。"><a href="#14‏一个有向图G-x3D-V，E-，V-x3D-0，1，2，3，4-，‏E-x3D-lt-0，1-gt-，-lt-1，2-gt-，-lt-0，3-gt-，-lt-1，2-gt-，-lt-1，4-gt-，-lt-2，4-gt-，-lt-4，3-gt-，‏现按深度优先遍历算法遍历，从顶点0出发，所得到的顶点序列是（-）。" class="headerlink" title="14‏一个有向图G&#x3D;(V，E)，V&#x3D;{0，1，2，3，4}，‏E&#x3D;{&lt;0，1&gt;，&lt;1，2&gt;，&lt;0，3&gt;，&lt;1，2&gt;，&lt;1，4&gt;，&lt;2，4&gt;，&lt;4，3&gt;}，‏现按深度优先遍历算法遍历，从顶点0出发，所得到的顶点序列是（ ）。"></a>14‏一个有向图G&#x3D;(V，E)，V&#x3D;{0，1，2，3，4}，‏E&#x3D;{&lt;0，1&gt;，&lt;1，2&gt;，&lt;0，3&gt;，&lt;1，2&gt;，&lt;1，4&gt;，&lt;2，4&gt;，&lt;4，3&gt;}，‏现按深度优先遍历算法遍历，从顶点0出发，所得到的顶点序列是（ ）。</h2><p>A.0，1，3，4，2<br>B.0，1，2，3，4<br>C.0，1，4，2，3<br>D.0，1，2，4，3<br>正确答案：D</p><h2 id="15‍以下关于广度优先遍历的叙述中正确的是（-）。"><a href="#15‍以下关于广度优先遍历的叙述中正确的是（-）。" class="headerlink" title="15‍以下关于广度优先遍历的叙述中正确的是（ ）。"></a>15‍以下关于广度优先遍历的叙述中正确的是（ ）。</h2><p>A.对任何有向图调用一次广度优先遍历算法便可访问所有的顶点<br>B.对任何非强连通图必须2次或以上调用广度优先遍历算法才可访问所有的顶点<br>C.对一个强连通图调用一次广度优先遍历算法便可访问所有的顶点<br>D.广度优先遍历不适合有向图<br>正确答案：C<br>解析： C、强连通图中任何两个顶点之间都有路径，所以调用一次广度优先遍历算法便可访问所有的顶点。</p><h1 id="第十一周测验"><a href="#第十一周测验" class="headerlink" title="第十一周测验"></a>第十一周测验</h1><h2 id="1‍一个无向连通图的生成树是含有该连通图的全部顶点的（-）。"><a href="#1‍一个无向连通图的生成树是含有该连通图的全部顶点的（-）。" class="headerlink" title="1‍一个无向连通图的生成树是含有该连通图的全部顶点的（ ）。"></a>1‍一个无向<a href="https://so.csdn.net/so/search?q=%E8%BF%9E%E9%80%9A%E5%9B%BE&spm=1001.2101.3001.7020">连通图</a>的生成树是含有该连通图的全部顶点的（ ）。</h2><p>A.极大连通子图<br>B.极大子图<br>C.极小连通子图<br>D.极小子图<br>正确答案：C</p><p><strong>课本考据：一个连通图的生成树是一个极小连通子图，其中含有图中的全部顶点和构成一颗树的（n-1）条边。</strong></p><h2 id="2任何一个非空带权无向连通图（-）最小生成树。"><a href="#2任何一个非空带权无向连通图（-）最小生成树。" class="headerlink" title="2任何一个非空带权无向连通图（ ）最小生成树。"></a>2任何一个非空带权无向连通图（ ）最小<a href="https://so.csdn.net/so/search?q=%E7%94%9F%E6%88%90%E6%A0%91&spm=1001.2101.3001.7020">生成树</a>。</h2><p>A.可能不存在<br>B.一定有多棵<br>C.有一棵或多棵<br>D.只有一棵<br>正确答案：C</p><p><strong>课本考据：一个连通图的生成树不一定是唯一的。</strong></p><h2 id="3用Prim算法求一个连通的带权图的最小代价生成树，在算法执行的某时刻，已选取的顶点集合U＝-1，2，3-已选取的边的集合TE＝-1，2-，-2，3-要选取下一条权值最小的边，应当从（-）组中选取。"><a href="#3用Prim算法求一个连通的带权图的最小代价生成树，在算法执行的某时刻，已选取的顶点集合U＝-1，2，3-已选取的边的集合TE＝-1，2-，-2，3-要选取下一条权值最小的边，应当从（-）组中选取。" class="headerlink" title="3用Prim算法求一个连通的带权图的最小代价生成树，在算法执行的某时刻，已选取的顶点集合U＝{1，2，3}已选取的边的集合TE＝{(1，2)，(2，3)}要选取下一条权值最小的边，应当从（ ）组中选取。"></a>3用Prim算法求一个连通的带权图的最小代价生成树，在算法执行的某时刻，已选取的顶点集合U＝{1，2，3}已选取的边的集合TE＝{(1，2)，(2，3)}要选取下一条权值最小的边，应当从（ ）组中选取。</h2><p>A.{(3，4)，(3，5)，(4，5)，(1，4)}<br>B.{(1，4)，(3，4)，(3，5)，(2，5)}<br>C.{(1，2)，(2，3)，(3，5)}<br>D.{(4，5)，(1，3)，(3，5)}<br>正确答案：B<br>解析： B、U&#x3D;{1，2，3}，V-U&#x3D;{4，5，…}，候选边只能是这两个顶点集之间的边。</p><h2 id="4对某个带权连通图构造最小生成树，以下说法中正确的是（-）。"><a href="#4对某个带权连通图构造最小生成树，以下说法中正确的是（-）。" class="headerlink" title="4对某个带权连通图构造最小生成树，以下说法中正确的是（ ）。"></a>4对某个带权连通图构造最小生成树，以下说法中正确的是（ ）。</h2><p>Ⅰ.该图的所有最小生成树的总代价一定是唯一的<br>Ⅱ.其所有权值最小的边一定会出现在所有的最小生成树中‏<br>Ⅲ.用普里姆（Prim）算法从不同顶点开始构造的所有最小生成树一定相同<br>‍Ⅳ.使用普里姆算法和克鲁斯卡尔（Kruskal）算法得到的最小生成树总不相同</p><p>A.仅Ⅰ、Ⅲ<br>B.仅Ⅱ、Ⅳ<br>C.仅Ⅰ<br>D.仅Ⅱ<br>正确答案：C<br>解析： C、由一个带权连通图构造的最小生成树可能有多棵，但其代价一定是唯一的；权值最小的边可能不唯一，这些不唯一的最小权值边不一定都会出现在所有的最小生成树中；当存在多条权值相同的边时，用普里姆（Prim）算法从不同顶点开始得到的最小生成树不一定相同；使用普里姆算法和克鲁斯卡尔（Kruskal）算法得到的最小生成树不一定总不相同，如图中最小生成树唯一时，无论用哪种算法，得到的最小生成树都是相同的。</p><h2 id="5用Kruskal算法求一个连通的带权图的最小代价生成树，在算法执行的某时刻，已选取的边集合TE＝-1，2-，-2，3-，-3，5-要选取下一条权值最小的边，不可能选取的边是（-）。"><a href="#5用Kruskal算法求一个连通的带权图的最小代价生成树，在算法执行的某时刻，已选取的边集合TE＝-1，2-，-2，3-，-3，5-要选取下一条权值最小的边，不可能选取的边是（-）。" class="headerlink" title="5用Kruskal算法求一个连通的带权图的最小代价生成树，在算法执行的某时刻，已选取的边集合TE＝{(1，2)，(2，3)，(3，5)},要选取下一条权值最小的边，不可能选取的边是（ ）。"></a>5用Kruskal算法求一个连通的带权图的最小代价生成树，在算法执行的某时刻，已选取的边集合TE＝{(1，2)，(2，3)，(3，5)},要选取下一条权值最小的边，不可能选取的边是（ ）。</h2><p>A.(1，4)<br>B.(1，3)<br>C.(2，4)<br>D.(3，6)<br>正确答案：B<br>解析： B、选取(1，3)边会构成回路。</p><p><strong>课本考据：克鲁斯卡尔（Kruskal）算法是一种按权值的递增次序选择合适的边来构造最小生成树的方法。</strong></p><h2 id="6在用Prim和Kruskal算法构造最小生成树时，前者更适合于（）。"><a href="#6在用Prim和Kruskal算法构造最小生成树时，前者更适合于（）。" class="headerlink" title="6在用Prim和Kruskal算法构造最小生成树时，前者更适合于（）。"></a>6在用Prim和Kruskal算法构造最小生成树时，前者更适合于（）。</h2><p>A.无向图<br>B.稠密图<br>C.有向图<br>D.稀疏图<br>正确答案：B<br>解析： B、Prim算法的时间复杂度为O(n2)，Kruskal算法的时间复杂度为O(elog2e)。</p><p><strong>课本考据：prim算法的执行时间与图中边数e无关，所以它特别适合用稠密图最小生成树。</strong></p><h2 id="7‏Dijkstra算法是（-）方法求出图中从某点到其余顶点最短路径的。"><a href="#7‏Dijkstra算法是（-）方法求出图中从某点到其余顶点最短路径的。" class="headerlink" title="7‏Dijkstra算法是（ ）方法求出图中从某点到其余顶点最短路径的。"></a>7‏Dijkstra算法是（ ）方法求出图中从某点到其余顶点最短路径的。</h2><p>A.按长度递增的顺序求出图的某顶点到其余顶点的最短路径<br>B.按长度递减的顺序求出图的某顶点到其余顶点的最短路径<br>C.通过广度优先遍历求出图中某顶点到其余顶点的最短路径<br>D.通过深度优先遍历求出图中某顶点到其余顶点的最短路径<br>正确答案：A<br>解析： A、Dijkstra算法是一种贪心算法，按长度递增的顺序求出图的某顶点到其余顶点的最短路径。</p><h2 id="8用Dijkstra算法求一个带权有向图G中从顶点0出发的最短路径，在算法执行的某时刻：S-x3D-0，2，3，4-下一步选取的目标顶点可能是（-）。"><a href="#8用Dijkstra算法求一个带权有向图G中从顶点0出发的最短路径，在算法执行的某时刻：S-x3D-0，2，3，4-下一步选取的目标顶点可能是（-）。" class="headerlink" title="8用Dijkstra算法求一个带权有向图G中从顶点0出发的最短路径，在算法执行的某时刻：S&#x3D;{0，2，3，4}下一步选取的目标顶点可能是（ ）。"></a>8用Dijkstra算法求一个带权有向图G中从顶点0出发的最短路径，在算法执行的某时刻：S&#x3D;{0，2，3，4}下一步选取的目标顶点可能是（ ）。</h2><p>A.顶点7<br>B.顶点4<br>C.顶点2<br>D.顶点3<br>正确答案：A<br>解析： A、下一步只能选取V-S中的顶点。</p><h2 id="9用Dijkstra算法求一个带权有向图G中从顶点0出发的最短路径，在算法执行的某时刻：‎S-x3D-0，2，3，4-，选取的目标顶点是顶点1‎则可能修改最短路径是（-）。"><a href="#9用Dijkstra算法求一个带权有向图G中从顶点0出发的最短路径，在算法执行的某时刻：‎S-x3D-0，2，3，4-，选取的目标顶点是顶点1‎则可能修改最短路径是（-）。" class="headerlink" title="9用Dijkstra算法求一个带权有向图G中从顶点0出发的最短路径，在算法执行的某时刻：‎S&#x3D;{0，2，3，4}，选取的目标顶点是顶点1‎则可能修改最短路径是（ ）。"></a>9用Dijkstra算法求一个带权有向图G中从顶点0出发的最短路径，在算法执行的某时刻：‎S&#x3D;{0，2，3，4}，选取的目标顶点是顶点1‎则可能修改最短路径是（ ）。</h2><p>A.从顶点0到顶点1的最短路径<br>B.从顶点2到顶点4的最短路径<br>C.从顶点0到顶点3的最短路径<br>D.从顶点0到顶点2的最短路径<br>正确答案：A<br>解析： A、只可能修改从顶点0到V-S中的某个顶点的最短路径。</p><h2 id="10‏对于n个顶点e条边的有向带权图，可以通过Dijkstra算法求出所有两个顶点之间的最短路径，此时的时间复杂度为（-）。"><a href="#10‏对于n个顶点e条边的有向带权图，可以通过Dijkstra算法求出所有两个顶点之间的最短路径，此时的时间复杂度为（-）。" class="headerlink" title="10‏对于n个顶点e条边的有向带权图，可以通过Dijkstra算法求出所有两个顶点之间的最短路径，此时的时间复杂度为（ ）。"></a>10‏对于n个顶点e条边的有向带权图，可以通过Dijkstra算法求出所有两个顶点之间的最短路径，此时的时间复杂度为（ ）。</h2><p>A.O(n2)<br>B.O(n)<br>C.O(nlog2n)<br>D.O(n*e)<br>正确答案：C<br>解析： C、对每个顶点调用一次Dijkstra算法求出所有两个顶点之间的最短路径，其时间复杂度为O(n3)。</p><h2 id="11‌有一个顶点编号为0～4的带权有向图G，现用Floyd算法求任意两个顶点之间的最短路径，在算法执行的某时刻，已考虑了0～2的顶点，现考虑顶点3，则以下叙述中正确的是（-）。"><a href="#11‌有一个顶点编号为0～4的带权有向图G，现用Floyd算法求任意两个顶点之间的最短路径，在算法执行的某时刻，已考虑了0～2的顶点，现考虑顶点3，则以下叙述中正确的是（-）。" class="headerlink" title="11‌有一个顶点编号为0～4的带权有向图G，现用Floyd算法求任意两个顶点之间的最短路径，在算法执行的某时刻，已考虑了0～2的顶点，现考虑顶点3，则以下叙述中正确的是（ ）。"></a>11‌有一个顶点编号为0～4的带权有向图G，现用Floyd算法求任意两个顶点之间的最短路径，在算法执行的某时刻，已考虑了0～2的顶点，现考虑顶点3，则以下叙述中正确的是（ ）。</h2><p>A.所有两个顶点之间的路径都可能被修改<br>B.只可能修改从顶点3到顶点0～2的最短路径<br>C.只可能修改从顶点0～2到顶点3的最短路径<br>D.只可能修改从顶点0～2到顶点4的最短路径<br>正确答案：A<br>解析： A、Floyd算法在考虑某个顶点时，任意两个顶点之间的路径都可能被修改。</p><h2 id="12‏设有一个不带权的有向图G-x3D-（V，E），‍‏V-x3D-a，b，c，d，e-‍‏E-x3D-lt-a，b-gt-，-lt-a，c-gt-，-lt-d，c-gt-，-lt-d，e-gt-，-lt-b，e-gt-，-lt-c，e-gt-‏对该图进行拓扑排序，以下序列中不是拓扑序列的是（-）。"><a href="#12‏设有一个不带权的有向图G-x3D-（V，E），‍‏V-x3D-a，b，c，d，e-‍‏E-x3D-lt-a，b-gt-，-lt-a，c-gt-，-lt-d，c-gt-，-lt-d，e-gt-，-lt-b，e-gt-，-lt-c，e-gt-‏对该图进行拓扑排序，以下序列中不是拓扑序列的是（-）。" class="headerlink" title="12‏设有一个不带权的有向图G&#x3D;（V，E），‍‏V&#x3D;{a，b，c，d，e}‍‏E&#x3D;{&lt;a，b&gt;，&lt;a，c&gt;，&lt;d，c&gt;，&lt;d，e&gt;，&lt;b，e&gt;，&lt;c，e&gt;},‏对该图进行拓扑排序，以下序列中不是拓扑序列的是（ ）。"></a>12‏设有一个不带权的有向图G&#x3D;（V，E），‍‏V&#x3D;{a，b，c，d，e}‍‏E&#x3D;{&lt;a，b&gt;，&lt;a，c&gt;，&lt;d，c&gt;，&lt;d，e&gt;，&lt;b，e&gt;，&lt;c，e&gt;},‏对该图进行拓扑排序，以下序列中不是拓扑序列的是（ ）。</h2><p>A.dabce<br>B.abcde<br>C.abdce<br>D.adcbe<br>正确答案：B<br>解析： B、可以画出该有向图，显然abcde不是正确的拓扑序列。</p><h2 id="13‏若一个有向图中的顶点不能排成一个拓扑序列，则可断定该有向图（-）。"><a href="#13‏若一个有向图中的顶点不能排成一个拓扑序列，则可断定该有向图（-）。" class="headerlink" title="13‏若一个有向图中的顶点不能排成一个拓扑序列，则可断定该有向图（ ）。"></a>13‏若一个有向图中的顶点不能排成一个拓扑序列，则可断定该有向图（ ）。</h2><p>A.是一个强连通图<br>B.含有顶点数目大于1的强连通分量<br>C.含有多个入度为0的顶点<br>D.是一棵树图<br>正确答案：B<br>解析： B、这个有向图中存在回路，该回路构成一个强连通分量或者强连通分量的一部分。</p><h2 id="14一个表示工程的AOE网中的关键路径（-）。"><a href="#14一个表示工程的AOE网中的关键路径（-）。" class="headerlink" title="14一个表示工程的AOE网中的关键路径（ ）。"></a>14一个表示工程的AOE网中的关键路径（ ）。</h2><p>A.可以有多条<br>B.可以没有<br>C.必须是唯一的<br>D.以上都不对<br>正确答案：A<br>解析： A、一个表示工程的AOE网中至少存在一条关键路径，也可以有多条关键路径。</p><h2 id="15‏对于AOE网的关键路径，以下叙述中正确的是（-）。"><a href="#15‏对于AOE网的关键路径，以下叙述中正确的是（-）。" class="headerlink" title="15‏对于AOE网的关键路径，以下叙述中正确的是（ ）。"></a>15‏对于AOE网的关键路径，以下叙述中正确的是（ ）。</h2><p>A.任何一个活动持续时间的改变可能会影响关键路径的改变<br>B.一个AOE网的多条关键路径的长度可以不相同<br>C.完成工程的最短时间是从源点到汇点的最短路径长度<br>D.任何一个关键活动提前完成，则整个工程也会提前完成<br>正确答案：A<br>解析： A、改变AOE网中任何一个活动的持续时间，需要重新计算关键活动，可能导致关键路径的改变。</p><h1 id="第十二周测验"><a href="#第十二周测验" class="headerlink" title="第十二周测验"></a>第十二周测验</h1><h2 id="1静态查找表和动态查找表的区别是（-）。"><a href="#1静态查找表和动态查找表的区别是（-）。" class="headerlink" title="1静态查找表和动态查找表的区别是（ ）。"></a>1静态查找表和动态查找表的区别是（ ）。</h2><p>A.所包含的数据元素的类型不同<br>B.施加其上的操作不同<br>C.它们的逻辑结构相同<br>D.以上都不对<br>正确答案：B<br>解析： B、<strong>若在查找的同时对表做修改操作（如插入和删除），则相应的查找表称之为动态查找表。若在查找中不涉及表的修改操作，则相应的查找表称之为静态查找表。</strong></p><h2 id="2顺序查找法适合于存储结构为（-）的线性表。"><a href="#2顺序查找法适合于存储结构为（-）的线性表。" class="headerlink" title="2顺序查找法适合于存储结构为（ ）的线性表。"></a>2<a href="https://so.csdn.net/so/search?q=%E9%A1%BA%E5%BA%8F%E6%9F%A5%E6%89%BE&spm=1001.2101.3001.7020">顺序查找</a>法适合于存储结构为（ ）的线性表。</h2><p>A.索引存储<br>B.顺序存储或链式存储<br>C.哈希存储<br>D.压缩存储<br>正确答案：B<br>解析： B、顺序查找可以从前向后或从后向前依次查找，既适合于顺序存储结构也适合于链式存储结构。</p><p><strong>课本考据：<br>1、线性表的顺序存储结构是把线性表中的所有元素按照其逻辑顺序依次存储到计算机存储器中指定存储位置开始的一块i连续的存储空间。<br>2、线性表的链式存储结构称为链表，其中每个存储结点不仅包含元素本身的信息（数据域），而且包含表示元素之间逻辑关系的信息。<br>3、线性表有顺序和链式两种存储结构。<br>4、索引存储结构是在存储数据的同时还建立附加的索引表。</strong></p><h2 id="3‍采用顺序查找方法查找长度为n的顺序表时，在等概率时成功查找的平均查找长度为（-）。"><a href="#3‍采用顺序查找方法查找长度为n的顺序表时，在等概率时成功查找的平均查找长度为（-）。" class="headerlink" title="3‍采用顺序查找方法查找长度为n的顺序表时，在等概率时成功查找的平均查找长度为（ ）。"></a>3‍采用顺序查找方法查找长度为n的顺序表时，在等概率时成功查找的平均查找长度为（ ）。</h2><p>A.n&#x2F;2<br>B.n<br>C.(n-1)&#x2F;2<br>D.(n+1)&#x2F;2<br>正确答案：D<br>解析： D、顺序查找时，元素ai需i次比较，成功查找的平均查找长度&#x3D;(1+2+…+n)&#x2F;n&#x3D;(n+1)&#x2F;2。</p><p><strong>课本考据：顺序查找方法在查找成功时的平均比较次数约为表长的一半。</strong></p><h2 id="4‏采用顺序查找方法查找长度为n的顺序表时，在等概率时不成功查找的平均查找长度为（-）。"><a href="#4‏采用顺序查找方法查找长度为n的顺序表时，在等概率时不成功查找的平均查找长度为（-）。" class="headerlink" title="4‏采用顺序查找方法查找长度为n的顺序表时，在等概率时不成功查找的平均查找长度为（ ）。"></a>4‏采用顺序查找方法查找长度为n的顺序表时，在等概率时不成功查找的平均查找长度为（ ）。</h2><p>A.n&#x2F;2<br>B.(n-1)&#x2F;2<br>C.n<br>D.(n+1)&#x2F;2<br>正确答案：C<br>解析： C、当查找的元素不在线性表中时，均需要n次元素之间的比较。</p><h2 id="5‏适合于折半查找的数据组织方式是（-）。"><a href="#5‏适合于折半查找的数据组织方式是（-）。" class="headerlink" title="5‏适合于折半查找的数据组织方式是（ ）。"></a>5‏适合于<a href="https://so.csdn.net/so/search?q=%E6%8A%98%E5%8D%8A%E6%9F%A5%E6%89%BE&spm=1001.2101.3001.7020">折半查找</a>的数据组织方式是（ ）。</h2><p>A.以链表存储的线性表<br>B.以顺序表存储的线性表<br>C.以顺序表存储的有序线性表<br>D.以链表存储的有序线性表<br>正确答案：C<br>解析： C、折半查找的数据必须是有序的。另外，折半查找中需要确定查找区间，这要求存储结构最好具有随机存取特性，而顺序表满足这个特性。</p><p><strong>课本考据：折半查找又称二分查找，要求线性表示有序表，即表中的元素按关键字有序。</strong></p><h2 id="6采用折半查找方法查找长度为n的线性表，当n很大时，在等概率时不成功查找的平均查找长度为（-）。"><a href="#6采用折半查找方法查找长度为n的线性表，当n很大时，在等概率时不成功查找的平均查找长度为（-）。" class="headerlink" title="6采用折半查找方法查找长度为n的线性表，当n很大时，在等概率时不成功查找的平均查找长度为（ ）。"></a>6采用折半查找方法查找长度为n的线性表，当n很大时，在等概率时不成功查找的平均查找长度为（ ）。</h2><p>A.O(log2n)<br>B.O(nlog2n)<br>C.O(n2)<br>D.O(n)<br>正确答案：A<br>解析： A、采用折半查找时，若n很大，对应的判定树可以看成是一棵满二叉树，失败节点（外部节点）集中在最下一层，落在每个失败节点时比较的次都均为log2n。</p><p><strong>课本考据：失败的折半查找的过程是经历了一条从判定树根到某个外部结点的路径，所需的关键字比较次数是该路径上内部结点的总数。</strong></p><h2 id="7设有100个元素的有序表，采用折半查找方法，在等概率时成功时最大的比较次数是（-）。"><a href="#7设有100个元素的有序表，采用折半查找方法，在等概率时成功时最大的比较次数是（-）。" class="headerlink" title="7设有100个元素的有序表，采用折半查找方法，在等概率时成功时最大的比较次数是（ ）。"></a>7设有100个元素的有序表，采用折半查找方法，在等概率时成功时最大的比较次数是（ ）。</h2><p>A.50<br>B.25<br>C.10<br>D.7<br>正确答案：D<br>解析： D、成功时最大比较次数为log2(n+1)（取上界）&#x3D; log2(101)（取上界）&#x3D;7。</p><p><strong>课本考据：一般情况下，判定树中度数小于2的结点只能在最下面的两层上（不计外部结点），所以n个结点的判定树高度和n个节点的完全二叉树高度相同，即为log2(n+1)。</strong></p><h2 id="8已知一个长度为16的顺序表，其元素按关键字有序排序，若采用折半查找法查找一个存在的元素，则比较的次数最多是（-）。"><a href="#8已知一个长度为16的顺序表，其元素按关键字有序排序，若采用折半查找法查找一个存在的元素，则比较的次数最多是（-）。" class="headerlink" title="8已知一个长度为16的顺序表，其元素按关键字有序排序，若采用折半查找法查找一个存在的元素，则比较的次数最多是（ ）。"></a>8已知一个长度为16的顺序表，其元素按关键字有序排序，若采用折半查找法查找一个存在的元素，则比较的次数最多是（ ）。</h2><p>A.7<br>B.4<br>C.5<br>D.6<br>正确答案：C<br>解析： C、n&#x3D;16，采用折半查找法查找一个存在的元素，即为成功查找。成功查找的最多比较次数&#x3D;log2(n+1)（取上界）&#x3D;log2(17)（取上界）&#x3D;5。</p><h2 id="9‌一个递增有序表为R-0…11-，采用折半查找方法进行查找，在一次不成功查找中，以下（-）是不可能的记录比较序列。"><a href="#9‌一个递增有序表为R-0…11-，采用折半查找方法进行查找，在一次不成功查找中，以下（-）是不可能的记录比较序列。" class="headerlink" title="9‌一个递增有序表为R[0…11]，采用折半查找方法进行查找，在一次不成功查找中，以下（ ）是不可能的记录比较序列。"></a>9‌一个递增有序表为R[0…11]，采用折半查找方法进行查找，在一次不成功查找中，以下（ ）是不可能的记录比较序列。</h2><p>A.R[5]、R[8]、R[6]、R[7]<br>B.R[5]、R[2]、R[3]<br>C.R[5]、R[8]、R[10]<br>D.R[5]、R[8]、R[6]<br>正确答案：C<br>解析： C、画出递增有序表R[0…11]采用折半查找对应的判定树，一次失败的查找必须到达某个外部节点，而R[5]、R[8]、R[10]序列没有到达任何外部节点。<br><img src="/../imgs/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%88%B7%E9%A2%98/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA54yq6ISa546L,size_20,color_FFFFFF,t_70,g_se,x_16.png" alt="在这里插入图片描述"><br><strong>课本考据：折半查找的基本思路是设R[low,high]是当前的查找区间，首先确定该区间的中点位置mid&#x3D;[(low+high)&#x2F;2]，然后将待查的k值与R[mid].key比较：<br>（1）若k&#x3D;R[mid].key，则查找成功并返回该元素的逻辑序号。<br>（2）若k&lt;R[mid].key，则由表的有序性可知R[mid…high].key均大于k，因此若表中存在关键字等于k的元素，则该元素必定是在位置mid左边的子表R[low…mid-1]中，故新的查找区间是左子表R[low…mid-1]。<br>（3）若k&gt;R[mid].key，则关键字为k的元素必在mid的右子表R[mid+1…high]中，即新的查找区间是右子表R[mid+1…high]。下一次查找是针对新的查找区间进行的。</strong></p><p><em><strong>综上所述，可以从初始的查找区间R[0…n-1]开始，每经过一次与当前查找区间的中点位置上的关键字比较，就可确定查找是否成功，不成功则当前的查找区间缩小一半。重复比较来确定查找成功与失败。</strong></em></p><h2 id="10‏对有3600个记录的索引顺序表（分块表）进行分块查找，最理想的块长是（-）"><a href="#10‏对有3600个记录的索引顺序表（分块表）进行分块查找，最理想的块长是（-）" class="headerlink" title="10‏对有3600个记录的索引顺序表（分块表）进行分块查找，最理想的块长是（ ）"></a>10‏对有3600个记录的索引顺序表（分块表）进行分块查找，最理想的块长是（ ）</h2><p>A.[log23600]<br>B.1800<br>C.60<br>D.1200<br>正确答案：C<br>解析： C、n&#x3D;3600，分块查找最理想的块长&#x3D;sqrt(n)&#x3D;sqrt(3600)&#x3D;60。</p><p><strong>课本考据：当s&#x3D;sqrt(n)时，ASL’blk取极小值sqrt(n)+1，即当采用顺序查找确定块时各块中的元素数选定为sqrt(n)时效果最佳。</strong></p><h2 id="11‌二叉排序中，按（-）遍历二叉排序得到的序列是一个有序序列。"><a href="#11‌二叉排序中，按（-）遍历二叉排序得到的序列是一个有序序列。" class="headerlink" title="11‌二叉排序中，按（ ）遍历二叉排序得到的序列是一个有序序列。"></a>11‌二叉排序中，按（ ）遍历二叉排序得到的序列是一个有序序列。</h2><p>A.中序<br>B.后序<br>C.先序<br>D.层次<br>正确答案：A<br>解析： A、二叉排序的中序遍历序列恰好是一个递增有序序列。</p><p><strong>二叉排序树（BST）的性质：<br>1、若根节点的左子树非空，则左子树上的所有结点关键字均小于根节点关键字。<br>2、若根节点的右子树非空，则右子树上的所有结点关键字均大于根结点关键字。<br>3、根结点的左右子树本身又各是一棵二叉排序树。<br>由性质可知，按中序遍历该树所得的中序序列是一个递增有序序列。</strong></p><h2 id="12‍在含有27个节点的二叉排序树上，查找关键字为35的节点，则依次比较的关键字有可能是（-）。"><a href="#12‍在含有27个节点的二叉排序树上，查找关键字为35的节点，则依次比较的关键字有可能是（-）。" class="headerlink" title="12‍在含有27个节点的二叉排序树上，查找关键字为35的节点，则依次比较的关键字有可能是（ ）。"></a>12‍在含有27个节点的二叉排序树上，查找关键字为35的节点，则依次比较的关键字有可能是（ ）。</h2><p>A.46，36，18，28，35<br>B.46，28，18，36，35<br>C.18，36，28，46，35<br>D.28，36，18，46，35<br>正确答案：A<br>解析： A、画出各选项对应的查找树，从中看到只有选项D对应的查找树构成一棵二叉排序树，可以作为一棵二叉排序树的一部分，其他查找树均不构成一棵二叉排序树。<br><img src="/../imgs/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%88%B7%E9%A2%98/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA54yq6ISa546L,size_20,color_FFFFFF,t_70,g_se,x_16-16877914901971.png" alt="在这里插入图片描述"></p><h2 id="13‍以下关于二叉排序树的叙述中正确的是（-）。"><a href="#13‍以下关于二叉排序树的叙述中正确的是（-）。" class="headerlink" title="13‍以下关于二叉排序树的叙述中正确的是（ ）。"></a>13‍以下关于二叉排序树的叙述中正确的是（ ）。</h2><p>A.在二叉排序树中进行查找，关键字的比较次数不超过节点数的一半<br>B.二叉排序树是动态树表，在插入新节点时会引起树的重新分裂和合并<br>C.对二叉排序树进行层次遍历可以得到一个有序序列<br>D.在构造二叉排序树时，若关键字序列有序，则二叉排序树的高度最大<br>正确答案：D<br>解析： D、选项A错误，二叉排序树中不存在重新分裂和合并操作。选项B错误，对二叉排序树进行中序遍历才可以得到一个有序序列。选项D错误，在二叉排序树中进行查找时关键字的比较次数可能达到n次。</p><h2 id="14有一棵含有8个节点的二叉排序树，其节点值为A～H，以下（-）是其后序遍历结果。"><a href="#14有一棵含有8个节点的二叉排序树，其节点值为A～H，以下（-）是其后序遍历结果。" class="headerlink" title="14有一棵含有8个节点的二叉排序树，其节点值为A～H，以下（ ）是其后序遍历结果。"></a>14有一棵含有8个节点的二叉排序树，其节点值为A～H，以下（ ）是其后序遍历结果。</h2><p>A.BCAEFDHG<br>B.BCAGEHFD<br>C.ADBCEGFH<br>D.BDACEFHG<br>正确答案：A<br>解析： A、该二叉排序树的中序序列为ABCDEFGH，后序序列应是A～H的出栈序列，其中选项A、B和D都不是合法的出栈序列，只有选项C是合法的出栈序列。</p><h2 id="15‍具有5层节点的AVL树至少有（-）个节点。"><a href="#15‍具有5层节点的AVL树至少有（-）个节点。" class="headerlink" title="15‍具有5层节点的AVL树至少有（ ）个节点。"></a>15‍具有5层节点的AVL树至少有（ ）个节点。</h2><p>A.17<br>B.10<br>C.12<br>D.15<br>正确答案：C<br>解析： C、设Nh表示高度为h的平衡二叉树中含有的最少节点数，有：N1&#x3D;1，N2&#x3D;2，Nh&#x3D;Nh-1+Nh-2+1由此，求出N5&#x3D;12。</p><h2 id="16以下关于m阶B-树的叙述中正确的是（-）。"><a href="#16以下关于m阶B-树的叙述中正确的是（-）。" class="headerlink" title="16以下关于m阶B-树的叙述中正确的是（ ）。"></a>16以下关于m阶B-树的叙述中正确的是（ ）。</h2><p>A.树中每个节点至多有ém&#x2F;2ù-1个关键字<br>B.当插入一个关键字引起B-树节点分裂时，树增高一层<br>C.所有叶子节点均在同一层上<br>D.每个节点至少有两棵非空子树<br>正确答案：C<br>解析： C、选项A错误，因为m阶B-树可能只有一个根节点。选项B错误，在m阶B-树中，除根节点外，每个节点至少有m&#x2F;2（取上界）-1个关键字。选项D错误，当插入一个关键字引起B-树节点分裂时，树不一定会增高一层，只有节点分裂延续到根节点，根节点也分裂后，树才会增高一层。</p><h2 id="17‌在一棵m阶B-树中删除一个关键字会引起合并，则该节点原有（-）个关键字。"><a href="#17‌在一棵m阶B-树中删除一个关键字会引起合并，则该节点原有（-）个关键字。" class="headerlink" title="17‌在一棵m阶B-树中删除一个关键字会引起合并，则该节点原有（ ）个关键字。"></a>17‌在一棵m阶B-树中删除一个关键字会引起合并，则该节点原有（ ）个关键字。</h2><p>A.[m&#x2F;2]-1<br>B.[m&#x2F;2]+1<br>C.1<br>D.[m&#x2F;2]<br>正确答案：A<br>解析： A、引起合并的节点应为关键字个数的下限。</p><h2 id="18‏以下关于哈希查找的叙述中错误的是（-）。"><a href="#18‏以下关于哈希查找的叙述中错误的是（-）。" class="headerlink" title="18‏以下关于哈希查找的叙述中错误的是（ ）。"></a>18‏以下关于哈希查找的叙述中错误的是（ ）。</h2><p>A.哈希函数H(k)&#x3D;k MOD p，p通常取小于等于表长的素数<br>B.用线性探测法解决冲突易引起堆积现象<br>C.哈希函数选得好可以减少冲突现象<br>D.用拉链法解决冲突易引起堆积现象<br>正确答案：D<br>解析： D、用拉链法解决冲突时不存在堆积现象，只有用线性探测法解决冲突时易引起堆积现象。<br><img src="/../imgs/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%88%B7%E9%A2%98/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA54yq6ISa546L,size_20,color_FFFFFF,t_70,g_se,x_16-16877914901972.png" alt="在这里插入图片描述"></p><h2 id="19以下关于哈希查找的叙述中正确的是（-）。"><a href="#19以下关于哈希查找的叙述中正确的是（-）。" class="headerlink" title="19以下关于哈希查找的叙述中正确的是（ ）。"></a>19以下关于哈希查找的叙述中正确的是（ ）。</h2><p>A.哈希查找中不需要任何关键字的比较<br>B.采用拉链法解决冲突时，查找一个元素的时间是相同的<br>C.哈希表在查找成功时的平均查找长度仅仅与表长有关<br>D.哈希表的装填因子等于表中填入的记录数除以哈希表的长度<br>正确答案：D</p><h2 id="20为提高哈希（Hash）表的查找效率，可以采取的正确措施是（-）。"><a href="#20为提高哈希（Hash）表的查找效率，可以采取的正确措施是（-）。" class="headerlink" title="20为提高哈希（Hash）表的查找效率，可以采取的正确措施是（ ）。"></a>20为提高哈希（Hash）表的查找效率，可以采取的正确措施是（ ）。</h2><p>Ⅰ.增大装填（载）因子​<br>​Ⅱ.设计冲突（碰撞）少的哈希函数​<br>​Ⅲ.处理冲突（碰撞）时避免产生堆积（堆积）现象</p><p>A.仅Ⅰ、Ⅱ<br>B.仅Ⅰ<br>C.仅Ⅱ、Ⅲ<br>D.仅Ⅱ<br>正确答案：C<br>解析： C、装填（载）因子α越大，发生冲突的可能性越大，所以Ⅰ错误。因为哈希表是由哈希函数和处理冲突两部分组成的，查找效率与这两部分有关，所以Ⅱ和Ⅲ是正确的。</p><h1 id="第十三周测验"><a href="#第十三周测验" class="headerlink" title="第十三周测验"></a>第十三周测验</h1><h2 id="1以下关于排序的叙述中正确的是（-）。"><a href="#1以下关于排序的叙述中正确的是（-）。" class="headerlink" title="1以下关于排序的叙述中正确的是（ ）。"></a>1以下关于排序的叙述中正确的是（ ）。</h2><p>A.在顺序表上实现的排序方法在链表上也同样适合<br>B.排序方法都是在顺序表上实现的，在链表上无法实现排序方法<br>C.对同一个顺序表使用不同的排序方法进行排序，得到的排序结果可能不同<br>D.稳定的排序方法优于不稳定的排序方法，因为稳定的排序方法效率较高<br>正确答案：C<br>解析： C、稳定的排序方法的效率不一定都比不稳定的排序方法高。有些排序方法既可以上顺序表上实现，也可以在链表上实现，但不是所有的排序方法都如此。由于排序方法具有不同的稳定性，所以对同一个顺序表（存在相同的多个关键字记录）使用不同的排序方法进行排序，得到的排序结果可能不同。</p><p><strong>课本考据：1、排序是要整理表中的元素，使之按关键字递增或递减有序排列。</strong></p><h2 id="2以下不属于内排序方法的是（-）。"><a href="#2以下不属于内排序方法的是（-）。" class="headerlink" title="2以下不属于内排序方法的是（ ）。"></a>2以下不属于内排序方法的是（ ）。</h2><p>A.拓扑排序<br>B.二路<a href="https://so.csdn.net/so/search?q=%E5%BD%92%E5%B9%B6&spm=1001.2101.3001.7020">归并</a>排序<br>C.<a href="https://so.csdn.net/so/search?q=%E7%9B%B4%E6%8E%A5%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F&spm=1001.2101.3001.7020">直接插入排序</a><br>D.堆排序<br>正确答案：A<br>解析： A、拓扑排序是一种产生拓扑序列的方法，不属内排序方法。<br><img src="/../imgs/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%88%B7%E9%A2%98/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA54yq6ISa546L,size_20,color_FFFFFF,t_70,g_se,x_16-16877915043219.png" alt="在这里插入图片描述"></p><h2 id="3目前来讲，基于比较的内排序方法最好的平均时间复杂度为（-）。"><a href="#3目前来讲，基于比较的内排序方法最好的平均时间复杂度为（-）。" class="headerlink" title="3目前来讲，基于比较的内排序方法最好的平均时间复杂度为（ ）。"></a>3目前来讲，基于比较的内排序方法最好的平均时间复杂度为（ ）。</h2><p>A.O(log2n)<br>B.O(nlog2n)<br>C.O(n)<br>D.O(n2)<br>正确答案：B<br>解析： B、目前来讲，基于比较的内排序方法最好的平均时间复杂度为O(nlog2n)。</p><p><strong>课本考据：<br>1、对于n个元素排序结果有n!种情况，对应的判定树是一颗有n!个叶子结点的高度最小的二叉树，其中单分支结点个数为0，结点总数&#x3D;n0+n2&#x3D;2n!-1。<br>2、设其高度为h，求出h&#x3D;[log22n!]&#x3D;[log2n!]+1，对应的关键字比较次数最多为h-1,即[log2n!],算出[log22n!]≈nlog2n，则h≈nlog2n。<br>3、综上所述，从平均情况可以看出大约需要nlog2n次关键字比较（所有n!种排序情况的关键字比较次数的平均值），移动次数是同样的数量级，所以排序的平均时间复杂度为O(nlog2n)，即基于比较的排序算法最好的平均时间负责度为O(nlog2n)。</strong></p><h2 id="4‍对有n个记录的表进行直接插入排序，在最好情况下需比较（-）次关键字。"><a href="#4‍对有n个记录的表进行直接插入排序，在最好情况下需比较（-）次关键字。" class="headerlink" title="4‍对有n个记录的表进行直接插入排序，在最好情况下需比较（ ）次关键字。"></a>4‍对有n个记录的表进行直接插入排序，在最好情况下需比较（ ）次关键字。</h2><p>A.n-1<br>B.n&#x2F;2<br>C.n+1<br>D.n(n-1)&#x2F;2<br>正确答案：A<br>解析： A、直接插入排序在初始数据正序时效率最好，此时只需要n-1次关键字比较。</p><p><strong>课本考据：直接插入排序的一趟操作时将当前无序区的开头元素R[i] (1&lt;&#x3D;i&lt;&#x3D;n-1)插到有序区R[0…i-1]中的适当位置，使R[0…i]变为新的有序区。</strong></p><h2 id="5数据序列-8，9，10，4，5，6，20，1，2-只能是（-）算法的两趟排序后的结果。"><a href="#5数据序列-8，9，10，4，5，6，20，1，2-只能是（-）算法的两趟排序后的结果。" class="headerlink" title="5数据序列{8，9，10，4，5，6，20，1，2}只能是（ ）算法的两趟排序后的结果。"></a>5数据序列{8，9，10，4，5，6，20，1，2}只能是（ ）算法的两趟排序后的结果。</h2><p>A.堆排序<br>B.简单选择排序<br>C.直接插入排序<br>D.冒泡排序<br>正确答案：C<br>解析： C、采用排除法，因为两趟排序后结果中的有序区不是全局有序的，所以只能是直接插入排序，不可能是其他三种排序方法。</p><p><strong>课本考据：<br>1、选择排序的基本思想是每一趟从待排序的元素中选出关键字最小的元素，顺序放在已排好序的子表的最后，直到全部元素排序完毕。<br>2、堆排序是一种树形选择排序方式，利用完全二叉树中双亲结点和孩子结点之间的位置关系在无序区中选择关键字最大（或最小）的元素。堆排序每趟产生的有序区一定是全局有序区，也就是说每趟产出的有序区中的所有元素都归位了。<br>3、简单选择排序（又称直接选择排序）的基本思想是第i趟排序开始时，当前有序区和无序区分别为R[0…i-1]和R[i…n-1] (0&lt;&#x3D;i&lt;&#x3D;n-1),该趟排序是从当前无序区中选出关键字最小的元素R[k]，将它与无序区的第1个元素R[i]交换。简单选择排序每趟产生的有序区一定是全局有序区，也就是说每趟产出的有序区中的所有元素都归位了。<br>4、直接插入排序的一趟操作是将当前无序区的开头元素R[i] (1&lt;&#x3D;i&lt;&#x3D;n-1)插到有序区R[0…i-1]中的适当位置，使R[0…i]变为新的有序区。直接插入排序每趟产生的有序区并不一定是全局有序区，也就是说有序区中的元素并不一定放在最终的位置上。每当一个元素在整个排序结束前就已经放在其最终位置上称为归位。<br>5、冒泡排序（又称气泡排序）是一种典型的交换排序方法，其基本思想是通过无序区中相邻元素关键字间的比较和位置的交换使关键字最小的元素如气泡一般选择逐渐往上“漂浮”直至“水面”。冒泡排序每趟产生的有序区一定是全局有序区，也就是说每趟产出的有序区中的所有元素都归位了。</strong></p><h2 id="6‏对数据序列-15，9，7，8，20，-1，4-进行排序，进行一趟后数据的排序变为-4，9，-1，8，20，7，15-，则采用的是（-）算法。"><a href="#6‏对数据序列-15，9，7，8，20，-1，4-进行排序，进行一趟后数据的排序变为-4，9，-1，8，20，7，15-，则采用的是（-）算法。" class="headerlink" title="6‏对数据序列{15，9，7，8，20，-1，4}进行排序，进行一趟后数据的排序变为{4，9，-1，8，20，7，15}，则采用的是（ ）算法。"></a>6‏对数据序列{15，9，7，8，20，-1，4}进行排序，进行一趟后数据的排序变为{4，9，-1，8，20，7，15}，则采用的是（ ）算法。</h2><p>A.希尔排序<br>B.快速排序<br>C.冒泡排序<br>D.简单选择排序<br>正确答案：A<br>解析： A、因为一趟排序后结果中的有序区不是全局有序的，所以不可能是简单选择排序和冒泡排序。而快速排序会将15归位，这里也不对。这里是增量d&#x3D;3的希尔排序。</p><h2 id="7以下排序方法中，（-）在初始序列已基本有序的情况下，排序效率最高。"><a href="#7以下排序方法中，（-）在初始序列已基本有序的情况下，排序效率最高。" class="headerlink" title="7以下排序方法中，（ ）在初始序列已基本有序的情况下，排序效率最高。"></a>7以下排序方法中，（ ）在初始序列已基本有序的情况下，排序效率最高。</h2><p>A.直接插入排序<br>B.堆排序<br>C.二路归并排序<br>D.快速排序<br>正确答案：A<br>解析： A、直接插入排序在初始序列越接近正序时，排序效率越高，为O(n)。</p><p><strong>课本考据：当初始化数据序列不同时，直接插入排序所耗费的时间有很大差异。最好情况是表初态为正序，此时算法的时间复杂度为O(n)。</strong></p><h2 id="8冒泡排序最少元素移动的次数是（-）。"><a href="#8冒泡排序最少元素移动的次数是（-）。" class="headerlink" title="8冒泡排序最少元素移动的次数是（ ）。"></a>8冒泡排序最少元素移动的次数是（ ）。</h2><p>A.n<br>B.0<br>C.1<br>D.3n(n-1)&#x2F;2<br>正确答案：B<br>解析： B、数据有序的情况。</p><p><strong>课本考据：若初始数据序列是正序的，则一趟扫描即可完成排序，所需的关键字比较和元素移动的次数均分别达到最小值：Cmin&#x3D;n-1,Mmin&#x3D;0。</strong></p><h2 id="9‏已知用某种排序方法对关键字序列-51，35，93，24，13，68，56，42，77-进行排序时，前两趟排序的结果为"><a href="#9‏已知用某种排序方法对关键字序列-51，35，93，24，13，68，56，42，77-进行排序时，前两趟排序的结果为" class="headerlink" title="9‏已知用某种排序方法对关键字序列{51，35，93，24，13，68，56，42，77}进行排序时，前两趟排序的结果为"></a>9‏已知用某种排序方法对关键字序列{51，35，93，24，13，68，56，42，77}进行排序时，前两趟排序的结果为</h2><p>‏（35，51，24，13，68，56，42，77，93）<br>‏（35，24，13，51，56，42，68，77，93）<br>‏所采用的排序方法是（ ）。<br>A.冒泡排序<br>B.直接插入排序<br>C.二路归并排序<br>D.快速排序<br>正确答案：A<br>解析： A、每趟冒出一个最大元素放在后面。</p><h2 id="10‏为实现快速排序法，待排序序列宜采用存储方式是（-）。"><a href="#10‏为实现快速排序法，待排序序列宜采用存储方式是（-）。" class="headerlink" title="10‏为实现快速排序法，待排序序列宜采用存储方式是（ ）。"></a>10‏为实现快速排序法，待排序序列宜采用存储方式是（ ）。</h2><p>A.链式存储<br>B.索引存储<br>C.顺序存储<br>D.哈希存储<br>正确答案：C<br>解析： C、快速排序算法要求存储结构具有随机存取特征，因为要快速定位子区间。</p><h2 id="11快速排序在（-）情况下最不利于发挥其长处。"><a href="#11快速排序在（-）情况下最不利于发挥其长处。" class="headerlink" title="11快速排序在（ ）情况下最不利于发挥其长处。"></a>11快速排序在（ ）情况下最不利于发挥其长处。</h2><p>A.排序的数据中含有多个相同值<br>B.排序的数据已基本有序<br>C.排序的数据个数为奇数<br>D.排序的数据量太大<br>正确答案：B<br>解析： B、当排序的数据已基本有序，快速排序的时间复杂度会变为O(n2)。</p><h2 id="12‌对一组数据-25，84，21，47，15，27，68，35，20-进行排序，前3趟的排序结果如下："><a href="#12‌对一组数据-25，84，21，47，15，27，68，35，20-进行排序，前3趟的排序结果如下：" class="headerlink" title="12‌对一组数据(25，84，21，47，15，27，68，35，20)进行排序，前3趟的排序结果如下："></a>12‌对一组数据(25，84，21，47，15，27，68，35，20)进行排序，前3趟的排序结果如下：</h2><p>‌第1趟：20，15，21，25，47，27，68，35，84​<br>‌第2趟：15，20，21，25，35，27，47，68，84<br>​‌第3趟：15，20，21，25，27，35，47，68，84​<br>‌则所采用的排序方法是（ ）。<br>A.二路归并排序<br>B.希尔排序<br>C.简单选择<br>D.快速排序<br>正确答案：D<br>解析： D、考虑快速排序，第1趟将第一个元素25归位，第2趟将(20，15，21)中元素20归位，(35，27，47，68，84)中元素35归位，所以可以推导出采用的是快速排序方法。</p><h2 id="13采用排序算法对n个元素进行排序，其排序趟数肯定为n-1趟的排序方法是（-）。"><a href="#13采用排序算法对n个元素进行排序，其排序趟数肯定为n-1趟的排序方法是（-）。" class="headerlink" title="13采用排序算法对n个元素进行排序，其排序趟数肯定为n-1趟的排序方法是（ ）。"></a>13采用排序算法对n个元素进行排序，其排序趟数肯定为n-1趟的排序方法是（ ）。</h2><p>A.直接插入和快速<br>B.冒泡和快速<br>C.简单选择和冒泡<br>D.简单选择和直接插入<br>正确答案：D<br>解析： D、简单选择和直接插入肯定要进行n-1趟排序，冒泡排序为1～n-1趟，快速排序为log2n～n-1趟。</p><h2 id="14‏在一般情况下，以下排序算法中元素移动次数最少的（-）。"><a href="#14‏在一般情况下，以下排序算法中元素移动次数最少的（-）。" class="headerlink" title="14‏在一般情况下，以下排序算法中元素移动次数最少的（ ）。"></a>14‏在一般情况下，以下排序算法中元素移动次数最少的（ ）。</h2><p>A.都一样<br>B.简单选择排序<br>C.冒泡排序<br>D.直接插入排序<br>正确答案：B<br>解析： B、简单选择排序移动元素的次数为0～3(n-1)，在一般情况下，比直接插入排序和冒泡排序移动元素次数要少。</p><h2 id="15以下序列不是堆的是（-）。"><a href="#15以下序列不是堆的是（-）。" class="headerlink" title="15以下序列不是堆的是（ ）。"></a>15以下序列不是堆的是（ ）。</h2><p>A.(10，20，40，60，66，77，80，82，85，98，100)<br>B.(100，85，98，77，80，60，82，40，20，10，66)<br>C.(100，98，85，82，80，77，66，60，40，20，10)<br>D.(100，85，40，77，80，60，66，98，82，10，20)<br>正确答案：D<br>解析： D、画出各个序列对应的完全二叉树，再逐个判断。</p><h2 id="16‌对含有n个元素的数据序列采用堆排序方法，其中调用筛选算法有（-）次。"><a href="#16‌对含有n个元素的数据序列采用堆排序方法，其中调用筛选算法有（-）次。" class="headerlink" title="16‌对含有n个元素的数据序列采用堆排序方法，其中调用筛选算法有（ ）次。"></a>16‌对含有n个元素的数据序列采用堆排序方法，其中调用筛选算法有（ ）次。</h2><p>A.n-1<br>B.n<br>C.(3n-2)&#x2F;2<br>D.n&#x2F;2<br>正确答案：C<br>解析： C、建立初始堆调用筛选算法n&#x2F;2时，每选出一个元素调用筛选算法1次，共需n&#x2F;2+n-1&#x3D;(3n-2)&#x2F;2次。</p><h2 id="17‍已知序列-18，12，16，10，5，15，2，8，7-是大根堆，删除一个元素后再调整为大根堆，调整后的大根堆是（-）。"><a href="#17‍已知序列-18，12，16，10，5，15，2，8，7-是大根堆，删除一个元素后再调整为大根堆，调整后的大根堆是（-）。" class="headerlink" title="17‍已知序列(18，12，16，10，5，15，2，8，7)是大根堆，删除一个元素后再调整为大根堆，调整后的大根堆是（ ）。"></a>17‍已知序列(18，12，16，10，5，15，2，8，7)是大根堆，删除一个元素后再调整为大根堆，调整后的大根堆是（ ）。</h2><p>A.(16，2，15，10，5，7，12，8)<br>B.(16，15，12，10，8，7，5，2)<br>C.(16，12，15，10，5，7，2，8)<br>D.(16，12，15，10，5，7，2，8，18)<br>正确答案：C<br>解析： C、堆中只能删除堆顶元素，然后调整成堆。</p><h2 id="18‌对n个元素采用二路归并排序，其中归并的趟数是（-）。"><a href="#18‌对n个元素采用二路归并排序，其中归并的趟数是（-）。" class="headerlink" title="18‌对n个元素采用二路归并排序，其中归并的趟数是（ ）。"></a>18‌对n个元素采用二路归并排序，其中归并的趟数是（ ）。</h2><p>A.[log2n]+1<br>B.[log2n]<br>C.O(n2)<br>D.n<br>正确答案：B<br>解析： B、归并排序中每趟归并子段的长度倍增，所以趟数为log2n（取上界）。</p><p><strong>课本考据：对于长度为n的排序表，二路归并需要进行[log2n]趟，每趟归并时间为O(n)。</strong></p><h2 id="19‌数据序列（10，9，8，7，6，5，4，3，2，1）采用二路归并排序方法进行递增排序，第2趟排序结束后的结果是（-）。‎"><a href="#19‌数据序列（10，9，8，7，6，5，4，3，2，1）采用二路归并排序方法进行递增排序，第2趟排序结束后的结果是（-）。‎" class="headerlink" title="19‌数据序列（10，9，8，7，6，5，4，3，2，1）采用二路归并排序方法进行递增排序，第2趟排序结束后的结果是（ ）。‎"></a>19‌数据序列（10，9，8，7，6，5，4，3，2，1）采用二路归并排序方法进行递增排序，第2趟排序结束后的结果是（ ）。‎</h2><p>A.（9，10，7，8，5，6，3，4，1，2）<br>B.（7，8，9，10，3，4，5，6，1，2）<br>C.（1，2，3，4，7，8，9，10，1，2）<br>D.（1，2，3，4，5，6，7，8，9，10）<br>正确答案：B</p><h2 id="20‏有n个十进制整数进行基数排序，其中最大的整数为5位，则基数排序过程中临时建立的队数个数是（-）。"><a href="#20‏有n个十进制整数进行基数排序，其中最大的整数为5位，则基数排序过程中临时建立的队数个数是（-）。" class="headerlink" title="20‏有n个十进制整数进行基数排序，其中最大的整数为5位，则基数排序过程中临时建立的队数个数是（ ）。"></a>20‏有n个十进制整数进行基数排序，其中最大的整数为5位，则基数排序过程中临时建立的队数个数是（ ）。</h2><p>A.5<br>B.10<br>C.n<br>D.2<br>正确答案：B<br>解析： B、基数排序中建立队列个数等于进制数。</p><p><img src="/../imgs/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%88%B7%E9%A2%98/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA54yq6ISa546L,size_20,color_FFFFFF,t_70,g_se,x_16-168779150432110.png" alt="在这里插入图片描述"></p><h1 id="第十四周测验"><a href="#第十四周测验" class="headerlink" title="第十四周测验"></a>第十四周测验</h1><h2 id="1‏外排序和内排序的主要区别是（-）。"><a href="#1‏外排序和内排序的主要区别是（-）。" class="headerlink" title="1‏外排序和内排序的主要区别是（ ）。"></a>1‏外排序和内排序的主要区别是（ ）。</h2><p>A.内排序所需内存小，而外排序所需内存大<br>B.内排序不涉及内、外存数据交换，而外排序涉及内、外存数据交换<br>C.内排序的数据量小，而外排序的数据量大<br>D.内排序速度快，而外排序速度慢<br>正确答案：B</p><p><strong>课本考据：<br>1、在排序过程中，若整个表都放在内存中处理，排序时不涉及数据的内、外存交换，则称为内排序；<br>2、在排序过程中，若要进行数据的内、外存交换，则称为外排序。</strong></p><h2 id="2‌以下关于外排序的叙述中正确的是（-）。"><a href="#2‌以下关于外排序的叙述中正确的是（-）。" class="headerlink" title="2‌以下关于外排序的叙述中正确的是（ ）。"></a>2‌以下关于外排序的叙述中正确的是（ ）。</h2><p>A.外排序把外存文件调入内存，再利用内排序方法进行排序，所以外排序所花时间完全由采用的内排序确定<br>B.外排序所花时间&#x3D;内排序时间+外存数据读写时间+内部<a href="https://so.csdn.net/so/search?q=%E5%BD%92%E5%B9%B6&spm=1001.2101.3001.7020">归并</a>所花时间<br>C.外排序完全可以由内排序来替代<br>D.外排序并不涉及文件的读写操作<br>正确答案：B<br>解析： B、外排序过程主要分为两个阶段：生成初始归并段和对初始归并段进行归并，这两个步骤中都涉及文件的读写操作。</p><p><strong>课本考据：外排序的基本方法是归并排序法，它分为两个步骤：<br>1、生成若干初始归并段（顺串）：将一个文件（含待排序的数据）中的数据分段读入内存中，在内存中对其进行内排序，并将经过排序的数据段（有序段）写到多个外存文件上。<br>2、多路并归：对这些初始归并段进行多遍归并，使得有序的归并段逐渐扩大，最后在外存上形成整个文件的单一归并段，完成这个文件的外排序。</strong></p><h2 id="3多路平衡归并的目的是（-）。‌"><a href="#3多路平衡归并的目的是（-）。‌" class="headerlink" title="3多路平衡归并的目的是（ ）。‌"></a>3多路平衡归并的目的是（ ）。‌</h2><p>A.以上都对<br>B.便于实现败者树<br>C.减少初始归并段的个数<br>D.减少归并趟数<br>正确答案：D<br>解析： D、多路平衡归并的目的是减少归并趟数，因为m个初始归并段采用k路平衡归并时，所需趟数s&#x3D;logkm（取上界），如果不采用平衡归并，其趟数会大于s。</p><h2 id="4‌m个初始归并进行k路平衡归并时，所需趟数是（-）。"><a href="#4‌m个初始归并进行k路平衡归并时，所需趟数是（-）。" class="headerlink" title="4‌m个初始归并进行k路平衡归并时，所需趟数是（ ）。"></a>4‌m个初始归并进行k路平衡归并时，所需趟数是（ ）。</h2><p>A.[logmk]<br>B.[logkm]+1<br>C.[logkm]<br>D.[logk(m+1)]<br>正确答案：C</p><p><strong>课本考据：当采用k路平衡归并时，相应的归并树有[logkm]+1层，要对数据进行s&#x3D;[logkm]遍扫描，显然k越大，磁盘读写次数越少。</strong></p><h2 id="5在由k路归并构建的的败者树中选取一个最小的关键字记录，则所需时间为（-）（用“O”表示）。"><a href="#5在由k路归并构建的的败者树中选取一个最小的关键字记录，则所需时间为（-）（用“O”表示）。" class="headerlink" title="5在由k路归并构建的的败者树中选取一个最小的关键字记录，则所需时间为（ ）（用“O”表示）。"></a>5在由k路归并构建的的败者树中选取一个最小的关键字记录，则所需时间为（ ）（用“O”表示）。</h2><p>A.O(log2k)<br>B.O(k)<br>C.O(1)<br>D.以上都不对<br>正确答案：A</p><p><strong>课本考据：若初始归并段为m个，利用败者树在k个记录中选择最小者只需要进行[log2k]次关键字比较，则s&#x3D;[logkm]趟归并。</strong></p><h2 id="6m个初始归并段采用k路平衡归并时，构建的败者树中共有（-）个节点（不计冠军节点）。"><a href="#6m个初始归并段采用k路平衡归并时，构建的败者树中共有（-）个节点（不计冠军节点）。" class="headerlink" title="6m个初始归并段采用k路平衡归并时，构建的败者树中共有（ ）个节点（不计冠军节点）。"></a>6m个初始归并段采用k路平衡归并时，构建的败者树中共有（ ）个节点（不计冠军节点）。</h2><p>A.2m-1<br>B.2k<br>C.2k-1<br>D.2m<br>正确答案：C</p><p><strong>课本考据：k路平衡归并败者树是一颗含有k个叶子结点，且没有单分支结点（这是构建k路平衡归并败者树的约定）的完全二叉树,即n1&#x3D;0.有n2&#x3D;n0-1&#x3D;k-1,n&#x3D;n0+n1+n2&#x3D;2k-1,则h&#x3D;[log2(n+1)]&#x3D;[log2(2k)]&#x3D;[log2k]+1。</strong></p><h2 id="7采用败者树进行k路平衡归并的外排序算法中，总的关键字比较次数与k（-）。"><a href="#7采用败者树进行k路平衡归并的外排序算法中，总的关键字比较次数与k（-）。" class="headerlink" title="7采用败者树进行k路平衡归并的外排序算法中，总的关键字比较次数与k（ ）。"></a>7采用败者树进行k路平衡归并的外排序算法中，总的关键字比较次数与k（ ）。</h2><p>A.以上都不对<br>B.无关<br>C.成反比<br>D.成正比<br>正确答案：B<br>解析： B、采用败者树进行k路平衡归并的外排序算法中，总的关键字比较次数&#x3D;(u-1)*log2m，其中u为归并的记录个数，m是初始归并段的个数，从而看出与k无关。</p><h2 id="8‏一个无序文件中的n个记录采用置换-选择算法产生m个有序段，则m和n的关系是（-）。"><a href="#8‏一个无序文件中的n个记录采用置换-选择算法产生m个有序段，则m和n的关系是（-）。" class="headerlink" title="8‏一个无序文件中的n个记录采用置换-选择算法产生m个有序段，则m和n的关系是（ ）。"></a>8‏一个无序文件中的n个记录采用置换-选择算法产生m个有序段，则m和n的关系是（ ）。</h2><p>A.m与n成反比<br>B.以上都不对<br>C.m&#x3D;log2n<br>D.m与n成正比<br>正确答案：B<br>解析： B、如w&#x3D;1时，记录序列（1，2，3，4，5）产生一个有序段，而（5，4，3，2，1）产生5个有序段，所以一般来讲，m与数据序列、内存工作区可容纳的记录个数w和n都有关，但并不是A、B、C选项所指的直接关系。</p><h2 id="9对于100个长度不等的初始归并段，构建5路最佳归并树时，需要增加（-）个虚段"><a href="#9对于100个长度不等的初始归并段，构建5路最佳归并树时，需要增加（-）个虚段" class="headerlink" title="9对于100个长度不等的初始归并段，构建5路最佳归并树时，需要增加（ ）个虚段"></a>9对于100个长度不等的初始归并段，构建5路最佳归并树时，需要增加（ ）个虚段</h2><p>A.0<br>B.1<br>C.2<br>D.3<br>正确答案：B<br>解析： B、u&#x3D;(m-1)%(k-1)&#x3D;3，需要增加k-1-u&#x3D;1个虚段。</p><h2 id="10‍由m个初始归并段构建的k阶最佳归并树中，度为k的节点个数是（-）。"><a href="#10‍由m个初始归并段构建的k阶最佳归并树中，度为k的节点个数是（-）。" class="headerlink" title="10‍由m个初始归并段构建的k阶最佳归并树中，度为k的节点个数是（ ）。"></a>10‍由m个初始归并段构建的k阶最佳归并树中，度为k的节点个数是（ ）。</h2><p>A.无法确定<br>B.(m-1)&#x2F;(k-1)<br>C.(m-1)&#x2F;k<br>D.m&#x2F;k<br>正确答案：B<br>解析： B、设树中节点个数为n，n0&#x3D;m，n-1&#x3D;knk，n&#x3D;n0+nk，所以有knk&#x3D;m+nk-1，则nk&#x3D;(m-1)&#x2F;(k-1)。</p>]]></content>
    
    
    <categories>
      
      <category>考试复习</category>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
      <tag>考试复习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构-AB卷</title>
    <link href="/2023/06/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-AB%E5%8D%B7/"/>
    <url>/2023/06/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-AB%E5%8D%B7/</url>
    
    <content type="html"><![CDATA[<h1 id="综合题"><a href="#综合题" class="headerlink" title="综合题"></a>综合题</h1><h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><h3 id="1-A卷"><a href="#1-A卷" class="headerlink" title="1.A卷"></a>1.A卷</h3><p>1． 设一棵二叉树的先序序列： A B D F C E G H ，中序序列： B F D A G E H C。请回答下列问题。（15分） </p><p>（1）画出这棵二叉树。（5分）  </p><blockquote><p>看先序确定根，看中序确定左右子树</p></blockquote><p>（2）画出这棵二叉树的后序线索树。（5分）</p><blockquote><p>根据后续补全左右节点</p></blockquote><p>（3）将这棵二叉树转换成对应的树（或森林）（5分）</p><blockquote><p>将A节点的中右孩子的右孩子都与A节点的双亲节点连线</p><p>去除右孩子连线层次转换得到树</p></blockquote><h3 id="2-B卷"><a href="#2-B卷" class="headerlink" title="2.B卷"></a>2.B卷</h3><p>1． 设一棵二叉树的后序序列：G B D E H F C A，中序序列： D G B A E C H F。请回答下列问题。（15分） </p><p>（1）画出这棵二叉树。（5分）   </p><blockquote><p>看后序确定根，看中序确定左右节点</p></blockquote><p>（2）画出这棵二叉树的后序线索树。（5分）</p><blockquote><p>根据后续补全节点</p></blockquote><p>（3）将这棵二叉树转换成对应的树（或森林）。（5分）</p><blockquote><p>去除从根节点开始右孩子连线</p><p>将分离的二叉树转换为树</p></blockquote><h2 id="哈夫曼编码"><a href="#哈夫曼编码" class="headerlink" title="哈夫曼编码"></a>哈夫曼编码</h2><h3 id="1-A卷-1"><a href="#1-A卷-1" class="headerlink" title="1.A卷"></a>1.A卷</h3><p>有一份电文共有5个字符：a、b、c、d、e，它们出现的频率依次为4、7、5、2、9。请为这5个字符设计哈夫曼编码。（10分）</p><blockquote><p>画哈夫曼编码，路径左0右1，从根节点到节点的通路编码</p></blockquote><h3 id="2-B卷-1"><a href="#2-B卷-1" class="headerlink" title="2.B卷"></a>2.B卷</h3><p>假设用于通信的电文仅由8个字母A、B、C、D、E、F、G、H组成，字母在电文中出现的频率分别为0.07，0.19，0.02，0.06，0.32，0.03，0.21，0.10。请为这8个字母设计哈夫曼编码。（10分） </p><blockquote><p>扩大100倍计算，画哈夫曼编码，路径左0右1，从根节点到节点的通路编码</p></blockquote><h2 id="有向图、无向图"><a href="#有向图、无向图" class="headerlink" title="有向图、无向图"></a>有向图、无向图</h2><h3 id="1-A卷-2"><a href="#1-A卷-2" class="headerlink" title="1.A卷"></a>1.A卷</h3><p><img src="/../imgs/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-AB%E5%8D%B7/image-20230627142347446.png" alt="image-20230627142347446"></p><p>（1）计算每个顶点的<strong>入度和出度</strong>（5分）</p><blockquote><p>入度：狐头数</p><p>出度：狐尾数</p><p>图的度：相加</p></blockquote><p>（2）画出该有向图的<strong>邻接矩阵</strong>（5分）</p><blockquote></blockquote><p>（3）画出该有向图的<strong>邻接表</strong>（5分）</p><blockquote></blockquote><h3 id="2-B卷-2"><a href="#2-B卷-2" class="headerlink" title="2.B卷"></a>2.B卷</h3><p><img src="/../imgs/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-AB%E5%8D%B7/image-20230627142423600.png" alt="image-20230627142423600"></p><p>（1）画出该带权无向图。（5分）</p><p><img src="/../imgs/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-AB%E5%8D%B7/image-20230627142452268.png" alt="image-20230627142452268"></p><p>（2）画出该无向图的邻接表。（5分）</p><p>（3）求该无向图的最小生成树。（5分）</p><h2 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h2><h3 id="1-A卷-3"><a href="#1-A卷-3" class="headerlink" title="1.A卷"></a>1.A卷</h3><blockquote><p>设待排序的关键字序列为{12，2，16，30，28，10， 20，6，18}，试分别写出使用冒泡排序法和快速排序法在每趟排序结束后关键字序列的状态。（10分）</p></blockquote><p>（1）冒泡排序法（5分）</p><p>（2）快速排序法（5分）</p><h3 id="2-B卷-3"><a href="#2-B卷-3" class="headerlink" title="2.B卷"></a>2.B卷</h3><blockquote><p>设待排序的关键字序列为{12，2，16，30，28，10， 20，6，18}，试分别写出使用直接插入排序法和希尔排序法在每趟排序结束后关键字序列的状态。（10分）</p></blockquote><p>（1）直接插入排序法（5分）</p><p>（2）希尔排序法（5分）</p>]]></content>
    
    
    <categories>
      
      <category>考试复习</category>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
      <tag>考试复习</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>

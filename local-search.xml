<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>数据结构-考点范围</title>
    <link href="/2023/06/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E8%80%83%E7%82%B9%E8%8C%83%E5%9B%B4/"/>
    <url>/2023/06/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E8%80%83%E7%82%B9%E8%8C%83%E5%9B%B4/</url>
    
    <content type="html"><![CDATA[<h1 id="一、哈夫曼树🌟-第5章-二叉树"><a href="#一、哈夫曼树🌟-第5章-二叉树" class="headerlink" title="一、哈夫曼树🌟(第5章-二叉树)"></a>一、哈夫曼树🌟(第5章-二叉树)</h1><h1 id="二、如何构造二叉树并画出来（第5章-二叉树）"><a href="#二、如何构造二叉树并画出来（第5章-二叉树）" class="headerlink" title="二、如何构造二叉树并画出来（第5章-二叉树）"></a>二、如何构造二叉树并画出来（第5章-二叉树）</h1><h1 id="三、深度优先和广度优先（第6章-图-图的遍历）"><a href="#三、深度优先和广度优先（第6章-图-图的遍历）" class="headerlink" title="三、深度优先和广度优先（第6章-图-图的遍历）"></a>三、深度优先和广度优先（第6章-图-图的遍历）</h1><h1 id="四、领接表和矩阵（第6章-图-图的存储结构）"><a href="#四、领接表和矩阵（第6章-图-图的存储结构）" class="headerlink" title="四、领接表和矩阵（第6章-图-图的存储结构）"></a>四、领接表和矩阵（第6章-图-图的存储结构）</h1><h1 id="五、最小生成树（第6章-图-图的应用）"><a href="#五、最小生成树（第6章-图-图的应用）" class="headerlink" title="五、最小生成树（第6章-图-图的应用）"></a>五、最小生成树（第6章-图-图的应用）</h1><h1 id="六、AVL树（第7章-查找）"><a href="#六、AVL树（第7章-查找）" class="headerlink" title="六、AVL树（第7章-查找）"></a>六、AVL树（第7章-查找）</h1><h1 id="七、散列表散列查找（第7章-查找-散列表的查找）"><a href="#七、散列表散列查找（第7章-查找-散列表的查找）" class="headerlink" title="七、散列表散列查找（第7章-查找-散列表的查找）"></a>七、散列表散列查找（第7章-查找-散列表的查找）</h1><h1 id="八、二叉排序树（第7章-查找-树表的查找）"><a href="#八、二叉排序树（第7章-查找-树表的查找）" class="headerlink" title="八、二叉排序树（第7章-查找-树表的查找）"></a>八、二叉排序树（第7章-查找-树表的查找）</h1><h1 id="九、排序算法（第8章排序）🌟"><a href="#九、排序算法（第8章排序）🌟" class="headerlink" title="九、排序算法（第8章排序）🌟"></a>九、排序算法（第8章排序）🌟</h1>]]></content>
    
    
    <categories>
      
      <category>考试复习</category>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
      <tag>考试复习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构-刷题-知识点</title>
    <link href="/2023/06/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%88%B7%E9%A2%98-%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <url>/2023/06/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%88%B7%E9%A2%98-%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<h1 id="第一章-绪论"><a href="#第一章-绪论" class="headerlink" title="第一章-绪论"></a>第一章-绪论</h1><h4 id="1-如何判断程序的复杂程度：时间和空间复杂度"><a href="#1-如何判断程序的复杂程度：时间和空间复杂度" class="headerlink" title="1.如何判断程序的复杂程度：时间和空间复杂度"></a>1.<a href="https://blog.csdn.net/wang_8101/article/details/109017857">如何判断程序的复杂程度：时间和空间复杂度</a></h4><blockquote><p>数据结构中评价两个程序最重要的指标是<strong>时间复杂度</strong>和<strong>空间复杂度</strong></p></blockquote><h1 id="第二章-线性表"><a href="#第二章-线性表" class="headerlink" title="第二章-线性表"></a>第二章-<a href="https://www.cnblogs.com/EXQSLoveForever/p/15642885.html">线性表</a></h1><blockquote><p>线性表定义：线性表是由<em>n</em>(<em>n</em>&gt;&#x3D;0)个相同类型的数据元素组成的有限序列，标记为:L&#x3D;(<em>a</em>1,<em>a</em>2,…,ai,…,an)</p><p>线性表可以为空，当n为0时表示该线性表不包含任何元素为空表</p></blockquote><p><img src="/../imgs/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%88%B7%E9%A2%98-%E7%9F%A5%E8%AF%86%E7%82%B9/image-20230625002019566.png" alt="image-20230625002019566"></p><h4 id="顺序表"><a href="#顺序表" class="headerlink" title="顺序表"></a>顺序表</h4><blockquote><p>随机存取特性：顺序表随机存取与元素个数无关</p><p>如：数组通过下标存取值，与数组内容无关，知道下标就行</p></blockquote><blockquote><p>删除特性：顺序表删除一个元素所用时间与删除的位置和表的长度有关</p><p>理解：根据顺序表的逻辑特征，删除其中一个元素后，后面的元素下表-1覆盖删除元素的位置，删除元素的位置在最后一个元素那么花费的时间短，删除的元素在开头，直接后继一个一个的覆盖</p></blockquote><h4 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h4><blockquote><p>单链表增加头节点是为了方便元素插入和删除运算的实现</p></blockquote><blockquote><p>头节点建立单链表：后面的节点先插入到最前端</p><p>理解：数组A与1、2、3的值，头节点建立L后顺序为3、2、1</p></blockquote><blockquote><p>在长度为n&gt;&#x3D;1的L中查找和删除尾节点的时间复杂度均为O(n)</p></blockquote><blockquote><p>带头节点的循环单链表为空时满足L-next&#x3D;&#x3D;L</p><p>理解：循环单链表想象成一个环形的链表，L-next&#x3D;&#x3D;L相当于L下一个节点等于自己，即表为空</p></blockquote><h4 id="双链表"><a href="#双链表" class="headerlink" title="双链表"></a>双链表</h4><blockquote><p><strong>双链表中每个结点有指向前后结点的指针即可访问前后结点</strong></p></blockquote><blockquote><p>双链表为空的条件为L-&gt;next&#x3D;&#x3D;NULL</p><p>理解：与单链一致</p></blockquote><blockquote><p>循环双链表和非顺序双链表删除头节点和尾节点的时间复杂度，两个删除头节点复杂度为O（1），删除尾节点时循环双L为O（1），后者为O（n）</p></blockquote><h1 id="第三章-栈和队列"><a href="#第三章-栈和队列" class="headerlink" title="第三章-栈和队列"></a>第三章-栈和队列</h1><blockquote></blockquote><h3 id="一、栈"><a href="#一、栈" class="headerlink" title="一、栈"></a>一、栈</h3><blockquote><p>栈的定义：<strong>栈是一种只能在一端进行插入或删除操作的线性表</strong></p><p>入栈出栈规则：元素先进后出，后进先出</p></blockquote><h4 id="3-1-出栈顺序题（判断出栈顺序正确新）"><a href="#3-1-出栈顺序题（判断出栈顺序正确新）" class="headerlink" title="3.1 出栈顺序题（判断出栈顺序正确新）"></a>3.1 出栈顺序题（判断出栈顺序正确新）</h4><h5 id="3-1-1-递增顺序"><a href="#3-1-1-递增顺序" class="headerlink" title="3.1.1 递增顺序"></a>3.1.1 递增顺序</h5><blockquote><p><img src="/../imgs/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%88%B7%E9%A2%98-%E7%9F%A5%E8%AF%86%E7%82%B9/image-20230625022451914.png" alt="image-20230625022451914"></p><p>理解：排除法做题，设第一个出栈的元素为x，不考虑比x大的元素入栈，此时栈内元素出栈的顺序必为递减</p><p><img src="/../imgs/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%88%B7%E9%A2%98-%E7%9F%A5%E8%AF%86%E7%82%B9/image-20230625023611561.png" alt="image-20230625023611561"></p><p>分析A，此时出栈为3，不考虑比3大的元素，那么出栈必然会有3、2、1，故A正确</p><p>分析B，出栈为5，那么出栈必有5、4、3、2、1，显然1、2不对</p><p>分析C，出栈为4，那么必然有4、3、2、1，显然1、3不对</p><p>分析D，出栈为4，同上，1、2不对</p></blockquote><h5 id="3-1-2-递减顺序"><a href="#3-1-2-递减顺序" class="headerlink" title="3.1.2 递减顺序"></a>3.1.2 递减顺序</h5><blockquote><p>和递增类似，补考虑比出栈元素小的，找比出栈元素大的</p><p>例子：4、3、2、1</p><p>如果3出栈，不考虑2、1，必然有3、4</p><p>如果出栈为1，必然有1、2、3、4</p><p><img src="/../imgs/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%88%B7%E9%A2%98-%E7%9F%A5%E8%AF%86%E7%82%B9/image-20230625024234556.png" alt="image-20230625024234556"></p><p>分析A，2出栈，必然有3、4、5、6，正确</p><p>分析B，3出栈，必然有4、5、6，显然4、6不对</p><p>分析C，5出栈，必然有5、6，正确</p><p>分析D，4出栈，必然有4、5、6，正确</p></blockquote><h5 id="3-1-3-字母类型"><a href="#3-1-3-字母类型" class="headerlink" title="3.1.3 字母类型"></a>3.1.3 字母类型</h5><blockquote><p>和数字一样，麻烦点直接把字符标数字，如A&#x3D;1，B&#x3D;2</p></blockquote><h4 id="3-2-栈顶入栈和栈底入栈（top-gt-0和top-gt-n-1"><a href="#3-2-栈顶入栈和栈底入栈（top-gt-0和top-gt-n-1" class="headerlink" title="3.2 栈顶入栈和栈底入栈（top-&gt;0和top-&gt;n-1)"></a>3.2 栈顶入栈和栈底入栈（top-&gt;0和top-&gt;n-1)</h4><blockquote><p>情况1：top初始值为0，即top在栈低入栈，元素x入栈时top++,data[top]&#x3D;x,top&#x3D;n-1时栈满</p><p>情况2：top初始值为n-1，即top在栈顶入栈，元素x入栈时top–，data[top]&#x3D;x,top&#x3D;0时栈满</p></blockquote><h3 id="二、队列"><a href="#二、队列" class="headerlink" title="二、队列"></a>二、队列</h3><blockquote><p>队列的定义：<strong>是只允许在一端进行插入操作，而在另一端进行删除操作的线性表</strong></p><p>入队出队规则：先进先出</p></blockquote><blockquote><p>循环队列为空：通常用front&#x3D;&#x3D;rear来判断栈是否为空，栈满时无法判断</p></blockquote><h4 id="循环队列空还是满的三种处理方式（可能考简答题🌟）"><a href="#循环队列空还是满的三种处理方式（可能考简答题🌟）" class="headerlink" title="循环队列空还是满的三种处理方式（可能考简答题🌟）"></a>循环队列空还是满的三种处理方式（可能考简答题🌟）</h4><ol><li><p>牺牲一个单元格区分堆满或对空：当front指向rear下一个位置时为队满</p><blockquote><p>队空：Q.front&#x3D;&#x3D;Q.rear</p><p>队满：(Q.rear+1)%N&#x3D;&#x3D;Q.front</p><p>队列中元素的个数：(rear-front+N)%N</p></blockquote></li><li><p>在Q的类型中新增关于元素个数的数据成员size</p><blockquote><p>队空：size&#x3D;0</p><p>队满：size&#x3D;N</p></blockquote></li><li><p>在Q的类型中新增tag数据成员</p><blockquote><p>队空：tag&#x3D;0,因删除操作队空</p><p>队满：tag&#x3D;1，因入队操作队满</p></blockquote></li></ol><h4 id="循环队列操作（插入、删除）"><a href="#循环队列操作（插入、删除）" class="headerlink" title="循环队列操作（插入、删除）"></a>循环队列操作（插入、删除）</h4><blockquote><p>条件：循环队列qu,data下表0~n-1,队头指针front、队尾指针rear</p><p>插入：队列插入的一端为队尾rear，删除的一端为队头，x元素入队qu.rear&#x3D;(qu.rear+1)%N,qu.data[qu.rear]&#x3D;x</p><p>删除（出队）：qu.font&#x3D;(qu.font+1)%N</p><p><img src="/../imgs/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%88%B7%E9%A2%98-%E7%9F%A5%E8%AF%86%E7%82%B9/d01d208e645a8c52bd6d361abd330f19.jpeg" alt="img"></p></blockquote><h4 id="顺序队和链队的比较"><a href="#顺序队和链队的比较" class="headerlink" title="顺序队和链队的比较"></a>顺序队和链队的比较</h4><blockquote><p>尽管链队总是采用动态分配方式，其长度也受内存大小的限制，也不可能实现无限长队列。</p><p>顺序队和链队的进队和出队操作时间均为O(1)。</p><p>顺序队和链队都可以进行顺序访问。</p><p>在顺序队中可以通过队头和队尾指针计算队中元素个数，而链队不能。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>考试复习</category>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
      <tag>考试复习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构-书本复习</title>
    <link href="/2023/06/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%B9%A6%E6%9C%AC%E5%A4%8D%E4%B9%A0/"/>
    <url>/2023/06/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%B9%A6%E6%9C%AC%E5%A4%8D%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="一、"><a href="#一、" class="headerlink" title="一、"></a>一、</h1>]]></content>
    
    
    <categories>
      
      <category>考试复习</category>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
      <tag>考试复习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构-刷题</title>
    <link href="/2023/06/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%88%B7%E9%A2%98/"/>
    <url>/2023/06/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%88%B7%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="第一周测验"><a href="#第一周测验" class="headerlink" title="第一周测验"></a>第一周测验</h1><h2 id="1、计算机所处理的数据一般具备某种内在联系，这是指（-）。"><a href="#1、计算机所处理的数据一般具备某种内在联系，这是指（-）。" class="headerlink" title="1、计算机所处理的数据一般具备某种内在联系，这是指（ ）。"></a>1、计算机所处理的数据一般具备某种内在联系，这是指（ ）。</h2><p>A.数据和数据之间存在某种关系<br>B.元素和元素之间存在某种关系<br>C.元素内部具有某种结构<br>D.数据项和数据项之间存在某种关系<br><strong>正确答案：B</strong><br>解析： B、在<a href="https://so.csdn.net/so/search?q=%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84&spm=1001.2101.3001.7020">数据结构</a>中讨论的关系指的是元素和元素之间的关系。</p><p><strong>课本考据：数据是描述客观事物的数和字符的集合，人们通常以数据元素作为数据的基本单位。其中数据元素也成为元素、结点、顶点或者记录。</strong></p><h2 id="2、在数据结构中，与所使用的计算机无关的是数据的（-）结构。"><a href="#2、在数据结构中，与所使用的计算机无关的是数据的（-）结构。" class="headerlink" title="2、在数据结构中，与所使用的计算机无关的是数据的（ ）结构。"></a>2、在数据结构中，与所使用的计算机无关的是数据的（ ）结构。</h2><p>A.逻辑<br>B.存储<br>C.逻辑和存储<br>D.物理<br><strong>正确答案：A</strong><br>解析： A、逻辑结构与存储结构无关，也就是与使用的计算机无关。</p><p><strong>课本考据：数据的逻辑结构由数据元素之间的逻辑关系构成，数据逻辑结构与数据的存储无关，是独立于计算机的，因此数据的逻辑结构可以看作是从具体问题抽象出来的数学模型。</strong></p><h2 id="3、在计算机中存储数据时，通常不仅要存储各数据元素的值，而且还要存储（-）。"><a href="#3、在计算机中存储数据时，通常不仅要存储各数据元素的值，而且还要存储（-）。" class="headerlink" title="3、在计算机中存储数据时，通常不仅要存储各数据元素的值，而且还要存储（ ）。"></a>3、在计算机中存储数据时，通常不仅要存储各数据元素的值，而且还要存储（ ）。</h2><p>A.数据的处理方法<br>B.数据元素的类型<br>C.数据元素之间的关系<br>D.数据的存储方法<br><strong>正确答案：C</strong><br>解析： C、将数据逻辑结构映射成存储数据时，需要存储所有数据元素的值和数据元素之间关系。</p><h2 id="4、数据结构在计算机内存中的表示是指（-）。"><a href="#4、数据结构在计算机内存中的表示是指（-）。" class="headerlink" title="4、数据结构在计算机内存中的表示是指（ ）。"></a>4、数据结构在计算机内存中的表示是指（ ）。</h2><p>A.数据的存储结构<br>B.数据结构<br>C.数据的逻辑结构<br>D.数据元素之间的关系<br><strong>正确答案：A</strong><br>解析： A、数据的存储结构是逻辑结构在计算机内存中的表示，它既保存数据元素，也保存数据元素之间的关系。</p><p><strong>课本考据：数据逻辑结构在计算机存储器中的存储表示成为数据的存储结构（也称为映像），也就是逻辑结构在计算机中的存储实现。</strong></p><h2 id="5、数据在计算机的存储器中表示时，逻辑上相邻的两个元素对应的物理地址也是相邻的，这种存储结构称之为（-）。"><a href="#5、数据在计算机的存储器中表示时，逻辑上相邻的两个元素对应的物理地址也是相邻的，这种存储结构称之为（-）。" class="headerlink" title="5、数据在计算机的存储器中表示时，逻辑上相邻的两个元素对应的物理地址也是相邻的，这种存储结构称之为（ ）。"></a>5、数据在计算机的存储器中表示时，逻辑上相邻的两个元素对应的物理地址也是相邻的，这种存储结构称之为（ ）。</h2><p>A.逻辑结构<br>B.顺序存储结构<br>C.链式存储结构<br>D.以上都对<br><strong>正确答案：B</strong><br>解析： B、顺序存储结构是逻辑结构的一种直接映射，通过数据元素之间的物理关系来表示逻辑关系。</p><p><strong>课本考据：顺序存储结构的定义——是采用一组连续的存储单元存放的数据元素，也就是说所有数据元素在存储器中占有一整块存储空间，而且两个逻辑上相邻的元素在存储器中的存储位置也相邻。</strong></p><h2 id="6、数据采用链式存储结构时，要求（-）。"><a href="#6、数据采用链式存储结构时，要求（-）。" class="headerlink" title="6、数据采用链式存储结构时，要求（ ）。"></a>6、数据采用链式存储结构时，要求（ ）。</h2><p>A.每个节点占用一片连续的存储区域<br>B.所有节点占用一片连续的存储区域<br>C.节点的最后一个域必须是指针域<br>D.每个节点有多少后继节点，就必须设多少个指针域<br><strong>正确答案：A</strong><br>解析： A、在链式存储结构中，通常一个结点是整体分配存储空间的，所以每个结点占用一片连续的存储区域，所有结点的存储地址既可以连续也可以不连续，所以所有结点不一定占用一片连续的存储区域。</p><p><strong>课本考据：在链式存储结构中，每个逻辑元素用一个内存节点存储，每个节点是单独分配的，所有的节点地址不一定是连续的，所有无须占用一整块存储空间。</strong></p><h2 id="7、可以用（-）定义一个完整的数据结构。"><a href="#7、可以用（-）定义一个完整的数据结构。" class="headerlink" title="7、可以用（ ）定义一个完整的数据结构。"></a>7、可以用（ ）定义一个完整的数据结构。</h2><p>A.数据元素<br>B.数据对象<br>C.数据关系<br>D.抽象数据类型<br><strong>正确答案：D</strong><br>解析： D、抽象数据类型指的是用户进行软件系统设计时从问题的数学模型中抽象出来的逻辑数据结构和逻辑数据结构上的运算，可以定义一个完整的数据结构。</p><p><strong>补充：抽象数据类型不考虑计算机的具体存储结构和运算的具体实现算法。</strong></p><h2 id="8、算法指的是（-）。"><a href="#8、算法指的是（-）。" class="headerlink" title="8、算法指的是（ ）。"></a>8、算法指的是（ ）。</h2><p>A.计算机程序<br>B.解决问题的方法<br>C.查找或排序过程<br>D.求解特定问题的指令有限序列<br><strong>正确答案：D</strong><br>解析： D、算法是求解特定问题的指令有限序列。</p><p><strong>补充：数据元素之间有逻辑关系和物理关系，对应的运算有基于逻辑结构的运算描述和居于存储结构的运算实现——通常我们把基于存储结构的运算实现的步骤或过程称为算法。</strong></p><h2 id="9、在算法设计时，若实参和形参同步发生改变，则应把形参变量说明为（-）型参数。"><a href="#9、在算法设计时，若实参和形参同步发生改变，则应把形参变量说明为（-）型参数。" class="headerlink" title="9、在算法设计时，若实参和形参同步发生改变，则应把形参变量说明为（ ）型参数。"></a>9、在算法设计时，若实参和形参同步发生改变，则应把形参变量说明为（ ）型参数。</h2><p>A.指针<br>B.引用<br>C.传值<br>D.常数<br><strong>正确答案：B</strong><br>解析： B、函数的形参变量与对应的实参共享相同的存储空间，可以将形参值回传给对应的实参。</p><h2 id="10、某算法的时间复杂度为O-n2-，表明该算法的（-）。"><a href="#10、某算法的时间复杂度为O-n2-，表明该算法的（-）。" class="headerlink" title="10、某算法的时间复杂度为O(n2)，表明该算法的（ ）。"></a>10、某算法的时间复杂度为O(n2)，表明该算法的（ ）。</h2><p>A.问题规模是<br>B.执行时间等于<br>C.执行时间与n2成正比<br>D.问题规模与n2成正比<br><strong>正确答案：C</strong><br>解析： C、<strong>算法的时间复杂度是问题规模n的函数，某算法的时间复杂度为O(n2),表示该算法的频度为cn2（c为一个正常量），即执行时间与n2成正比。</strong></p><h1 id="第二周测验"><a href="#第二周测验" class="headerlink" title="第二周测验"></a>第二周测验</h1><h2 id="1、线性表是（-）。"><a href="#1、线性表是（-）。" class="headerlink" title="1、线性表是（ ）。"></a>1、<a href="https://so.csdn.net/so/search?q=%E7%BA%BF%E6%80%A7%E8%A1%A8&spm=1001.2101.3001.7020">线性表</a>是（ ）。</h2><p>A.一个有限序列，可以为空<br>B.一个有限序列，不可以为空<br>C.一个无限序列，可以为空<br>D.一个无限序列，不可以为空<br><strong>正确答案：A</strong><br>解析： A、线性表是具有n（n≥0）个数据元素的有限序列。</p><p><strong>课本考据：线性表是具有相同特征的数据元素的一个有限序列。当 n&#x3D;0时，表示线性表是一个空表，即不包含任何元素。</strong></p><h2 id="2、线性表的基本运算ListInsert-amp-L-i-e-表示在线性表L中第i个位置上插入一个元素e，若L的长度为n，则i的合法取值是（-）。"><a href="#2、线性表的基本运算ListInsert-amp-L-i-e-表示在线性表L中第i个位置上插入一个元素e，若L的长度为n，则i的合法取值是（-）。" class="headerlink" title="2、线性表的基本运算ListInsert(&amp;L,i,e)表示在线性表L中第i个位置上插入一个元素e，若L的长度为n，则i的合法取值是（ ）。"></a>2、线性表的基本运算ListInsert(&amp;L,i,e)表示在线性表L中第i个位置上插入一个元素e，若L的长度为n，则i的合法取值是（ ）。</h2><p>A.1≤i≤n<br>B.1≤i≤n+1<br>C.0≤i≤n-1<br>D. 0≤i≤n<br><strong>正确答案：B</strong><br>解析： B、线性表的基本运算ListInsert(&amp;L，i，e)中，位置i是指逻辑序号，可以在L的位置1到位置n+1插入元素。</p><p><strong>课本考据：插入数据元素，在L的第i（1&lt;&#x3D;i&lt;&#x3D;n+1）个位置插入一个新的元素e，L的长度增一。</strong></p><h2 id="3、顺序表具有随机存取特性，指的是（-）。"><a href="#3、顺序表具有随机存取特性，指的是（-）。" class="headerlink" title="3、顺序表具有随机存取特性，指的是（ ）。"></a>3、顺序表具有随机存取特性，指的是（ ）。</h2><p>A.查找值为x的元素与顺序表中元素个数n无关<br>B.查找值为x的元素与顺序表中元素个数n有关<br>C.查找序号为i的元素与顺序表中元素个数n无关<br>D.查找序号为i的元素与顺序表中元素个数n有关<br><strong>正确答案：C</strong><br>解析： C、一种存储结构具有随机存取特性指的是，对于给定的序号i，在O(1)时间内找到对应元素值。</p><p><strong>课本考据：顺序表示线性表的直接映射，可从求线性表中的某个数据元素的值的算法得知<br>&#x3D;&gt;<br>一个没有循环（或者有循环，但循环的次数与问题规模 n无关）的算法中原操作执行次数与问题规模无关，记作O（1），也成为常数阶</strong>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">bool</span> <span class="hljs-title function_">GetElem</span><span class="hljs-params">(SqList * L,<span class="hljs-type">int</span> i, ElemType &amp;e)</span><br>&#123;<br><span class="hljs-keyword">if</span>(i&lt;<span class="hljs-number">1</span> || i&gt;L-&gt;length)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>e=L-&gt;data[i<span class="hljs-number">-1</span>];<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-number">1234567</span><br></code></pre></td></tr></table></figure><h2 id="4、在顺序表中删除一个元素所需要的时间（-）。"><a href="#4、在顺序表中删除一个元素所需要的时间（-）。" class="headerlink" title="4、在顺序表中删除一个元素所需要的时间（ ）。"></a>4、在顺序表中删除一个元素所需要的时间（ ）。</h2><p>A.与删除元素的位置及顺序表的长度都有关<br>B.只与删除元素的位置有关<br>C.与删除任何其他元素所需要的时间相等<br>D.只与顺序表的长度有关<br><strong>正确答案：A</strong><br>解析： A、当从顺序表中删除元素时，为了保持顺序表的逻辑特性，需要移动元素以覆盖该删除的元素。因此在顺序表中删除一个元素与该元素的位置及顺序表的长度都有关。</p><p><strong>课本考据：元素移动的次数与表长n&#x3D;L-&gt;length和删除元素的位置i有关，共有n个元素可被删除。</strong></p><h2 id="5、在n（n-gt-1）个运算的顺序表中，算法时间复杂度为O-1-的运算是（-）。"><a href="#5、在n（n-gt-1）个运算的顺序表中，算法时间复杂度为O-1-的运算是（-）。" class="headerlink" title="5、在n（n&gt;1）个运算的顺序表中，算法时间复杂度为O(1)的运算是（ ）。"></a>5、在n（n&gt;1）个运算的顺序表中，算法时间复杂度为O(1)的运算是（ ）。</h2><p>A.访问第i个元素（2≤i≤n）并求其前驱元素<br>B.在第i个元素之后插入一个新元素<br>C.删除第i个元素<br>D.将这n个元素递增排序<br><strong>正确答案：A</strong><br>解析： A、访问第i个元素（2≤i≤n）即L-&gt;data[i-1]和求其前驱元素L-&gt;data[i-2]的时间复杂度均为O(1)。</p><p><strong>课本考据：元素移动的次数不仅与表长n&#x3D;L-&gt;length有关，而且与插入、删除的位置i有关，平均时间复杂度为O（n）。</strong></p><h2 id="6、关于线性表的顺序存储结构和链式存储结构的描述中，正确的是（-）。"><a href="#6、关于线性表的顺序存储结构和链式存储结构的描述中，正确的是（-）。" class="headerlink" title="6、关于线性表的顺序存储结构和链式存储结构的描述中，正确的是（ ）。"></a>6、关于线性表的顺序存储结构和链式存储结构的描述中，正确的是（ ）。</h2><p>Ⅰ.线性表的顺序存储结构优于链式存储结构<br>Ⅱ.顺序存储结构比链式存储结构的存储密度高<br>Ⅲ.如需要频繁插入和删除元素，最好采用顺序存储结构<br>Ⅳ.如需要频繁插入和删除元素，最好采用链式存储结构<br>A.Ⅰ、Ⅱ、Ⅲ<br>B.Ⅱ、Ⅳ<br>C.Ⅱ、Ⅲ<br>D.Ⅲ、Ⅳ<br><strong>正确答案：B</strong><br>解析： B、线性表的顺序存储结构和链式存储结构各有优缺点，不能简单比较好坏，所以Ⅰ错误。链式存储结构使用指针表示逻辑关系，所以存储密度比较低，所以Ⅱ正确。如频繁使用插入和删除操作，链式存储结构更优于顺序存储结构，所以Ⅲ错误，Ⅳ正确。</p><h2 id="7、在单链表中，增加一个头节点的目的是为了（-）。"><a href="#7、在单链表中，增加一个头节点的目的是为了（-）。" class="headerlink" title="7、在单链表中，增加一个头节点的目的是为了（ ）。"></a>7、在单链表中，增加一个头节点的目的是为了（ ）。</h2><p>A.使单链表至少有一个节点<br>B.标识链表中某个重要节点的位置<br>C.方便插入和删除运算的实现<br>D.表示单链表是线性表的链式存储结构<br><strong>正确答案：C</strong><br>解析： C、在单链表中增加一个头节点的主要目的是使删除和插入节点操作更简单，方便运算的实现。</p><h2 id="8、通过含有n（n≥1）个元素的数组a，采用头插法建立一个单链表L，则L中节点值的次序（-）。"><a href="#8、通过含有n（n≥1）个元素的数组a，采用头插法建立一个单链表L，则L中节点值的次序（-）。" class="headerlink" title="8、通过含有n（n≥1）个元素的数组a，采用头插法建立一个单链表L，则L中节点值的次序（ ）。"></a>8、通过含有n（n≥1）个元素的数组a，采用头插法建立一个单链表L，则L中节点值的次序（ ）。</h2><p>A.与数组a的元素次序相同<br>B.与数组a的元素次序相反<br>C.与数组a的元素次序无关<br>D.以上都不对<br><strong>正确答案：B</strong><br>解析： B、采用头插法建立单链表时，后面的节点插入到最前端，所以L的节点值次序与数组a的元素次序相反。</p><h2 id="9、某算法在含有n（n≥1）个节点的单链表中查找值为x节点，其时间复杂度是（-）。"><a href="#9、某算法在含有n（n≥1）个节点的单链表中查找值为x节点，其时间复杂度是（-）。" class="headerlink" title="9、某算法在含有n（n≥1）个节点的单链表中查找值为x节点，其时间复杂度是（ ）。"></a>9、某算法在含有n（n≥1）个节点的单链表中查找值为x节点，其时间复杂度是（ ）。</h2><p>A.O(log2n)<br>B.O(1)<br>C.O(n2)<br>D.O(n)<br><strong>正确答案：D</strong><br>解析： D、需要从首节点出发逐一查找每个节点。</p><p><strong>课本考据：按元素值查找的算法在单链表L中从头开始找第一个值域与e相等的结点，若存在这样的结点，则返回逻辑序号，否则返回0；</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">LocateElem</span><span class="hljs-params">(LinkNode * ElemType)</span><br>&#123;<br><span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;<br>LinkNode * p=L-&gt;next;<br><span class="hljs-keyword">while</span>(p != UNLL &amp;&amp; p-&gt;data != e)<br>&#123;<br>p=p-&gt;next;<br>i++;<br>&#125;<br><span class="hljs-keyword">if</span>(p==<span class="hljs-literal">NULL</span>)<br><span class="hljs-keyword">return</span>(<span class="hljs-number">0</span>);<br><span class="hljs-keyword">else</span><br><span class="hljs-keyword">return</span>(i);<br>&#125;<br><span class="hljs-number">1234567891011121314</span><br></code></pre></td></tr></table></figure><h2 id="10、在长度为n（n≥1）的单链表中删除尾节点的时间复杂度为（-）。"><a href="#10、在长度为n（n≥1）的单链表中删除尾节点的时间复杂度为（-）。" class="headerlink" title="10、在长度为n（n≥1）的单链表中删除尾节点的时间复杂度为（ ）。"></a>10、在长度为n（n≥1）的单链表中删除尾节点的时间复杂度为（ ）。</h2><p>A.O(1)<br>B.O(log2n)<br>C.O(n)<br>D.O(n2)<br><strong>正确答案：C</strong><br>解析： C、在长度为n（n≥1）的单链表中删除尾节点时，需要找倒数第2个节点，此时时间复杂度为O(n)。</p><p><strong>课本考据L：删除数据元素的实现过程是先在单链表L中找到第i-1个结点，由p指向它。若存在这样的结点，且也存在后继结点（也由p指向它），则删除q所指的结点，返回true；否则返回false，表示参数i错误。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">bool</span> <span class="hljs-title function_">ListDelete</span><span class="hljs-params">(LinkNode *&amp; L,<span class="hljs-type">int</span> i,ElemType &amp; e)</span><br>&#123;<br><span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;<br>LinkNode * p=L,*q;<br><span class="hljs-keyword">if</span>(i&lt;=<span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">while</span>(j&lt;i<span class="hljs-number">-1</span> &amp;&amp; p != <span class="hljs-literal">NULL</span>)<br>&#123;<br>j++;<br>p=p-&gt;next;<br>&#125;<br><span class="hljs-keyword">if</span>(p==<span class="hljs-literal">NULL</span>)<br>ruturn <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">else</span><br>&#123;<br>q=p-&gt;next;<br><span class="hljs-keyword">if</span>(q==<span class="hljs-literal">NULL</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>e=q-&gt;data;<br>p-&gt;next=q-&gt;next;<br><span class="hljs-built_in">free</span>(q);<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br>&#125;<span class="hljs-number">12345678910111213141516171819202122</span><br></code></pre></td></tr></table></figure><h2 id="11、关于线性表的正确说法是（-）。"><a href="#11、关于线性表的正确说法是（-）。" class="headerlink" title="11、关于线性表的正确说法是（ ）。"></a>11、关于线性表的正确说法是（ ）。</h2><p>A.每个元素都有一个前驱和一个后继元素<br>B.线性表中至少有一个元素<br>C.表中元素的排序顺序必须是由小到大或由大到小<br>D.除第一个元素和最后一个元素外，其余每个元素有且仅有一个前驱和一个后继元素<br><strong>正确答案：D</strong><br>解析： D、线性表属典型的线性结构。</p><h2 id="12、以下关于顺序表的叙述中，正确的是（-）。"><a href="#12、以下关于顺序表的叙述中，正确的是（-）。" class="headerlink" title="12、以下关于顺序表的叙述中，正确的是（ ）。"></a>12、以下关于顺序表的叙述中，正确的是（ ）。</h2><p>A.顺序表可以利用一维数组表示，因此顺序表与一维数组在结构上是一致的，它们可以通用<br>B.在顺序表中，逻辑上相邻的元素在物理位置上不一定相邻<br>C.顺序表和一维数组一样，都可以进行随机存取<br>D.在顺序表中每一个元素的类型不必相同<br><strong>正确答案：C</strong><br>解析： C、顺序表中所有元素必须连续存放，而一维数组中所有元素可以不连续存放，另外，一维数组只有按下标的存、取两个操作，而顺序表可以进行线性表的插入、删除等操作，所以选项A错误。在顺序表中，逻辑上相邻的元素在物理位置上也一定相邻，所以选项B错误。顺序表中每一个元素的类型必须相同，所以选项D错误。</p><h2 id="13、以下属于顺序表的优点是（-）。"><a href="#13、以下属于顺序表的优点是（-）。" class="headerlink" title="13、以下属于顺序表的优点是（ ）。"></a>13、以下属于顺序表的优点是（ ）。</h2><p>A.插入元素方便<br>B.删除元素方便<br>C.存储密度大<br>D.以上都不对<br><strong>正确答案：C</strong><br>解析： C、顺序表的存储密度为1，所以其存储密度大。</p><h2 id="14、设线性表中有n个元素，以下运算中，（-）在单链表上实现要比在顺序表上实现效率更高。"><a href="#14、设线性表中有n个元素，以下运算中，（-）在单链表上实现要比在顺序表上实现效率更高。" class="headerlink" title="14、设线性表中有n个元素，以下运算中，（ ）在单链表上实现要比在顺序表上实现效率更高。"></a>14、设线性表中有n个元素，以下运算中，（ ）在单链表上实现要比在顺序表上实现效率更高。</h2><p>A.删除指定位置元素的后一个元素<br>B.在尾元素的后面插入一个新元素<br>C.顺序输出前k个元素<br>D.交换第i个元素和第n-i+1个元素的值（i&#x3D;1，2，…，n）<br><strong>正确答案：A</strong><br>解析： A、在顺序表中插入元素和删除元素时需要移动较多元素，而在单链表上执行同样的操作不需要移动元素，只需修改相关节点的指针域。</p><h2 id="15、以下关于单链表的叙述中正确的是（-）。"><a href="#15、以下关于单链表的叙述中正确的是（-）。" class="headerlink" title="15、以下关于单链表的叙述中正确的是（ ）。"></a>15、以下关于单链表的叙述中正确的是（ ）。</h2><p>Ⅰ.节点除自身信息外还包括指针域，存储密度小于顺序表<br>Ⅱ.找第i个节点的时间为O(1)<br>Ⅲ.在插入、删除运算时不必移动节点<br>A.仅Ⅰ、Ⅱ<br>B.仅Ⅱ、Ⅲ<br>C.仅Ⅰ、Ⅲ<br>D.Ⅰ、Ⅱ、Ⅲ<br><strong>正确答案：C</strong><br>解析： C、单链表不具有随机存取特性，即不能在O(1)的时间内找到第i个节点。</p><p><strong>课本考据：在链表中，逻辑上相邻的元素对应的存储位置是通过指针来连接的，因而每个结点的存储位置可以任意安排，不必要求相邻，所以当进行插入或删除操作时只需要修改相关结点的指针域即可。（方便省时）</strong></p><hr><h1 id="第三周测验2"><a href="#第三周测验2" class="headerlink" title="第三周测验2"></a>第三周测验2</h1><h2 id="1、与单链表相比，双链表的优点之一是（-）。"><a href="#1、与单链表相比，双链表的优点之一是（-）。" class="headerlink" title="1、与单链表相比，双链表的优点之一是（ ）。"></a>1、与<a href="https://so.csdn.net/so/search?q=%E5%8D%95%E9%93%BE%E8%A1%A8&spm=1001.2101.3001.7020">单链表</a>相比，双链表的优点之一是（ ）。</h2><p>A.插入、删除操作更简单<br>B.可以进行随机访问<br>C.可以省略表头指针或表尾指针<br>D.访问前后相邻节点更方便<br><strong>正确答案：D</strong><br>解析： D、在双链表中可以访问任一节点的前后相邻节点，而单链表中只能访问任一节点的下一个节点。</p><p>课本考据：由于双链表的每个结点既包含一个指向后继结点的指针，又包含一个指向前驱结点的指针，所以当访问过一个结点后既可以依次向后访问每一个结点，也可以依次向前访问每一个结点。<strong>（双链表中每个结点有指向前后结点的指针即可访问前后结点）</strong></p><h2 id="2、带头节点的双链表L为空表时应满足（-）。"><a href="#2、带头节点的双链表L为空表时应满足（-）。" class="headerlink" title="2、带头节点的双链表L为空表时应满足（ ）。"></a>2、带头节点的双链表L为空表时应满足（ ）。</h2><p>A.L &#x3D;&#x3D; NULL<br>B.L-&gt;prior &#x3D;&#x3D; L-&gt;next<br>C.L-&gt;prior &#x3D;&#x3D; NULL<br>D.L-&gt;nex t &#x3D;&#x3D; NULL<br><strong>正确答案：D</strong></p><p><strong>课本考据：除了插入和删除结点，双链表其他运算的算法与单链表中相应的算法相同。</strong></p><h2 id="3、在长度为n（n≥1）的双链表中插入一个节点（非尾节点）要修改（-）个指针域。"><a href="#3、在长度为n（n≥1）的双链表中插入一个节点（非尾节点）要修改（-）个指针域。" class="headerlink" title="3、在长度为n（n≥1）的双链表中插入一个节点（非尾节点）要修改（ ）个指针域。"></a>3、在长度为n（n≥1）的双链表中插入一个节点（非尾节点）要修改（ ）个指针域。</h2><p>A.1<br>B.2<br>C.3<br>D.4<br><strong>正确答案：D</strong><br>解析： D、需要修改插入节点的prior、next域，前驱节点的next域和后继节点的prior域。</p><p><strong>课本考据：原理参考第二题，如图<img src="/../imgs/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%88%B7%E9%A2%98/20201110165354598.png" alt="在这里插入图片描述"></strong><br><strong>操作语句如下：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">s-&gt;next=p-&gt;next;<br>p-&gt;next-&gt;prior=s;<br>s-&gt;prior=p;<br>p-&gt;next=s;<br><span class="hljs-number">1234</span><br></code></pre></td></tr></table></figure><h2 id="4、对于长度为n（n≥1）的双链表L，在p所指节点之前插入一个新节点的算法的时间复杂度为（-）。"><a href="#4、对于长度为n（n≥1）的双链表L，在p所指节点之前插入一个新节点的算法的时间复杂度为（-）。" class="headerlink" title="4、对于长度为n（n≥1）的双链表L，在p所指节点之前插入一个新节点的算法的时间复杂度为（ ）。"></a>4、对于长度为n（n≥1）的双链表L，在p所指节点之前插入一个新节点的算法的时间复杂度为（ ）。</h2><p>A.O(1)<br>B.O(n)<br>C.O(n2)<br>D.O(nlog2n)<br><strong>正确答案：A</strong><br>解析： A、设新节点指针为q，操作是：p-&gt;prior-&gt;next&#x3D;p; q-&gt;prior&#x3D;p-&gt;prior; p-&gt;prior&#x3D;q; q-&gt;next&#x3D;p;</p><h2 id="5、在长度为n（n≥1）的双链表中删除一个节点（非尾节点）要修改（-）个指针域。"><a href="#5、在长度为n（n≥1）的双链表中删除一个节点（非尾节点）要修改（-）个指针域。" class="headerlink" title="5、在长度为n（n≥1）的双链表中删除一个节点（非尾节点）要修改（ ）个指针域。"></a>5、在长度为n（n≥1）的双链表中删除一个节点（非尾节点）要修改（ ）个指针域。</h2><p>A.1<br>B.2<br>C.3<br>D.4<br><strong>正确答案：B</strong><br>解析： B、需要修改前驱节点的next域和后继节点的prior域。</p><h2 id="6、与非循环单链表相比，循环单链表的主要优点是（-）。"><a href="#6、与非循环单链表相比，循环单链表的主要优点是（-）。" class="headerlink" title="6、与非循环单链表相比，循环单链表的主要优点是（ ）。"></a>6、与非循环单链表相比，循环单链表的主要优点是（ ）。</h2><p>A.不再需要头指针<br>B.已知某个节点的位置后，能够容易找到它的前驱节点<br>C.在进行插入、删除操作时，能更好地保证链表不断开<br>D.从表中任意节点出发都能扫描到整个链表<br><strong>正确答案：D</strong><br>解析： D、循环单链表中可以循环扫描，因此从表中任意节点出发都能扫描到整个链表。</p><h2 id="7、设有带头节点的循环单链表L，当这种链表成为空链表时，有（-）。"><a href="#7、设有带头节点的循环单链表L，当这种链表成为空链表时，有（-）。" class="headerlink" title="7、设有带头节点的循环单链表L，当这种链表成为空链表时，有（ ）。"></a>7、设有带头节点的循环单链表L，当这种链表成为空链表时，有（ ）。</h2><p>A.表头节点指针域next为空<br>B.L的值为NULL<br>C.表头节点的指针域next与L的值相等<br>D.表头节点的指针域next与L的地址相等<br><strong>正确答案：C</strong><br>解析： C、带头节点的循环单链表L成为空链表时满足L-&gt;next&#x3D;&#x3D;L，即表头节点<em>L的指针域next与L的值相等，而不是表头节点</em>L的指针域next与L的地址相等。</p><h2 id="8、在长度为n（n≥1）的循环双链表L中，删除尾节点的时间复杂度为（-）。"><a href="#8、在长度为n（n≥1）的循环双链表L中，删除尾节点的时间复杂度为（-）。" class="headerlink" title="8、在长度为n（n≥1）的循环双链表L中，删除尾节点的时间复杂度为（ ）。"></a>8、在长度为n（n≥1）的循环双链表L中，删除尾节点的时间复杂度为（ ）。</h2><p>A.O(1)<br>B.O(n)<br>C.O(n2)<br>D.O(nlog2n)<br><strong>正确答案：A</strong><br>解析： A、通过头节点指针直接找到尾节点，然后再删除该尾节点，对应的时间复杂度为O(1)。</p><h2 id="9、将两个分别含有m、n个节点的有序单链表归并成一个有序单链表，要求不破坏原有的单链表，对应算法的空间复杂度是（-）（MIN表示取最小值）。"><a href="#9、将两个分别含有m、n个节点的有序单链表归并成一个有序单链表，要求不破坏原有的单链表，对应算法的空间复杂度是（-）（MIN表示取最小值）。" class="headerlink" title="9、将两个分别含有m、n个节点的有序单链表归并成一个有序单链表，要求不破坏原有的单链表，对应算法的空间复杂度是（ ）（MIN表示取最小值）。"></a>9、将两个分别含有m、n个节点的有序单链表归并成一个有序单链表，要求不破坏原有的单链表，对应算法的空间复杂度是（ ）（MIN表示取最小值）。</h2><p>A.O(n)<br>B.O(m)<br>C.O(m+n)<br>D.O(MIN(m,n))<br><strong>正确答案：C</strong><br>解析： C、将两个有序单链表A、B归并到C中时，通过比较A、B中的节点，将比较小的节点复制到C中，复制次数为m+n，即新建m+n个节点，对应的空间复杂度为O(m+n)。</p><h2 id="10、已知两个长度分别为m-和n-的升序单链表，若将它们合并为一个长度为m-n-的降序单链表，则时间复杂度是（-）。"><a href="#10、已知两个长度分别为m-和n-的升序单链表，若将它们合并为一个长度为m-n-的降序单链表，则时间复杂度是（-）。" class="headerlink" title="10、已知两个长度分别为m 和n 的升序单链表，若将它们合并为一个长度为m+n 的降序单链表，则时间复杂度是（ ）。"></a>10、已知两个长度分别为m 和n 的升序单链表，若将它们合并为一个长度为m+n 的降序单链表，则时间复杂度是（ ）。</h2><p>A.O(n)<br>B.O(m×n)<br>C.O(m)<br>D.O(m+n)<br><strong>正确答案：D</strong></p><h2 id="11、在长度为n（n≥1）的双链表L中，删除p所指节点的时间复杂度为（-）。"><a href="#11、在长度为n（n≥1）的双链表L中，删除p所指节点的时间复杂度为（-）。" class="headerlink" title="11、在长度为n（n≥1）的双链表L中，删除p所指节点的时间复杂度为（ ）。"></a>11、在长度为n（n≥1）的双链表L中，删除p所指节点的时间复杂度为（ ）。</h2><p>A.O(1)<br>B.O(n)<br>C.O(n2)<br>D.O(nlog2n)<br><strong>正确答案：A</strong><br>解析： A、在双链表中，通过p所指节点可以找到前后节点，通过其前后节点来删除p所指节点，对应的时间复杂度为O(1)。</p><h2 id="12、在长度为n（n≥1）的循环单链表L中，删除尾节点的时间复杂度为（-）。"><a href="#12、在长度为n（n≥1）的循环单链表L中，删除尾节点的时间复杂度为（-）。" class="headerlink" title="12、在长度为n（n≥1）的循环单链表L中，删除尾节点的时间复杂度为（ ）。"></a>12、在长度为n（n≥1）的循环单链表L中，删除尾节点的时间复杂度为（ ）。</h2><p>A.O(1)<br>B.O(n)<br>C.O(n2)<br>D.O(nlog2n)<br><strong>正确答案：B</strong><br>解析： B、通过L查找到尾节点的前驱节点，然后删除尾节点，对应的时间复杂度为O(n)。</p><h2 id="13、在只有尾节点指针rear没有头节点的非空循环单链表中，删除尾节点的时间复杂度为（-）。"><a href="#13、在只有尾节点指针rear没有头节点的非空循环单链表中，删除尾节点的时间复杂度为（-）。" class="headerlink" title="13、在只有尾节点指针rear没有头节点的非空循环单链表中，删除尾节点的时间复杂度为（ ）。"></a>13、在只有尾节点指针rear没有头节点的非空循环单链表中，删除尾节点的时间复杂度为（ ）。</h2><p>A.O(1)<br>B.O(n)<br>C.O(n2)<br>D.O(nlog2n)<br><strong>正确答案：B</strong><br>解析： B、通过rear查找到尾节点的前驱节点，然后删除尾节点，对应的时间复杂度为O(n)。</p><h2 id="14、在只有尾节点指针rear没有头节点的非空循环单链表中，删除开始节点的时间复杂度为（-）。"><a href="#14、在只有尾节点指针rear没有头节点的非空循环单链表中，删除开始节点的时间复杂度为（-）。" class="headerlink" title="14、在只有尾节点指针rear没有头节点的非空循环单链表中，删除开始节点的时间复杂度为（ ）。"></a>14、在只有尾节点指针rear没有头节点的非空循环单链表中，删除开始节点的时间复杂度为（ ）。</h2><p>A.O(1)<br>B.O(n)<br>C.O(n2)<br>D.O(nlog2n)<br><strong>正确答案：A</strong><br>解析： A、通过rear指针直接删除开始节点。</p><h2 id="15、两个长度为n的双链表，节点类型相同，若以h1为头指针的双链表是非循环的，以h2为头指针指针的双链表是循环的，则（-）。"><a href="#15、两个长度为n的双链表，节点类型相同，若以h1为头指针的双链表是非循环的，以h2为头指针指针的双链表是循环的，则（-）。" class="headerlink" title="15、两个长度为n的双链表，节点类型相同，若以h1为头指针的双链表是非循环的，以h2为头指针指针的双链表是循环的，则（ ）。"></a>15、两个长度为n的双链表，节点类型相同，若以h1为头指针的双链表是非循环的，以h2为头指针指针的双链表是循环的，则（ ）。</h2><p>A.对于非循环双链表来说，删除首节点的操作，其时间复杂度都是O(n)<br>B.对于循环双链表来说，删除首节点的操作，其时间复杂度都是O(n)<br>C.对于非循环双链表来说，删除尾节点的操作，其时间复杂度都是O(1)<br>D.对于循环双链表来说，删除尾节点的操作，其时间复杂度都是O(1)<br><strong>正确答案：D</strong><br>解析： D、对于这两个双链表来说，删除首节点的操作的时间复杂度都是O(1)。对于非循环双链表来说，删除尾节点的操作的时间复杂度都是O(n)，对于循环双链表来说，删除尾节点的操作的时间复杂度都是O(1)。</p><hr><h1 id="第四周测验"><a href="#第四周测验" class="headerlink" title="第四周测验"></a>第四周测验</h1><h2 id="1、栈的“先进后出”特性是指（-）。"><a href="#1、栈的“先进后出”特性是指（-）。" class="headerlink" title="1、栈的“先进后出”特性是指（ ）。"></a>1、栈的“先进后出”特性是指（ ）。</h2><p>A.最后进栈的元素总是最先出栈<br>B.同时进行进栈和出栈操作时，总是进栈优先<br>C.每当有出栈操作时，总要先进行一次进栈操作<br>D.每次出栈的元素总是最先进栈的元素<br><strong>正确答案：A</strong></p><p><strong>课本考据：栈是一种只能在一端进行插入或删除操作的线性表。</strong></p><h2 id="2、给定一个足够大的空栈，有4个元素的进栈次序为A、B、C、D，则以C、D开头的出栈序列的个数为（-）。"><a href="#2、给定一个足够大的空栈，有4个元素的进栈次序为A、B、C、D，则以C、D开头的出栈序列的个数为（-）。" class="headerlink" title="2、给定一个足够大的空栈，有4个元素的进栈次序为A、B、C、D，则以C、D开头的出栈序列的个数为（ ）。"></a>2、给定一个足够大的空栈，有4个元素的进栈次序为A、B、C、D，则以C、D开头的出栈序列的个数为（ ）。</h2><p>A.1<br>B.2<br>C.3<br>D.4<br><strong>正确答案：A</strong><br>解析： A、若出栈序列为CD…，则A、B、C进栈，C出栈，D进栈，D出栈，此后只有B出栈和A出栈一种情况，所以这样的出栈序列只有CDBA一个。</p><h2 id="3、若元素a、b、c、d、e、f依次进栈，允许进栈、退栈的操作交替进行，但不允许连续3次退栈工作，则不可能得到的出栈序列是（-）。"><a href="#3、若元素a、b、c、d、e、f依次进栈，允许进栈、退栈的操作交替进行，但不允许连续3次退栈工作，则不可能得到的出栈序列是（-）。" class="headerlink" title="3、若元素a、b、c、d、e、f依次进栈，允许进栈、退栈的操作交替进行，但不允许连续3次退栈工作，则不可能得到的出栈序列是（ ）。"></a>3、若元素a、b、c、d、e、f依次进栈，允许进栈、退栈的操作交替进行，但不允许连续3次退栈工作，则不可能得到的出栈序列是（ ）。</h2><p>A.dcebfa<br>B.cbdaef<br>C.bcaefd<br>D.afedcb<br><strong>正确答案：D</strong><br>解析：<br>选项A操作：a进，b进，c进，d进，d出，c出，e进，e出，b出，f进，f出，a出。<br>选项B操作：a进，b进，c进，c出，b出，d进，d出，a出，e进，e出，f进，f出。<br>选项C操作：a进，b进，b出，c进，c出，a出，d进，e进，e出，f进，f出，d出。<br>选项D操作：a进，a出，b进，c进，d进，e进，f进，f出，e出，d出，c出，b出。<br>从中看到，选项D中最后连续出栈5次，不符合要求。</p><h2 id="4、一个栈的进栈序列是a、b、c、d、e，则栈的不可能的输出序列是（-）。"><a href="#4、一个栈的进栈序列是a、b、c、d、e，则栈的不可能的输出序列是（-）。" class="headerlink" title="4、一个栈的进栈序列是a、b、c、d、e，则栈的不可能的输出序列是（ ）。"></a>4、一个栈的进栈序列是a、b、c、d、e，则栈的不可能的输出序列是（ ）。</h2><p>A.edcba<br>B.decba<br>C.dceab<br>D.abcde<br><strong>正确答案：C</strong><br>解析：<br>对于选项A，a、b、c、d、e进栈，e、d、c、b、a出栈；<br>对于选项B，a，b，c，d进栈，d出栈，e进栈，e出栈，c、b、a依次出栈；<br>对于选项C，a、b、c、d进栈，d出栈，c出栈，e进栈，e出栈，此时栈中从栈底到栈顶为a、b，不可能a先出栈，所以C是不可能的输出序列；<br>对于选项D，a进栈，a出栈，b进栈，b出栈，c进栈，c出栈，d进栈，d出栈，e进栈，e出栈。</p><h2 id="5、当用一个数组data-0…n-1-存放栈中元素时，栈底最好（-）。"><a href="#5、当用一个数组data-0…n-1-存放栈中元素时，栈底最好（-）。" class="headerlink" title="5、当用一个数组data[0…n-1]存放栈中元素时，栈底最好（ ）。"></a>5、当用一个数组data[0…n-1]存放栈中元素时，栈底最好（ ）。</h2><p>A.设置在data[0]处<br>B.设置在data[n-1]处<br>C.设置在data[0]或data[n-1]处<br>D.设置在data数组的任何位置<br><strong>正确答案：C</strong><br>解析： C、栈中元素的逻辑关系呈现线性关系，这样有两个端点，最好将栈底设置在某个端点data[0]或data[n-1]处，从而方便栈运算算法的设计。</p><p><strong>（因为栈是一种只能在一端进行插入或删除操作的线性表）</strong></p><h2 id="6、若一个栈用数组data-1…n-存储，初始栈顶指针top为n-1，则以下元素x进栈的正确操作是（-）。"><a href="#6、若一个栈用数组data-1…n-存储，初始栈顶指针top为n-1，则以下元素x进栈的正确操作是（-）。" class="headerlink" title="6、若一个栈用数组data[1…n]存储，初始栈顶指针top为n+1，则以下元素x进栈的正确操作是（ ）。"></a>6、若一个栈用数组data[1…n]存储，初始栈顶指针top为n+1，则以下元素x进栈的正确操作是（ ）。</h2><p>A.top++; data[top]&#x3D;x;<br>B.data[top]&#x3D;x; top++;<br>C.top–; data[top]&#x3D;x;<br>D.data[top]&#x3D;x; top–;<br><strong>正确答案：C</strong></p><p><strong>初始栈顶指针top为n+1，说明data[1]端作为栈顶，且元素x的进栈操作为先将栈顶指针top减1，然后将元素x放在栈顶指针处。</strong></p><h2 id="7、若一个栈用数组data-1…n-存储，初始栈顶指针top为0，则以下元素x进栈的正确操作是（-）。"><a href="#7、若一个栈用数组data-1…n-存储，初始栈顶指针top为0，则以下元素x进栈的正确操作是（-）。" class="headerlink" title="7、若一个栈用数组data[1…n]存储，初始栈顶指针top为0，则以下元素x进栈的正确操作是（ ）。"></a>7、若一个栈用数组data[1…n]存储，初始栈顶指针top为0，则以下元素x进栈的正确操作是（ ）。</h2><p>A.top++; data[top]&#x3D;x;<br>B.data[top]&#x3D;x; top++;<br>C.top–; data[top]&#x3D;x;<br>D.data[top]&#x3D;x; top–;<br><strong>正确答案：A</strong><br>解析： A、<strong>初始栈顶指针top为0，说明data[1]端作为栈底，在进栈时top应递增，由于不存在data[0]的元素，所以在进栈时应先将top递增，再将x放在top处</strong></p><h2 id="8、在设计链栈时，通常采用单链表作为链栈，而不采用双链表作为链栈，其准确的原因是（-）。"><a href="#8、在设计链栈时，通常采用单链表作为链栈，而不采用双链表作为链栈，其准确的原因是（-）。" class="headerlink" title="8、在设计链栈时，通常采用单链表作为链栈，而不采用双链表作为链栈，其准确的原因是（ ）。"></a>8、在设计链栈时，通常采用单链表作为链栈，而不采用双链表作为链栈，其准确的原因是（ ）。</h2><p>A.栈中元素是顺序存取的，用单链表就足够了<br>B.栈中元素是随机存取的，用单链表就足够了<br>C.双链表运算较单链表更复杂<br>D.双链表存储密度较单链表低<br><strong>正确答案：A</strong><br>解析： A、因为栈中元素是顺序存取的（指逐个存或取结构中的元素），而不是随机存取的，用单链表就足够了。</p><h2 id="9、栈和队列的不同点是（-）。"><a href="#9、栈和队列的不同点是（-）。" class="headerlink" title="9、栈和队列的不同点是（ ）。"></a>9、栈和队列的不同点是（ ）。</h2><p>A.都是线性表<br>B.都不是线性表<br>C.栈只能在同一端进行插入删除操作，而队列在不同端进行插入删除操作<br>D.没有不同点<br><strong>正确答案：C</strong><br>解析： C、栈和队列的不同点是，栈在同一端进行插入和删除操作，而队列在不同端进行插入和删除操作。</p><h2 id="10、设循环队列qu中数组data的下标是0～N-1，其队头、队尾指针分别为f和r（f指向队首元素的前一位置，r指向队尾元素），元素x进队的操作是（）-qu-data-qu-rear-x3D-x。"><a href="#10、设循环队列qu中数组data的下标是0～N-1，其队头、队尾指针分别为f和r（f指向队首元素的前一位置，r指向队尾元素），元素x进队的操作是（）-qu-data-qu-rear-x3D-x。" class="headerlink" title="10、设循环队列qu中数组data的下标是0～N-1，其队头、队尾指针分别为f和r（f指向队首元素的前一位置，r指向队尾元素），元素x进队的操作是（）;qu.data[qu.rear]&#x3D;x。"></a>10、设<a href="https://so.csdn.net/so/search?q=%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97&spm=1001.2101.3001.7020">循环队列</a>qu中数组data的下标是0～N-1，其队头、队尾指针分别为f和r（f指向队首元素的前一位置，r指向队尾元素），元素x进队的操作是（）;qu.data[qu.rear]&#x3D;x。</h2><p>A.qu.rear++<br>B.qu.rear&#x3D;(qu.rear+1)%N<br>C.qu.front++;<br>D.qu.front&#x3D;(qu.front+1)%N<br><strong>正确答案：B</strong><br>解析： B、对于循环队列，进队操作仅移动队尾指针，元素x进队的操作是<br>qu.rear&#x3D;(qu.rear+1)%N;<br>qu.data[qu.rear]&#x3D;x。</p><p><strong>课本考据：<br>在队列不满的条件下先将队尾指针rear循环增1，然后将元素插入到该位置。算法如下</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">bool</span> <span class="hljs-title function_">enQueue</span><span class="hljs-params">(SqQueue *&amp;q,ElemType e)</span><br>&#123;<br><span class="hljs-keyword">if</span> ((q-&gt;rear+<span class="hljs-number">1</span>)%Maxsize==q-&gt;front)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>q-&gt;rear=(q-&gt;rear+<span class="hljs-number">1</span>)%MaxSize;<br>q-&gt;data[q-&gt;rear]=e;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-number">12345678</span><br></code></pre></td></tr></table></figure><h2 id="11、设循环队列qu中数组data的下标是0～N-1，其队头、队尾指针分别为f和r（f指向队首元素的前一位置，r指向队尾元素），元素x出队的操作是（-）-x-x3D-qu-data-qu-front-。"><a href="#11、设循环队列qu中数组data的下标是0～N-1，其队头、队尾指针分别为f和r（f指向队首元素的前一位置，r指向队尾元素），元素x出队的操作是（-）-x-x3D-qu-data-qu-front-。" class="headerlink" title="11、设循环队列qu中数组data的下标是0～N-1，其队头、队尾指针分别为f和r（f指向队首元素的前一位置，r指向队尾元素），元素x出队的操作是（ ）;x&#x3D;qu.data[qu.front]。"></a>11、设循环队列qu中数组data的下标是0～N-1，其队头、队尾指针分别为f和r（f指向队首元素的前一位置，r指向队尾元素），元素x出队的操作是（ ）;x&#x3D;qu.data[qu.front]。</h2><p>A.qu.rear++<br>B.qu.rear&#x3D;(qu.rear+1)%N<br>C.qu.front++;<br>D.qu.front&#x3D;(qu.front+1)%N<br><strong>正确答案：D</strong><br>解析： D、对于循环队列，出队操作仅移动队头指针，元素x出队的操作是：qu.front&#x3D;(qu.front+1)%N;<br>x&#x3D;qu.data[qu.rear]。</p><p>课本考据：在队列q不空的条件下将队首指针front循环增1，取出该位置的元素并赋值给e。算法如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">bool</span> <span class="hljs-title function_">deQueue</span><span class="hljs-params">(SqQueue *&amp;q,ElemType e)</span><br>&#123;<br><span class="hljs-keyword">if</span> (q-&gt;front==q-&gt;rear)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>q-&gt;front=(q-&gt;front+<span class="hljs-number">1</span>)%MaxSize;<br>e=q-&gt;dara[q-&gt;front];<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-number">12345678</span><br></code></pre></td></tr></table></figure><h2 id="12、若某循环队列有队首指针front和队尾指针rear，在队不空时出队操作仅会改变（-）。"><a href="#12、若某循环队列有队首指针front和队尾指针rear，在队不空时出队操作仅会改变（-）。" class="headerlink" title="12、若某循环队列有队首指针front和队尾指针rear，在队不空时出队操作仅会改变（ ）。"></a>12、若某循环队列有队首指针front和队尾指针rear，在队不空时出队操作仅会改变（ ）。</h2><p>A.front<br>B.rear<br>C.front和rear<br>D.以上都不对<br><strong>正确答案：A</strong><br>解析： A、<strong>当循环队列不空时，出队操作只能改变队头指针front。</strong></p><h2 id="13、通常设置循环队列qu的队空条件（front队首指针指向队首元素的前一位置，rear队尾指针指向队尾元素）是（-）。"><a href="#13、通常设置循环队列qu的队空条件（front队首指针指向队首元素的前一位置，rear队尾指针指向队尾元素）是（-）。" class="headerlink" title="13、通常设置循环队列qu的队空条件（front队首指针指向队首元素的前一位置，rear队尾指针指向队尾元素）是（ ）。"></a>13、通常设置循环队列qu的队空条件（front队首指针指向队首元素的前一位置，rear队尾指针指向队尾元素）是（ ）。</h2><p>A.(qu.rear+1)%MaxSize &#x3D;&#x3D; (qu.front+1)%MaxSize<br>B.(qu.rear+1)%MaxSize &#x3D;&#x3D; qu.front+1<br>C.(qu.rear+1)%MaxSize &#x3D;&#x3D; qu.front<br>D.qu.rea r &#x3D;&#x3D; qu.front<br><strong>正确答案：D</strong><br>解析： D、在循环队列中，通常设置队头等于队尾时表示队空。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">bool</span> <span class="hljs-title function_">QueueEmpty</span><span class="hljs-params">(SqQueue * q)</span><br>&#123;<br><span class="hljs-keyword">return</span>(q-&gt;front==q-&gt;rear);<br>&#125;<br><span class="hljs-number">1234</span><br></code></pre></td></tr></table></figure><h2 id="14、设循环队列的存储空间为a-0…20-，且当前队头指针（f指向队首元素的前一位置）和队尾指针（r指向队尾元素）的值分别为8和3，则该队列中元素个数为（-）。"><a href="#14、设循环队列的存储空间为a-0…20-，且当前队头指针（f指向队首元素的前一位置）和队尾指针（r指向队尾元素）的值分别为8和3，则该队列中元素个数为（-）。" class="headerlink" title="14、设循环队列的存储空间为a[0…20]，且当前队头指针（f指向队首元素的前一位置）和队尾指针（r指向队尾元素）的值分别为8和3，则该队列中元素个数为（ ）。"></a>14、设循环队列的存储空间为a[0…20]，且当前队头指针（f指向队首元素的前一位置）和队尾指针（r指向队尾元素）的值分别为8和3，则该队列中元素个数为（ ）。</h2><p>A.5<br>B.6<br>C.16<br>D.17<br><strong>正确答案：C</strong><br>解析： C、<strong>这里MaxSize&#x3D;21，其中的元素个数&#x3D;<br>(r-f+MaxSize)%MaxSize&#x3D;16。</strong></p><h2 id="15、假设用一个不带头节点的单链表表示队列，队头在链表的（-）位置。"><a href="#15、假设用一个不带头节点的单链表表示队列，队头在链表的（-）位置。" class="headerlink" title="15、假设用一个不带头节点的单链表表示队列，队头在链表的（ ）位置。"></a>15、假设用一个不带头节点的单链表表示队列，队头在链表的（ ）位置。</h2><p>A.链头<br>B.链尾<br>C.链中<br>D.以上都可以<br><strong>正确答案：A</strong><br>解析： A、在用单链表表示的链队中，以单链表的链头作为队头，以单链表的链尾作为队尾。</p><h2 id="16、与顺序队相比，链队（-）。"><a href="#16、与顺序队相比，链队（-）。" class="headerlink" title="16、与顺序队相比，链队（ ）。"></a>16、与顺序队相比，链队（ ）。</h2><p>A.优点是可以实现无限长队列<br>B.优点是进队和出队时间性能更好<br>C.缺点是不能进行顺序访问<br>D.缺点是不能根据队首和队尾指针计算队的长度<br><strong>正确答案：D</strong><br>解析： D、尽管链队总是采用动态分配方式，其长度也受内存大小的限制，也不可能实现无限长队列。顺序队和链队的进队和出队操作时间均为O(1)。顺序队和链队都可以进行顺序访问。在顺序队中可以通过队头和队尾指针计算队中元素个数，而链队不能。</p><h2 id="17、若用一个大小为6的数组来实现循环队列，且当前rear和front的值分别为0和3，当从队列中删除一个元素，再加入两个元素后，rear和front的值分别为（-）。"><a href="#17、若用一个大小为6的数组来实现循环队列，且当前rear和front的值分别为0和3，当从队列中删除一个元素，再加入两个元素后，rear和front的值分别为（-）。" class="headerlink" title="17、若用一个大小为6的数组来实现循环队列，且当前rear和front的值分别为0和3，当从队列中删除一个元素，再加入两个元素后，rear和front的值分别为（ ）。"></a>17、若用一个大小为6的数组来实现循环队列，且当前rear和front的值分别为0和3，当从队列中删除一个元素，再加入两个元素后，rear和front的值分别为（ ）。</h2><p>A.1和5<br>B.2和4<br>C.4和2<br>D.5和1<br><strong>正确答案：B</strong><br>解析： B、rear&#x3D;0，进队2个元素后，rear循环递增2，rear&#x3D;2；front&#x3D;3，出队一个元素后，front循环递增1，front&#x3D;4。</p><h2 id="18、一个循环队列中用data-0…n-1-数组保存队中元素，另设置一个队尾指针rear和一个记录队中实际元素个数的变量count，则该队中最多可以存放的元素个数是（-）。"><a href="#18、一个循环队列中用data-0…n-1-数组保存队中元素，另设置一个队尾指针rear和一个记录队中实际元素个数的变量count，则该队中最多可以存放的元素个数是（-）。" class="headerlink" title="18、一个循环队列中用data[0…n-1]数组保存队中元素，另设置一个队尾指针rear和一个记录队中实际元素个数的变量count，则该队中最多可以存放的元素个数是（ ）。"></a>18、一个循环队列中用data[0…n-1]数组保存队中元素，另设置一个队尾指针rear和一个记录队中实际元素个数的变量count，则该队中最多可以存放的元素个数是（ ）。</h2><p>A.n-1<br>B.n<br>C.(rear+n) % n<br>D.(n-rear) % n<br><strong>正确答案：B</strong><br>解析： B、队满的条件为count&#x3D;&#x3D;n。</p><h2 id="19、已知循环队列存储在一维数组A-0…n-1-中，且队列非空时front和rear分别指向队头元素和队尾元素。若初始时队列空，且要求第一个进入队列的元素存储在A-0-处，则初始时front和rear的值分别是（-）。"><a href="#19、已知循环队列存储在一维数组A-0…n-1-中，且队列非空时front和rear分别指向队头元素和队尾元素。若初始时队列空，且要求第一个进入队列的元素存储在A-0-处，则初始时front和rear的值分别是（-）。" class="headerlink" title="19、已知循环队列存储在一维数组A[0…n-1]中，且队列非空时front和rear分别指向队头元素和队尾元素。若初始时队列空，且要求第一个进入队列的元素存储在A[0]处，则初始时front和rear的值分别是（ ）。"></a>19、已知循环队列存储在一维数组A[0…n-1]中，且队列非空时front和rear分别指向队头元素和队尾元素。若初始时队列空，且要求第一个进入队列的元素存储在A[0]处，则初始时front和rear的值分别是（ ）。</h2><p>A.0，0<br>B.0，n-1<br>C.n-1，0<br>D. n-1，n-1<br><strong>正确答案：B</strong><br>解析： B、在循环队列中，进队操作是队尾指针rear循环加1，再在该处放置进队的元素，本题要求第一个进入队列的元素存储在A[0]处，则rear应为n-1，因为这样(rear+1)%n&#x3D;0。而队头指向队头元素，此时队头位置为0，所以front的初值为0。</p><h2 id="20、在循环队列中，元素的排列顺序（-）。"><a href="#20、在循环队列中，元素的排列顺序（-）。" class="headerlink" title="20、在循环队列中，元素的排列顺序（ ）。"></a>20、在循环队列中，元素的排列顺序（ ）。</h2><p>A.由元素进队的先后顺序确定<br>B.与元素值的大小有关<br>C.与队头和队尾指针的取值有关<br>D.与队中数组大小有关<br><strong>正确答案：A</strong><br>解析： A、在循环队列中，元素的排列顺序仅与元素进队的先后顺序有关。</p><hr><h1 id="第五周测验"><a href="#第五周测验" class="headerlink" title="第五周测验"></a>第五周测验</h1><h2 id="1、下面关于串的叙述中，正确的是（-）。"><a href="#1、下面关于串的叙述中，正确的是（-）。" class="headerlink" title="1、下面关于串的叙述中，正确的是（ ）。"></a>1、下面关于串的叙述中，正确的是（ ）。</h2><p>A.串是一种特殊的<a href="https://so.csdn.net/so/search?q=%E7%BA%BF%E6%80%A7%E8%A1%A8&spm=1001.2101.3001.7020">线性表</a><br>B.串中元素只能是字母<br>C.空串就是空白串<br>D.串的长度必须大于零<br><strong>正确答案：A</strong><br>解析： A、串是一种特殊的线性表，其元素为单个字符，长度可以为0。</p><p><strong>课本考据：<br>1）字符串简称为串，串是由字符元素构成的，其中元素的逻辑关系也是一种线性关系。<br>2）在一般情况下，英文字母、数字（0，1，·····9）和常用的标点符号以及空格符等都是合法的字符。<br>3）含零个字符的串称为空串。</strong></p><h2 id="2、两个字符串相等的条件是（-）。"><a href="#2、两个字符串相等的条件是（-）。" class="headerlink" title="2、两个字符串相等的条件是（ ）。"></a>2、两个字符串相等的条件是（ ）。</h2><p>A.串的长度相等<br>B.含有相同的字符集<br>C.都是非空串<br>D.两个串的长度相等且对应位置的字符相同<br><strong>正确答案：D</strong></p><p><strong>课本考据：两个串相等当且仅当这两个串的长度相等并且个对应位置上的字符都相同。</strong></p><h2 id="3、若串str-x3D-“Software”，其子串的个数是（-）。"><a href="#3、若串str-x3D-“Software”，其子串的个数是（-）。" class="headerlink" title="3、若串str&#x3D;“Software”，其子串的个数是（ ）。"></a>3、若串str&#x3D;“Software”，其子串的个数是（ ）。</h2><p>A.8<br>B.9<br>C.36<br>D.37<br><strong>正确答案：D</strong><br>解析： D、该串中所有字符不相同，长度为0的子串1个，长度为1的子串8个，长度为2的子串7个，…，长度为7的子串2个，长度为8的子串1个，总计子串数&#x3D;1+8+7+…+2+1&#x3D;1+8×9&#x2F;2&#x3D;37。</p><h2 id="4、一个链串的节点类型定义为-define-NodeSize-6"><a href="#4、一个链串的节点类型定义为-define-NodeSize-6" class="headerlink" title="4、一个链串的节点类型定义为#define NodeSize 6"></a>4、一个链串的节点类型定义为#define NodeSize 6</h2><p>typedef struct node<br>{<br>char data[NodeSize];<br>struct node *next;<br>} LinkStrNode;<br>如果每个字符占1个字节，指针占2个字节，该链串的存储密度为（ ）。<br>A.1&#x2F;3<br>B.1&#x2F;2<br>C.2&#x2F;3<br>D.3&#x2F;4<br><strong>正确答案：D</strong><br>解析： D、链串节点大小指每个节点存放的字符个数，本题节点大小为6，存储密度&#x3D;(6 * 1)&#x2F;(6 * 1+2)&#x3D;3&#x2F;4。</p><h2 id="5、串采用节点大小为1的链表作为其存储结构，是指（-）。"><a href="#5、串采用节点大小为1的链表作为其存储结构，是指（-）。" class="headerlink" title="5、串采用节点大小为1的链表作为其存储结构，是指（ ）。"></a>5、串采用节点大小为1的链表作为其存储结构，是指（ ）。</h2><p>A.链表的长度为1<br>B.链表中只存放一个字符<br>C.链表中每个节点的数据域中只存放一个字符<br>D.以上都不对<br><strong>正确答案：C</strong><br>解析： C、链串节点大小指每个节点存放的字符个数。</p><h2 id="6、对于一个链串s，查找第一个字符值为x的算法的时间复杂度为（-）。"><a href="#6、对于一个链串s，查找第一个字符值为x的算法的时间复杂度为（-）。" class="headerlink" title="6、对于一个链串s，查找第一个字符值为x的算法的时间复杂度为（ ）。"></a>6、对于一个链串s，查找第一个字符值为x的算法的时间复杂度为（ ）。</h2><p>A.O(1)<br>B.O(n)<br>C.O(n2)<br>D.以上都不对<br><strong>正确答案：B</strong><br>解析： B、在链串查找第一个字符值为x的算法的时间复杂度为O(n)。</p><h2 id="7、设有两个串p和q，其中q是p的子串，则求q在p中首次出现位置的算法称为（-）。"><a href="#7、设有两个串p和q，其中q是p的子串，则求q在p中首次出现位置的算法称为（-）。" class="headerlink" title="7、设有两个串p和q，其中q是p的子串，则求q在p中首次出现位置的算法称为（ ）。"></a>7、设有两个串p和q，其中q是p的子串，则求q在p中首次出现位置的算法称为（ ）。</h2><p>A.求子串<br>B.串联接<br>C.模式匹配<br>D.求串长<br><strong>正确答案：C</strong><br>解析： C、模式匹配算法就是找子串在主串中的位置。</p><h2 id="8、在串的简单模式匹配中，当模式串位j与目标串位i比较时，两字符不相等，则i的位移方式是（-）。"><a href="#8、在串的简单模式匹配中，当模式串位j与目标串位i比较时，两字符不相等，则i的位移方式是（-）。" class="headerlink" title="8、在串的简单模式匹配中，当模式串位j与目标串位i比较时，两字符不相等，则i的位移方式是（ ）。"></a>8、在串的简单模式匹配中，当模式串位j与目标串位i比较时，两字符不相等，则i的位移方式是（ ）。</h2><p>A.i++<br>B.i&#x3D;j+1<br>C.i&#x3D;i-j+1<br>D.i&#x3D;j-i+1<br><strong>正确答案：C</strong><br>解析： C、在串的简单模式匹配(BF算法)中，当两字符比较不等时，目标串位i回溯到原来位置的下一个位置，即i&#x3D;i-j+1。</p><h2 id="9、在KMP模式匹配中，用next数组存放模式串的部分匹配信息。当模式串位j与目标串位i比较时，两字符不相等，则i的位移方式是（-）。"><a href="#9、在KMP模式匹配中，用next数组存放模式串的部分匹配信息。当模式串位j与目标串位i比较时，两字符不相等，则i的位移方式是（-）。" class="headerlink" title="9、在KMP模式匹配中，用next数组存放模式串的部分匹配信息。当模式串位j与目标串位i比较时，两字符不相等，则i的位移方式是（ ）。"></a>9、在KMP模式匹配中，用next数组存放模式串的部分匹配信息。当模式串位j与目标串位i比较时，两字符不相等，则i的位移方式是（ ）。</h2><p>A.i&#x3D;next[j]<br>B.i不变<br>C…j不变<br>D.j&#x3D;next[j]<br><strong>正确答案：B</strong><br>解析： B、在KMP模式匹配中，当两字符比较不等时，目标串位i不回溯，仍停留在原来的位置。</p><h2 id="10、在KMP模式匹配中，用next数组存放模式串的部分匹配信息。当模式串位j与目标串位i比较时，两字符不相等，则j的位移方式是（-）。"><a href="#10、在KMP模式匹配中，用next数组存放模式串的部分匹配信息。当模式串位j与目标串位i比较时，两字符不相等，则j的位移方式是（-）。" class="headerlink" title="10、在KMP模式匹配中，用next数组存放模式串的部分匹配信息。当模式串位j与目标串位i比较时，两字符不相等，则j的位移方式是（ ）。"></a>10、在KMP模式匹配中，用next数组存放模式串的部分匹配信息。当模式串位j与目标串位i比较时，两字符不相等，则j的位移方式是（ ）。</h2><p>A.i&#x3D;next[j]<br>B.i不变<br>C.j不变<br>D.j&#x3D;next[j]<br><strong>正确答案：D</strong><br>解析： D、在KMP模式匹配中，当两字符比较不等时，目标串位i不改变，将其位置字符与模式串中next[j]位置的字符比较，即j&#x3D;next[j]。</p><hr><h1 id="第六周测验"><a href="#第六周测验" class="headerlink" title="第六周测验"></a>第六周测验</h1><h2 id="1、一个正确的递归算法通常包含（-）。"><a href="#1、一个正确的递归算法通常包含（-）。" class="headerlink" title="1、一个正确的递归算法通常包含（ ）。"></a>1、一个正确的<a href="https://so.csdn.net/so/search?q=%E9%80%92%E5%BD%92%E7%AE%97%E6%B3%95&spm=1001.2101.3001.7020">递归算法</a>通常包含（ ）。</h2><p>A.递归出口<br>B.递归体<br>C.递归出口和递归体<br>D.以上都不包含<br><strong>正确答案：C</strong><br>解析： C、正确的递归算法应包含递归出口和递归体两部分，缺一不可。</p><p><strong>课本考据：递归算法设计的基本步骤是先确定求解问题的递归模型，在转换成对应的 C&#x2F;C++语言函数。而一个递归体模型由递归出口（确定结束条件）和递归体（确定递推关系）两部分组成。</strong></p><h2 id="2、递归函数f-x，y-定义如下："><a href="#2、递归函数f-x，y-定义如下：" class="headerlink" title="2、递归函数f(x，y)定义如下："></a>2、<a href="https://so.csdn.net/so/search?q=%E9%80%92%E5%BD%92%E5%87%BD%E6%95%B0&spm=1001.2101.3001.7020">递归函数</a>f(x，y)定义如下：</h2><p>f(x，y)&#x3D;f(x-1，y)+f(x，y-1) 当x&gt;0且y&gt;0<br>f(x，y)&#x3D;x+y 否则<br>则f(2，1)的值是（ ）。<br>A.1<br>B.2<br>C.3<br>D.4<br><strong>正确答案：D</strong><br>解析： D、f(2,1)&#x3D;f(1,1)+f(2,0)&#x3D;f(0,1)+f(1,0)+2&#x3D;1+1+2&#x3D;4。</p><h2 id="3、某递归算法的执行时间的递推关系如下："><a href="#3、某递归算法的执行时间的递推关系如下：" class="headerlink" title="3、某递归算法的执行时间的递推关系如下："></a>3、某递归算法的执行时间的递推关系如下：</h2><p>T(n)&#x3D;1 当n&#x3D;1时<br>T(n)&#x3D;T(n&#x2F;2)+1 当n&gt;1时<br>则该算法的时间复杂度为（ ）。<br>A.O(1)<br>B.O(log2n)<br>C.O(n)<br>D.O(nlog2n)<br><strong>正确答案：B</strong><br>解析： B、不妨设n&#x3D;2^k，k&#x3D;log2n。<br>T(n)&#x3D;T(n&#x2F;2)+1&#x3D; T(n&#x2F;22)+2&#x3D;…&#x3D; T(n&#x2F;2k)+k&#x3D;T(1)+log2n&#x3D;O(log2n)。</p><h2 id="4、某递归算法的执行时间的递推关系如下："><a href="#4、某递归算法的执行时间的递推关系如下：" class="headerlink" title="4、某递归算法的执行时间的递推关系如下："></a>4、某递归算法的执行时间的递推关系如下：</h2><p>T(n)&#x3D;1 当n&#x3D;1时<br>T(n)&#x3D;2T(n&#x2F;2)+1 当n&gt;1时<br>则该算法的时间复杂度为（ ）。<br>A.O(1)<br>B.O(log2n)<br>C.O(n)<br>D.O(log2n)<br><strong>正确答案：C</strong><br>解析： C、不妨设n&#x3D;2^k，k&#x3D;log2n。<br>T(n)&#x3D;21<em>T(n&#x2F;21)+1&#x3D;22</em>T(n&#x2F;22)+1+21&#x3D;…&#x3D;2kT(n&#x2F;2k)+1+21+…+2(k-1)&#x3D;2kT(1)+2k-1&#x3D;2n-1&#x3D;O(n)。</p><h2 id="5、将递归算法转换成非递归算法时，通常要借助的数据结构是（-）。"><a href="#5、将递归算法转换成非递归算法时，通常要借助的数据结构是（-）。" class="headerlink" title="5、将递归算法转换成非递归算法时，通常要借助的数据结构是（ ）。"></a>5、将递归算法转换成非递归算法时，通常要借助的数据结构是（ ）。</h2><p>A.线性表<br>B.栈<br>C.队列<br>D.树<br><strong>正确答案：B</strong><br>解析： B、递归算法转换成非递归算法时通常使用栈。</p><p><strong>课本考据：大多数CPU上的程序实现使用栈来支持函数调用操作。</strong></p><hr><h1 id="第七周测验"><a href="#第七周测验" class="headerlink" title="第七周测验"></a>第七周测验</h1><h2 id="1、有一个三维数组A-2…2-4…5-2…6-，其中元素个数是（-）。"><a href="#1、有一个三维数组A-2…2-4…5-2…6-，其中元素个数是（-）。" class="headerlink" title="1、有一个三维数组A[-2…2][-4…5][2…6]，其中元素个数是（ ）。"></a>1、有一个三维数组A[-2…2][-4…5][2…6]，其中元素个数是（ ）。</h2><p>A.144<br>B.60<br>C.396<br>D.250<br><strong>正确答案：D</strong><br>解析： D、A的第1维长度为5【2-（-2）+1：-2，-1，0，1，2】，第2维长度为10【5-（-4）+1：-4，-3，-2，-1，0，1，2，3，4，5】，第3维长度为5【6-2+1：2，3，4，5，6】，元素个数&#x3D;5×10×5&#x3D;250。</p><p><strong>课本考据：一个的二维数组可看作是每个数据元素都是相同类型的一维数组的一维数组。如下图所示：</strong><br><img src="/../imgs/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%88%B7%E9%A2%98/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzAwNDU0MA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>故，任何多维数组都可看作一个线性表。**</p><h2 id="2、设C-x2F-C-二维数组a-m-n-，每个数组元素占用k个存储单元，第一个数组元素的存储地址是LOC-a-0-0-，求按行优先顺序存放的数组元素a-i-j-（0≤i≤m-1，0≤j≤n-1）的存储地址为（-）。"><a href="#2、设C-x2F-C-二维数组a-m-n-，每个数组元素占用k个存储单元，第一个数组元素的存储地址是LOC-a-0-0-，求按行优先顺序存放的数组元素a-i-j-（0≤i≤m-1，0≤j≤n-1）的存储地址为（-）。" class="headerlink" title="2、设C&#x2F;C++二维数组a[m][n]，每个数组元素占用k个存储单元，第一个数组元素的存储地址是LOC(a[0][0])，求按行优先顺序存放的数组元素a[i][j]（0≤i≤m-1，0≤j≤n-1）的存储地址为（ ）。"></a>2、设C&#x2F;C++<a href="https://so.csdn.net/so/search?q=%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84&spm=1001.2101.3001.7020">二维数组</a>a[m][n]，每个数组元素占用k个存储单元，第一个数组元素的存储地址是LOC(a[0][0])，求按行优先顺序存放的数组元素a[i][j]（0≤i≤m-1，0≤j≤n-1）的存储地址为（ ）。</h2><p>A.LOC(a[0][0])+[i×n+j]×k<br>B.LOC(a[0][0])+[j×m+i]×k<br>C.LOC(a[0][0])+[(j-1)×m+i-1]×k<br>D.LOC(a[0][0])+[(i-1)×n+j-1]×k<br><strong>正确答案：A</strong><br>解析： A、a[i][j]前面有0～i-1行，计i×n个元素，第i行前面有j个元素，则a[i][j]前面有i×m+ j个元素，所以a[i][j]的存储地址&#x3D;LOC(a[0][0])+[i×n+j]×k。</p><p><strong>课本考据：在内存中元素a[i][j]前面有i行，每行有n个元素，即已存放了i×n个元素，占用了i×n×k个内存单元；在第i行中元素a[i][j]前面有j个元素，即已存放了j个元素，占用了j-1乘k个内存单元；</strong></p><h2 id="3、设二维数组a-1…5-1…8-，若按行优先的顺序存放数组的元素，则a-4-6-元素的前面有（-）个元素。"><a href="#3、设二维数组a-1…5-1…8-，若按行优先的顺序存放数组的元素，则a-4-6-元素的前面有（-）个元素。" class="headerlink" title="3、设二维数组a[1…5][1…8]，若按行优先的顺序存放数组的元素，则a[4][6]元素的前面有（ ）个元素。"></a>3、设二维数组a[1…5][1…8]，若按行优先的顺序存放数组的元素，则a[4][6]元素的前面有（ ）个元素。</h2><p>A.6<br>B.28<br>C.29<br>D.40<br><strong>正确答案：C</strong><br>解析： C、m&#x3D;5，n&#x3D;8，a[4][6]元素的前面的元素个数&#x3D;(4-1) ×8+(6-1)&#x3D;29。</p><p><strong>课本考据：二维数组按行优先存放的示意图如<img src="/../imgs/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%88%B7%E9%A2%98/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA54yq6ISa546L,size_20,color_FFFFFF,t_70,g_se,x_16-168761569918718.png" alt="在这里插入图片描述"><br><img src="/../imgs/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%88%B7%E9%A2%98/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA54yq6ISa546L,size_20,color_FFFFFF,t_70,g_se,x_16-168761569778215.png" alt="在这里插入图片描述"><br>得该二维数组中任一元素a的存储地址，其中k为存储单元。</strong></p><h2 id="4、设C-x2F-C-二维数组a-6-10-，每个数组元素占用4个存储单元，若按行优先顺序存放所有数组元素，a-3-5-的存储地址为1000，则a-0-0-的存储地址是（-）。"><a href="#4、设C-x2F-C-二维数组a-6-10-，每个数组元素占用4个存储单元，若按行优先顺序存放所有数组元素，a-3-5-的存储地址为1000，则a-0-0-的存储地址是（-）。" class="headerlink" title="4、设C&#x2F;C++二维数组a[6][10]，每个数组元素占用4个存储单元，若按行优先顺序存放所有数组元素，a[3][5]的存储地址为1000，则a[0][0]的存储地址是（ ）。"></a>4、设C&#x2F;C++二维数组a[6][10]，每个<a href="https://so.csdn.net/so/search?q=%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0&spm=1001.2101.3001.7020">数组元素</a>占用4个存储单元，若按行优先顺序存放所有数组元素，a[3][5]的存储地址为1000，则a[0][0]的存储地址是（ ）。</h2><p>A.868<br>B.872<br>C.860<br>D.864<br><strong>正确答案：C</strong><br>解析： C、C&#x2F;C++二维数组下标从0开始。a[3][5]前面的元素个数&#x3D;(3-0)×10+(5-0)&#x3D;35。所以1000&#x3D;LOC(a[0][0])+35×4，LOC(a[0][0])&#x3D;860。</p><h2 id="5、一个n阶对称矩阵A采用压缩存储方式，将其下三角部分（含主对角线元素）按行优先存储到一维数组B中，则B中元素个数是（-）。"><a href="#5、一个n阶对称矩阵A采用压缩存储方式，将其下三角部分（含主对角线元素）按行优先存储到一维数组B中，则B中元素个数是（-）。" class="headerlink" title="5、一个n阶对称矩阵A采用压缩存储方式，将其下三角部分（含主对角线元素）按行优先存储到一维数组B中，则B中元素个数是（ ）。"></a>5、一个n阶对称矩阵A采用压缩存储方式，将其下三角部分（含主对角线元素）按行优先存储到一维数组B中，则B中元素个数是（ ）。</h2><p>A.n(n+1)&#x2F;2+1<br>B.n(n+1)&#x2F;2<br>C.n<br>D.n*n<br><strong>正确答案：B</strong></p><p><strong>课本考据：特殊矩阵是指非零元素或零元素得分布具有一定规律得矩阵，为了节省存储空间，特别是在高阶矩阵的情况下可以利用特殊矩阵的对它们进行压缩存储以提高存储空间效率。将特殊矩阵压缩规律如图表示<img src="/../imgs/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%88%B7%E9%A2%98/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA54yq6ISa546L,size_20,color_FFFFFF,t_70,g_se,x_16-168761569450612.png" alt="在这里插入图片描述"><br><img src="/../imgs/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%88%B7%E9%A2%98/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA54yq6ISa546L,size_20,color_FFFFFF,t_70,g_se,x_16-16876156923419.png" alt="在这里插入图片描述"><br><img src="/../imgs/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%88%B7%E9%A2%98/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA54yq6ISa546L,size_20,color_FFFFFF,t_70,g_se,x_16.png" alt="在这里插入图片描述"><br>显然，一维数组B中存放的元素个数为1+2+…+n&#x3D;n(n+1)&#x2F;2。</strong></p><h2 id="6、一个n阶对称矩阵A-1…n，1…n-采用压缩存储方式，将其下三角部分按行优先存储到一维数组B-1…m-中，则A-i-j-（i-lt-j）元素在B中的位置k是（-）。"><a href="#6、一个n阶对称矩阵A-1…n，1…n-采用压缩存储方式，将其下三角部分按行优先存储到一维数组B-1…m-中，则A-i-j-（i-lt-j）元素在B中的位置k是（-）。" class="headerlink" title="6、一个n阶对称矩阵A[1…n，1…n]采用压缩存储方式，将其下三角部分按行优先存储到一维数组B[1…m]中，则A[i][j]（i&lt;j）元素在B中的位置k是（ ）。"></a>6、一个n阶对称矩阵A[1…n，1…n]采用压缩存储方式，将其下三角部分按行优先存储到一维数组B[1…m]中，则A[i][j]（i&lt;j）元素在B中的位置k是（ ）。</h2><p>A.j(j-1)&#x2F;2+i<br>B.j(j-1)&#x2F;2+i-1<br>C.i(i-1)&#x2F;2+j-1<br>D. i(i-1)&#x2F;2+j<br><strong>正确答案：A</strong><br>解析： A、对于下三角部分或者主对角线元素a[i][j]，它存储在b[k]中，k&#x3D;i(i-1)&#x2F;2+j。对于上三角部分元素A[i][j]（i&lt;j），对应的k&#x3D;j(j-1)&#x2F;2+i。</p><h2 id="7、一个n阶上三角矩阵A按行优先顺序压缩存放在一维数组B，则B中元素个数是（-）。"><a href="#7、一个n阶上三角矩阵A按行优先顺序压缩存放在一维数组B，则B中元素个数是（-）。" class="headerlink" title="7、一个n阶上三角矩阵A按行优先顺序压缩存放在一维数组B，则B中元素个数是（ ）。"></a>7、一个n阶上三角矩阵A按行优先顺序压缩存放在一维数组B，则B中元素个数是（ ）。</h2><p>A.n*n<br>B.n(n+1)&#x2F;2+1<br>C.n<br>D.n(n+1)&#x2F;2<br><strong>正确答案：B</strong></p><p>**课本考据：对于上三角矩阵的压缩存储方法是采用 以行序为主序存储对其主对角线加上三角部分的元素，另外用一个元素存储常数c，并将压缩结果存放在一维数组B中，如图<img src="/../imgs/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%88%B7%E9%A2%98/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA54yq6ISa546L,size_20,color_FFFFFF,t_70,g_se,x_16-16876156836786.png" alt="在这里插入图片描述"><br><img src="/../imgs/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%88%B7%E9%A2%98/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA54yq6ISa546L,size_20,color_FFFFFF,t_70,g_se,x_16-16876156801933.png" alt="在这里插入图片描述"></p><p>显然，B中元素的个数为n(n+1)&#x2F;2+1，即用B[0…n(n+1)&#x2F;2]存放A 中的元素。**</p><h2 id="8、一个n-n-gt-3-阶三对角矩阵A按行优先顺序压缩存放在一维数组B，则B中元素个数是（-）。"><a href="#8、一个n-n-gt-3-阶三对角矩阵A按行优先顺序压缩存放在一维数组B，则B中元素个数是（-）。" class="headerlink" title="8、一个n(n&gt;3)阶三对角矩阵A按行优先顺序压缩存放在一维数组B，则B中元素个数是（ ）。"></a>8、一个n(n&gt;3)阶三对角矩阵A按行优先顺序压缩存放在一维数组B，则B中元素个数是（ ）。</h2><p>A.3n-2<br>B.2n<br>C.n*n<br>D.3n<br><strong>正确答案：A</strong></p><p><strong>课本考据：若 一个n阶方阵A 满足其所有非零元素都集中在对主对角线为中心的带状区域中。则称为n阶对角矩阵。<img src="/../imgs/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%88%B7%E9%A2%98/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA54yq6ISa546L,size_20,color_FFFFFF,t_70,g_se,x_16-168761996540033.png" alt="在这里插入图片描述"></strong></p><h2 id="9、稀疏矩阵常用的压缩存储方法有（-）。"><a href="#9、稀疏矩阵常用的压缩存储方法有（-）。" class="headerlink" title="9、稀疏矩阵常用的压缩存储方法有（ ）。"></a>9、稀疏矩阵常用的压缩存储方法有（ ）。</h2><p>A.二维数组<br>B.哈希表和十字链表<br>C.三元组和哈希表<br>D.三元组和十字链表<br><strong>正确答案：D</strong></p><p><strong>课本考据：把稀疏矩阵的三元组线性表按顺序存储结构存储，则称为稀疏矩阵的三元组顺序表（简称为三元组表）；十字链表是稀疏矩阵的 一种链式存储结构。</strong></p><h2 id="10、稀疏矩阵采用压缩存储后的缺点之一是（-）。"><a href="#10、稀疏矩阵采用压缩存储后的缺点之一是（-）。" class="headerlink" title="10、稀疏矩阵采用压缩存储后的缺点之一是（ ）。"></a>10、稀疏矩阵采用压缩存储后的缺点之一是（ ）。</h2><p>A.丧失随机存取特性<br>B.无法由行、列值查找某个矩阵元素<br>C.无法判断矩阵的行列数<br>D.使矩阵元素之间的逻辑关系更加复杂<br><strong>正确答案：A</strong></p>]]></content>
    
    
    <categories>
      
      <category>考试复习</category>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
      <tag>考试复习</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
